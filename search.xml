<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客的搜索功能</title>
      <link href="/2023/01/14/search-ability-in-blog/"/>
      <url>/2023/01/14/search-ability-in-blog/</url>
      
        <content type="html"><![CDATA[<p>博客文章数量越来越多, 偶尔想到某个词, 想找到是哪篇文章只能搜源码.<br>于是完善了博客的搜索功能.</p><span id="more"></span><p>我直接用了别人的方案, 相信以后大概率会忘记, 所以要记录一下思路.</p><p>需要搜索, 就必须有搜索目标, 众所周知浏览器是不能读文件的, 那就需要把所有搜索目标弄成静态的.<br>然后在搜索框是加一些js和css就行了.</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="生成静态资源"><a href="#生成静态资源" class="headerlink" title="生成静态资源"></a>生成静态资源</h3><p><a href="https://github.com/wzpan/hexo-generator-search">这个插件</a>做的是: 调用<a href="https://hexo.io/api/generator">hexo的generator api</a>获取到所有文章内容, 并写成一个静态文件.</p><h3 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h3><p>生成的静态文件可以通过url被访问到, 所以可以通过get方式在浏览器运行时获取资源.</p><h3 id="其他零碎的活"><a href="#其他零碎的活" class="headerlink" title="其他零碎的活"></a>其他零碎的活</h3><p>剩下的事就是: 编写html, js, css, 并插入到合适的位置.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过webpack插件修改代码</title>
      <link href="/2023/01/04/how-to-manipulate-code-with-webpack-plugin/"/>
      <url>/2023/01/04/how-to-manipulate-code-with-webpack-plugin/</url>
      
        <content type="html"><![CDATA[<p>工作遇到要写webpack插件的情况, 记录一下是如何完成需求的.</p><p>因为webpack插件的文档是没有插件相关api的, 要写webpack插件只有通过看webpack代码或webpack插件代码. 所以虽然是调用api级别的代码, 也有记录的价值.</p><span id="more"></span><h2 id="背景和思路"><a href="#背景和思路" class="headerlink" title="背景和思路"></a>背景和思路</h2><h3 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h3><p>我领导基于hel-micro开发了个微模块系统, 基本原理非常简单: 把微模块打包成挂在window上的library, 项目加载的时候预加载, 此时window上已经有微模块了, 调用模块的入口也已经经过改造会去从window找, 整个流程就串起来了.</p><p>(基础简单, 但整个流程并不简单, 因为包含了打包, 使用的脚手架, 和模块&#x2F;项目的ci, 控制版本的服务.)</p><p>detail到使用微模块的项目, 需要进行2个改造:</p><ol><li>在首页进行微模块预加载, 具体是调用一个方法, 传入微模块的名字.</li><li>在业务代码中引入微模块. 我们的改动是在普通模块后加”&#x2F;mlib”.</li></ol><p>这种改造方案, 有2个问题. 首页改造比较大, 并且每增加一个微模块, 都需要到首页注册, 如果忘记了页面就丢组件了.</p><h3 id="需求总结"><a href="#需求总结" class="headerlink" title="需求总结"></a>需求总结</h3><p>于是想到是不是可以通过webpack插件来解决用户心智负担, 需要做的事情也很简单:</p><ol><li>从所有代码中找到微模块的名字. (特征是import的内容包含”&#x2F;mlib”)</li><li>修改入口文件, 调用预加载函数, 调用参数是从步骤1中找到的微模块.</li></ol><h3 id="为什么不走babel"><a href="#为什么不走babel" class="headerlink" title="为什么不走babel"></a>为什么不走babel</h3><p>说到修改代码, 其实大家第一反应应该是babel, 说说我考虑不走babel的原因:</p><ol><li>babel的插件是处里单模块的, 能力范围小, 完不成需求.</li><li>加载比webpack麻烦. 需要先找到loader, 再修改option.</li><li>webpack的流程可以不用babel. (虽然如果用vite, 这就变成了优点, 但公司基建是基于webpack的)</li></ol><h3 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h3><p>在实施过程中还有一些要注意的细节, 如果没注意是达不到目标效果的.</p><ol><li>首页的import是修改依赖树的.</li><li>添加的代码中有需要走babel的代码.</li><li>需要在修改首页前, 就获取到微模块依赖信息. 而处理文件顺序首页是第一处理的.</li></ol><h2 id="观察webpack流程"><a href="#观察webpack流程" class="headerlink" title="观察webpack流程"></a>观察webpack流程</h2><p>要想办法解决上面的问题, 就需要知道文件被webpack处理的流程, 并找到合适的查找和修改的点.</p><h3 id="代码在webpack里的流程"><a href="#代码在webpack里的流程" class="headerlink" title="代码在webpack里的流程"></a>代码在webpack里的流程</h3><p>我们视角里的”文件”, 在webpack处理的时候是<code>module</code>. </p><p>我关心的module经过的流程是: module -&gt; loaders -&gt; compile. 把webpack的compile中关心的部分展开:</p><blockquote><p>file(module) -&gt; loaders -&gt; wp parse -&gt; wp codegen</p><p>所有module跑完, 最后wp seal(optimize)</p></blockquote><p>更详细的流程是: (选读, 不重要)</p><ol><li>创建module的时候, 通过 设置了parser和generator的<code>createData</code>, 一起创建了<code>JavascriptParser</code>和<code>JavascriptGenerator</code>.</li><li>compilation调用<code>executeModule()</code>.</li><li><code>executeModule()</code>通过构造的时候注册的<code>buildQueue</code>调用module的<code>build()</code>.</li><li><code>build()</code>调用<code>_doBuild()</code>, 执行loader, 获得loader返回的值后, 用<code>RawSource</code>包一层存起来.</li><li><code>_doBuild()</code>的回调里调用<code>parse()</code>, 获取module的ast.</li><li><code>build()</code>调用完成,  <code>executeModule()</code>继续调用<code>_codeGenerationModule()</code>来调用<code>module.generator.generate()</code>.</li><li><code>generate()</code>方法通过 <code>sourceModule/sorceBlock</code>, <code>sourceDependency</code>, 最后调用到<code>template.apply()</code>生成代码.</li><li>在外层调用<code>compilation.seal()</code>.</li></ol><p>上面提到的具体变量方法都在后续在wp plugin的操作中会看到, 但知道了操作方法后, 调用链就没那么重要了.</p><h3 id="可以遍历ast的点"><a href="#可以遍历ast的点" class="headerlink" title="可以遍历ast的点"></a>可以遍历ast的点</h3><ul><li>loader. 自己写loader或者babel插件都算是loader流程里的.</li><li>webpack parse. 通过webpack plugin api 的 JavascriptParser钩子.</li></ul><h3 id="可以修改ast的点"><a href="#可以修改ast的点" class="headerlink" title="可以修改ast的点"></a>可以修改ast的点</h3><ul><li>loader. 自己写loader返回字符串, 或者通过babel插件.</li><li>webpack codegen.</li><li>webpack optimize.</li></ul><p>这里我们发现, webpack parse阶段明明能直接获取ast, 缺不能修改, 因为webpack在调用钩子的前后会记录&#x2F;恢复状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldState = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = oldState;</span><br></pre></td></tr></table></figure><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>说完了思路, 说说具体的api怎么调用.</p><p>虽然webpack文档里, 与plugin相关的变量结构都没有. 需要去看webpack代码或者其他插件代码和搜索引擎, 但在写完插件以后, 回头看文档, 我认为webpack文档写得非常好了. 并且在文档里写那么多东西确实不如直接看源码.</p><h3 id="webpack插件开发简介"><a href="#webpack插件开发简介" class="headerlink" title="webpack插件开发简介"></a>webpack插件开发简介</h3><p>webpack插件是一个类. 有一个apply方法, 接受参数是compiler. (完, 形式很简单)</p><p>webpack会在加载插件的时候调用apply方法并把compiler传进来, 配置插件方法看文档就行.</p><p><strong>plugin的插入方式是Tapable.</strong> 我目前没有深入理解, 简单地认为他是一个发布订阅系统. 在webpack执行的过程中会在指定的一些地方调用指定的方法(并传入一些内部变量作为参数), 插件通过注册这些指定名字钩子, 来获取变量, 并调用api.</p><p>另外提一下, webpack内部很多功能也是通过Tapable的方式实现的, 所以甚至可以认为webpack plugin是webpack源码的扩展.</p><p>另外, 因为对Tapable的了解基本算不了解, 所以这个可能以后会展开钩子的类型或者Tapable的源码.</p><h3 id="从webpack-plugin-加载loader"><a href="#从webpack-plugin-加载loader" class="headerlink" title="从webpack plugin 加载loader"></a>从webpack plugin 加载loader</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  compiler.<span class="property">webpack</span>?.<span class="property">NormalModule</span>.<span class="title function_">getCompilationHooks</span>(</span><br><span class="line">    compilation,</span><br><span class="line">  ).<span class="property">beforeLoaders</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">_, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">request</span>.<span class="title function_">includes</span>(<span class="string">&#x27;src/index.jsx&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">module</span>.<span class="property">loaders</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;./loader.js&#x27;</span>),</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">lazy</span>: <span class="variable language_">this</span>.<span class="property">option</span>.<span class="property">lazy</span> ?? <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">ident</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个钩子调用在<code>_doBuild()</code>中, 调用<code>runLoaders()</code>前, 这个点可以插入loader.</p><p>在上面的例子中, 我们可以通过<code>module</code>里的信息来决定需要执行loader的文件. 还可以把传入plugin的option带给loader的option.</p><p>在这里, loader的顺序一定要注意, loaders和redux的middleware一样是反向执行的, push和unshift的的效果是不相同的. (这里知道顺序是matters的就可以, 如果发生了非预期的情况知道调换loader顺序调试就行了)</p><h3 id="parse阶段访问ast"><a href="#parse阶段访问ast" class="headerlink" title="parse阶段访问ast"></a>parse阶段访问ast</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> walk = <span class="built_in">require</span>(<span class="string">&#x27;acorn-walk&#x27;</span>);</span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">normalModuleFactory</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">factory</span>) =&gt;</span> &#123;</span><br><span class="line">  factory.<span class="property">hooks</span>.<span class="property">parser</span>.<span class="title function_">for</span>(<span class="string">&#x27;javascript/auto&#x27;</span>).<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">parser</span>) =&gt;</span> &#123;</span><br><span class="line">    parser.<span class="property">hooks</span>.<span class="property">import</span>.<span class="title function_">tap</span>(</span><br><span class="line">      pluginname,</span><br><span class="line">      <span class="function">(<span class="params">_stmt: unknown, source: string</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="property">state</span>?.<span class="property">module</span>?.<span class="property">resource</span>.<span class="title function_">includes</span>(<span class="string">&#x27;node_modules&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="variable language_">this</span>.<span class="property">option</span>.<span class="property">rule</span> ?? <span class="regexp">/@xforce\/.*\/mlib/</span>).<span class="title function_">test</span>(source)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">remoteLibs</span>.<span class="title function_">push</span>(source);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">    parser.<span class="property">hooks</span>.<span class="property">program</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">ast: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parser.<span class="property">state</span>?.<span class="property">module</span>?.<span class="property">resource</span>.<span class="title function_">includes</span>(<span class="string">&#x27;src/index.jsx&#x27;</span>)) &#123;</span><br><span class="line">        walk.<span class="title function_">simple</span>(ast, &#123;</span><br><span class="line">          <span class="title class_">Identifier</span>: <span class="function">(<span class="params">node: any</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">          <span class="title class_">ImportDeclaration</span>: <span class="function">(<span class="params">node: any</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>parser</code>的钩子是在<code>JavascriptParser</code>实例运行<code>parse()</code>时候调用的. 目的就是纯帮我们遍历ast.</p><p>遍历ast的节点的钩子名字文档里有, 自己去看.</p><p>这里说几个细节:</p><ol><li>我们依旧可以通过<code>parser.state.module</code>里的属性来过滤需要处理的文件.</li><li>上文提到的, 这里修改ast是不起作用的.</li><li>如果在<code>program</code>钩子遍历拿到的ast, 需要用<code>acron</code>的api, 用babel的是会报错的.</li><li>如果<code>program</code>钩子设置了返回值, parser就不会遍历ast了, 在不需要遍历ast的项目里, 通过这个钩子可以提升wp性能.</li></ol><p>关于第二点和第四点, 想看代码去wp代码里搜<code>program.call</code>就行了.</p><h3 id="在codegen阶段增加调用自定义template"><a href="#在codegen阶段增加调用自定义template" class="headerlink" title="在codegen阶段增加调用自定义template"></a>在codegen阶段增加调用自定义template</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">NullFactory</span> <span class="keyword">from</span> <span class="string">&#x27;webpack/lib/dependencies/NullDependency&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModifyDependency</span> <span class="keyword">extends</span> <span class="title class_ inherited__">NullFactory</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">param: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">param</span> = param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ModifyDependency</span>.<span class="property">Template</span> = <span class="keyword">class</span> <span class="title class_">ModifyDependencyTemplate</span> <span class="keyword">extends</span> (</span><br><span class="line">  <span class="title class_">NullFactory</span>.<span class="property">Template</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">dependency, source</span>) &#123;</span><br><span class="line">    source.<span class="title function_">insert</span>(<span class="number">0</span>, <span class="string">`// <span class="subst">$&#123;dependency.param&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在apply方法中</span></span><br><span class="line"></span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  compilation.<span class="property">dependencyTemplates</span>.<span class="title function_">set</span>(</span><br><span class="line">    <span class="title class_">ModifyDependency</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ModifyDependency</span>.<span class="title class_">Template</span>(),</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">normalModuleFactory</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">factory</span>) =&gt;</span> &#123;</span><br><span class="line">  factory.<span class="property">hooks</span>.<span class="property">parser</span>.<span class="title function_">for</span>(<span class="string">&#x27;javascript/auto&#x27;</span>).<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">parser</span>) =&gt;</span> &#123;</span><br><span class="line">    parser.<span class="property">hooks</span>.<span class="property">import</span>.<span class="title function_">tap</span>(</span><br><span class="line">      pluginname,</span><br><span class="line">      <span class="function">(<span class="params">_stmt: unknown, source: string</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="property">state</span>?.<span class="property">module</span>?.<span class="property">resource</span>.<span class="title function_">includes</span>(<span class="string">&#x27;node_modules&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="regexp">/@xforce\/.*\/mlib/</span>.<span class="title function_">test</span>(source)) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">ModifyDependency</span>(<span class="string">`添加一点注释: <span class="subst">$&#123;source&#125;</span>`</span>);</span><br><span class="line">            parser.<span class="property">state</span>.<span class="property">current</span>.<span class="title function_">addDependency</span>(dep);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里自定义程度比较高, 我从执行角度的流程分析会比较容易:</p><ol><li>通过钩子找到需要处理的文件(module), 为当前模块一个自定义的dependency. (<code>addDependency(dep)</code>)</li><li>codegen在执行到<code>sourceDependency()</code>的时候, 会发现这个dependency(即<strong>new ModifyDependency(`添加一点注释: ${source}`)</strong>).</li><li>执行的时候会从<code>dependencyTemplates</code>中根据dependency的构造器来找对应的Template. (所以我们要调用<code>dependencyTemplates.set()</code>)</li><li>找到Template以后, 会执行Template的<code>apply()</code>方法.</li><li><code>apply()</code>方法接受3个参数, 第一个是dep实例, 我们可以通过这个实例把参数传给Template, dep里还可以获取当前代码的位置等信息.</li><li><code>apply()</code>的第二个参数<code>source</code>是一个<code>ReplaceSource</code>实例, 调用方法可以替换, 添加代码.</li></ol><p>另外, 在合适的情况下, 我们是可以使用webpack内部定义好的dependency的.</p><p>最后, 上面提到调用template.apply的过程在<code>lib/javascript/JavascriptGenerators.js</code>里, <code>ReplaceSource</code>在webpack-source里, 需要的可以自行去看详情.</p><h3 id="在optimize阶段修改输出"><a href="#在optimize阶段修改输出" class="headerlink" title="在optimize阶段修改输出"></a>在optimize阶段修改输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ConcatSource</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;webpack-sources&#x27;</span>;</span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  compilation.<span class="property">hooks</span>.<span class="property">optimizeChunkAssets</span>.<span class="title function_">tap</span>(pluginname, <span class="function">(<span class="params">chunks</span>) =&gt;</span> &#123;</span><br><span class="line">    chunks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">      chunk.<span class="property">files</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (filename.<span class="title function_">includes</span>(<span class="string">&#x27;index&#x27;</span>)) &#123;</span><br><span class="line">          compilation.<span class="property">assets</span>[filename] = <span class="keyword">new</span> <span class="title class_">ConcatSource</span>(</span><br><span class="line">            (compilation.<span class="property">assets</span>[filename].<span class="title function_">source</span>() <span class="keyword">as</span> string).<span class="title function_">replace</span>(</span><br><span class="line">              <span class="string">&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">remoteLibs</span>[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;/mlib&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">          ) <span class="keyword">as</span> any;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上面代码的这些钩子与变量判断, 找到我们想要的文件就可以像loader里一样替换了.</p><p>这里说三个点:</p><ul><li><p>optimize是在wp seal的时候调用的, seal是在所有module都运行完后才调用的, 只有在这个时间其他的module才都运行过. 这点对我的目标需求非常重要, 因为其他钩子的点是拿不到收集的信息的.</p></li><li><p>这个时候拿到的代码已经是准备输出成文件的最终代码了.</p></li><li><p>wp里的source是webpack-source的实例, 但我们只要知道<code>source()</code>方法获取字符串, 再重新new一下返回就可以了.</p><p>并且这里可以用字符串操作, 也就是可以自己用ast&#x2F;magic string来分析操作字符串.</p></li></ul><h3 id="附送-指定某个文件不要被tree-shaking"><a href="#附送-指定某个文件不要被tree-shaking" class="headerlink" title="附送: 指定某个文件不要被tree-shaking"></a>附送: 指定某个文件不要被tree-shaking</h3><p>这个是在看老板写的plugin时候, 比较简单又不值得开一篇post分析的api. (记录一下)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">constructor</span>.<span class="property">name</span> &#125;,</span><br><span class="line">  <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; moduleGraph &#125; = compilation;</span><br><span class="line">    compilation.<span class="property">hooks</span>.<span class="property">afterOptimizeChunkModules</span>.<span class="title function_">tap</span>(</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">constructor</span>.<span class="property">name</span> &#125;,</span><br><span class="line">      <span class="function">(<span class="params">chunks</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> indexChunk = <span class="title class_">Array</span>.<span class="title function_">from</span>(chunks).<span class="title function_">find</span>(</span><br><span class="line">          <span class="function">(<span class="params">chunk</span>) =&gt;</span> chunk.<span class="property">name</span> === <span class="variable language_">this</span>.<span class="property">_chunkName</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (indexChunk) &#123;</span><br><span class="line">          compilation.<span class="property">chunkGraph</span></span><br><span class="line">            .<span class="title function_">getChunkModules</span>(indexChunk)</span><br><span class="line">            .<span class="title function_">forEach</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              <span class="variable language_">module</span>.<span class="property">type</span> === <span class="string">&#x27;javascript/auto&#x27;</span> &amp;&amp;</span><br><span class="line">              <span class="variable language_">module</span>.<span class="property">resource</span>.<span class="title function_">endsWith</span>(<span class="variable language_">this</span>.<span class="property">_moduleSource</span>)</span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="keyword">const</span> exportsInfo = moduleGraph.<span class="title function_">getExportsInfo</span>(<span class="variable language_">module</span>);</span><br><span class="line">              exportsInfo.<span class="title function_">setUsedInUnknownWay</span>(<span class="literal">undefined</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="完成需求的方案"><a href="#完成需求的方案" class="headerlink" title="完成需求的方案"></a>完成需求的方案</h2><p>我选择了 loader + optimize 的方案. 说说原因:</p><ul><li><p>我在首页添加的代码包含新的import, 所以在loader添加代码才会被module-graph收录.</p></li><li><p>module的处理顺序是从根节点开始遍历(深度还是广度我不在意).</p><p>我需要在遍历的时候收集信息, 收集完再写到入口文件. 所以只有通过seal的时候(此时已经执行完所有module), 再回头处理入口文件.</p></li></ul><p>遍历ast的过程我选择wp parse阶段, 原因是执行所有的module只加载一次plugin实例. 而不确定用loader或babel plugin可以把收集的信息放到同一个变量里. (不确定是不是同一个作用域, 也没去试)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需要遍历的话, 文件的顺序是: loader wp parse. 不同阶段获取的ast是不同的, loader的顺序也讲究.</p><p>如果要修改, 通过loader比较好. (修改后的代码可以顺利经过其他所有处理, 自己的loader要注意顺序)</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> webpack-plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸福之路</title>
      <link href="/2022/12/03/the-conquest-of-happiness/"/>
      <url>/2022/12/03/the-conquest-of-happiness/</url>
      
        <content type="html"><![CDATA[<p>幸福&#x2F;快乐应该是我们所有人追求的唯一东西. 这本书从解决不快乐和寻找快乐2部分. </p><p>这书写在90多年前(1930)的外国, 很多点让我感觉就是现在写的. 看完了简单的记录下.</p><span id="more"></span><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h2><p>所有内容分为2部分: 为什么不快乐以及解决方法; 什么是快乐的以及怎么去感受他们.</p><p>但本身有个前提, 在物质条件都充足的前提下, 对精神快乐&#x2F;难过的思考总结, 发生灾难的情况不在这里讨论范围内.</p><p>由于水平和时间有限. 本文主要是总结每个章节的内容.</p><p>总结外, 会简单记录我看了书后转换我观念的一些观点. 和自己&#x2F;周围人确实遇到的痛苦, 对号入座到哪些问题中. (这两件事非常主观.) 如果有遇到同样的问题看了总结后觉得有意思的, 强烈建议看原书的演绎会觉得很棒.</p><h3 id="有没有这些困扰"><a href="#有没有这些困扰" class="headerlink" title="有没有这些困扰"></a>有没有这些困扰</h3><ul><li>我做的事是为父母&#x2F;孩子好, 为什么他不接受. (不让父母吃xxx, 为父母买新东西(手机&#x2F;airpods), 带父母看病)</li><li>觉得无聊, 没事可以做.</li><li>因为身体&#x2F;生活&#x2F;工作而焦虑.</li><li>水平不如我的同事, 工资远比我高.</li><li>事情没做好, 觉得非常不好意思, 应该如何处理.</li><li>感觉别人讨厌或者针对自己.</li></ul><h3 id="一些观点"><a href="#一些观点" class="headerlink" title="一些观点"></a>一些观点</h3><ol><li><p>自我沉溺的形式有: 罪恶感, 虚荣心, 自恋, 自大. </p><p>其根本原因是过度在意别人的看法而导致的<strong>低自尊</strong>. <strong>解决方法是对客观事物产生兴趣而激发活动.</strong></p></li><li><p>大部分的无意识都是由曾经高度情绪化的有意识的想法构成的, 而这些有意识的想法现在被掩藏了起来. </p></li><li><p>精神疲劳最糟糕的点是: 他像是人与外部世界之间的一道屏幕. 不听亲人讲话, 对饮食和阳光没有兴趣, 不能享受与自然密切联系获得的幸福.</p></li><li><p>过度谦虚的人也是容易嫉妒他人的人. 原因也是低自尊.</p></li><li><p>即使做错事情了, 也要避免罪恶感, 而是努力向上, 想办法改成和把事情做好.</p></li><li><p>别人用来思考你的时间少于你琢磨自己的时间.</p></li><li><p>一旦到了能自主判断的年龄就有了选择的权利, <strong>必要的话还有犯错的权利.</strong></p></li><li><p>不高估自己的能力是幸福感的基础之一.</p></li><li><p>人类的天性本是让不缺爱的人更容易得到爱.  (道德经第七十七章)</p></li><li><p>爱, 更多的是同情已经发生的不幸, 而不是担心可能发生的不幸.</p></li></ol><h2 id="各章总结"><a href="#各章总结" class="headerlink" title="各章总结"></a>各章总结</h2><h3 id="不快乐的原因"><a href="#不快乐的原因" class="headerlink" title="不快乐的原因"></a>不快乐的原因</h3><h4 id="不快乐的原因总结"><a href="#不快乐的原因总结" class="headerlink" title="不快乐的原因总结"></a>不快乐的原因总结</h4><p>其他动物只要没生病, 吃得饱, 就是快乐的. 而人会去想象未来的问题, 从而产生了一些列精神需求.</p><p>精神需求的根源依然是未来可以存活, 衍生的需求有财富积累(未来可以吃饭), 社会地位(未来有人可以帮自己).</p><p>而人类的精神快乐和不快乐, 其实都由这些精神需求而来. 满足了快乐, 不满足不快乐.</p><p>一般因为年轻时被剥夺了一些正常的满足, 导致之后过分追求一些东西, 导致了不幸福.</p><p>而我们借助<strong>理性</strong>, 通过深入了解自己, 或者是心理戒律, 都可以让自己生活更幸福.</p><h4 id="悲观的理性"><a href="#悲观的理性" class="headerlink" title="悲观的理性"></a>悲观的理性</h4><p>一个足够有理性的人, 会认识到: 人类是偶然产生的, 并且大概率会从世界上消失, 文明也会清零.</p><p>类似的想法还有: 资本家付给工人工资, 只是像汽车要加汽油, 维护工人生存只是剥削的一部分.</p><p>再往浅一点的例子是: 人去旅游, 还是得回来, 还不如不去, 因为要花钱.</p><p>这种想法的根本错误是: 人类其实还是感性动物, 说这些话的人只不过是<strong>在舒服的情况下</strong>说的做作的话而已.</p><p>如果你的孩子生病了, 如果富人的公司快倒闭了, 他就不会觉得生命是虚妄的, 财富是没用的了.</p><p>所以这种”悲观的理性”是不利于幸福的. 正确的理性是不影响幸福的, 应当在困难的时刻分析并走出困难, 并在快乐的时候去享受快乐. 理性会能体会到: 自己是感性的这个事实的, 并且知道<strong>适当的辛苦和保持对一些东西的渴望是幸福必不可少的一部分.</strong> </p><h4 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h4><p>竞争的表面解释是: 担心的不是不知道明天的早餐在哪里, 而是不能比邻居吃得更好.</p><p>并且竞争心里很容易进入新的领域. 比如比谁书看得多, 比谁孩子好等.</p><p>我先要说明: 并不是竞争中做的事是错误的(比如赚钱&#x2F;看书&#x2F;培养孩子), 也不是说竞争是错的(有时候竞争是动力).</p><p>比如赚钱是需要的, 而且一定程度内, 钱确实能提高生活质量.</p><p><strong>有问题的是: 过分强调竞争胜利, 并把胜利作为快乐的主要源泉.</strong> 如此就会种下烦恼之跟.</p><p>并且<strong>做好事情的唯一途径是对事本身感兴趣</strong>, 为了竞争的胜利做的事让人做不好事.</p><p>另外, 过度竞争会导致人疲劳, 让人失去和亲人&#x2F;自然的联系, 失去很多获得幸福的可能.</p><h4 id="无聊与兴奋"><a href="#无聊与兴奋" class="headerlink" title="无聊与兴奋"></a>无聊与兴奋</h4><p>人生有起有伏, 而最多的部分是平淡, 这个阶段获得快乐的最大问题是无聊.</p><p>无聊的本质是现实环境与令人心向往之的更惬意的环境之间存在反差, 和人的机能没有“全力以赴”.</p><p><strong>人在尽全力做事情的时候是不会无聊的.</strong></p><p>无聊的反面是兴奋, 兴奋是指让无聊的人感受到这一天与另一天的不同.</p><p>现在的很多娱乐活动都是追求兴奋, 甚至吵架, 战争, 屠杀, 迫害也是逃避无聊的方法, 人类一半的罪恶来自于害怕无聊.</p><p>而追求兴奋不是长期有效的, <strong>昨夜越是销魂今晨就越是无聊.</strong> 再伟大的人, 伟大的作品都有无聊的阶段.</p><p>所以从心理抵抗无聊是获得快乐必须的能力.</p><p>推荐方法是: </p><ol><li>避免消极娱乐, 如电影美食. 认识到日复一日平淡生活的重要性.</li><li>与自然进行密切联系: 山水草木云. 自然带来的幸福感是巨大的, 当乐趣停止时也不会立即消失.</li></ol><h4 id="疲劳"><a href="#疲劳" class="headerlink" title="疲劳"></a>疲劳</h4><p>疲劳分两种. 身体疲劳也精神疲劳.</p><p>适度的身体疲劳是可以带来幸福的. 而精神疲劳会造成不幸福.</p><p>并且身体疲劳可以通过休息来恢复, 而精神疲劳不可以通过休息来恢复, 容易长期积累着.</p><p>普通人的精神疲劳产生自忧虑. 而<strong>忧虑可以通过一些心理戒律来解决</strong>: </p><ul><li>当明确了对某事已经无能为力的时候, 要停止思考.</li><li>当有不确定的事情让自己产生焦虑的时候, 思考最坏的情况是什么, 然后给自己一个理由让自己相信即使发生了也不是什么灭顶之灾.</li></ul><p>而心理戒律一定要写入无意识, 不然结果可能是: “我告诉自己不能紧张, 然后晚上继续做噩梦”.</p><p><strong>让意识在无意识中生根的方法是: 思想足够强烈和有力.</strong> 其实大部分的无意识都是由曾经高度情绪化的有意识的想法构成的, 而这些有意识的想法现在被掩藏了起来. </p><p>疲劳的另一个产生原因是贪恋兴奋. <strong>最容易得到, 浅层次上最能吸引人的乐趣, 大多都是耗神的.</strong> 这个对我来说应该就是b站和游戏了.</p><p><strong>精神疲劳最糟糕的点是: 他像是人与外部世界之间的一道屏幕.</strong> 不听亲人讲话, 对饮食和阳光没有兴趣, 不能享受与自然密切联系获得的幸福.</p><h4 id="嫉妒"><a href="#嫉妒" class="headerlink" title="嫉妒"></a>嫉妒</h4><p>陷入嫉妒状态的人, 会做出损人不利己的行为, 损伤被嫉妒者幸福.</p><p>同时, 嫉妒的人自己也会陷入不幸福. 本可以享受幸福的生活, 在想到别人享受更大快乐的时候, 不公平的感觉会将他吞噬, 让幸福感荡然无存.</p><p>八卦, 丑闻的传播, 就是基于嫉妒的道德形式: 被嫉妒的人的坏的故事会被大家相信, 而不相信的人也会遭人嫉妒, 惩罚他们的失德被视为有德.</p><p>嫉妒与竞争有很强的联系, 因为嫉妒对象大多是竞争对象. (乞丐不会嫉妒百万富翁，尽管他们会嫉妒更走运的其他乞丐)</p><p>并且男女的嫉妒对象也有所区别, 男的只会嫉妒同行, 而女的会嫉妒所有女的, 原理可能也是”竞争关系”.</p><p>对付嫉妒有三个方法, 由表面到深层:</p><ul><li>心里戒律: 不做无益之想的习惯(意识到自己嫉妒了就停止嫉妒的思考). 快乐是最重要的. 赚我2倍的人, 也有人比他赚多, 他也无法快乐.</li><li>用仰慕代替嫉妒. 思考嫉妒对象的优点, 仰慕使自己快乐, 也能激励自己成长.</li><li>根治方法: 自信. 如果大家都自信, 认为自己是最好的, 就不会有嫉妒的心理了. 由此也可以推出, 过度谦虚的人是不自信的. 他们是容易嫉妒别人的人.</li></ul><h4 id="罪恶感"><a href="#罪恶感" class="headerlink" title="罪恶感"></a>罪恶感</h4><p>罪恶感来自于: **我知道这事是错的, 并且我还是要做, 同时担心着别人发现我做过了. ** (这里的罪恶感是狭义的, 和”我吃了好多肉, 今天啥事也没做, 之类的罪恶感是不同的, 并且这些罪恶感不会引起不幸福”)</p><p>产生罪恶感的事分为2类: 其实是可以做的事, 确实做了不好的事.</p><p>根据分类, 对付罪恶感的方式也是不同的.</p><p>对于”其实可以做的事”, 但我们产生罪恶感, 其实是<strong>被社会观念或者是父母从小灌输的观念</strong>所影响. 举例是说脏话, 说谎, 性等.</p><p>(这里举个例子: 我跟猎人指狐狸的逃跑路线时候说谎救了狐狸. 于是产生了罪恶感. )</p><p>发生”理性知道是可以做, 但感觉是不能做”的事, 处理方式有2步:</p><ol><li>通过调用理性分析罪恶感, 来意识到这事是可以做的.</li><li>在”疲劳章节”中提过, 用强烈的意念(仔细思考从而相信自己), 来使意识写入无意识.</li></ol><p>如果在第一步发现, 确实是自己做错了, 也有一个重要的点: <strong>我们要想着如何去改正和努力, 并减少罪恶感.</strong></p><p>因为<strong>罪恶感会让人导致自卑和低自尊.</strong> 而导致疲劳, 嫉妒的情绪. 我认为<strong>沉溺罪恶感是懒惰和被动&#x2F;奴隶道德的表现.</strong></p><h4 id="受害妄想"><a href="#受害妄想" class="headerlink" title="受害妄想"></a>受害妄想</h4><p>受害妄想一句话总结是: 没有意识到发生情绪的根源在自身, <strong>而是假想中的他人的敌视和恶意</strong>. 认为有人针对我, 总有刁民想害朕.</p><p>在一般的没有特殊背景的情况下, 只有2个原因: <strong>你在想象自己未受过的伤害, 或者在无意间做了让人怒不可遏的事.</strong> </p><p>书里细分了几个情况, 我想大家在各个程度上都能对号入座:</p><ol><li><p>被背后说话而生气. 没有意识到自己也是会在背后说人的. </p><p><code>解决方案: 理解到所有人都会背后说人后, 更好的做法是: 接受别人会背后说自己的事实, 并且原谅别人, 因为理解到自己也会说, 这是人性.</code></p></li><li><p>对自我价值的过分夸大. 自己认为自己做的事是80分, 可事实是60分, 别人评价也在60分左右, 就认为别人针对自己.</p><p><code>解决方案: 意识到每个人都会对自我价值夸大. 尝试从第三方角度和自己的产出看待自己的价值.</code></p></li><li><p>把自己的需求强加于他人, 然后发现对方没感谢.</p><p><code>解决方案: 记住, 你的动机并不想你想象的那么无私. 并且要理解: 有自私的动机并没有什么不好的, 有自私的动机才能把事情做得更好. 但为别人做事前, 需要思考别人是否需要.</code></p></li><li><p>自己期望别人会为自己做某些事. 比如我饿了, 妈妈应该会想到呀, 或者: 我事情做好了, 领导过会应该会来问我进度.</p><p><code>解决方案: 不要苛求他人, 认为别人应该为自己做什么. 人们对他人的抱怨只是自然的私心对过分的贪心的合理反应.</code></p></li></ol><p>最后, 我们要认识到一个事实: <strong>别人用来思考你的时间少于你琢磨自己的时间.</strong> 不用在脑内做过多的演习, 把时间花在做事上.</p><h4 id="舆论恐惧"><a href="#舆论恐惧" class="headerlink" title="舆论恐惧"></a>舆论恐惧</h4><p>每个人&#x2F;群体的生活&#x2F;工作习惯不同. 而自己生活&#x2F;工作的群体与自己的习惯不同, 在别人的眼光甚至阻止里, 就会产生不幸福.</p><p>一个在群体中行为不适的人, 到了适合自己的群体中, 他会从不苟言笑, 羞怯, 退缩变成愉快, 自信, 会从生硬变成随和易处, 会从以自我为中心变成外向, 善于交际.</p><p>所以避免舆论恐惧的第一个方法就是找到合适自己的群体, 而不是在不适中硬撑.</p><p>如果无法避免, 也有2个方法:</p><ol><li>不表现得畏惧, 舆论对那些畏惧他的人要暴虐得多.</li><li>以足够愉快, 友好的态度向人们, 甚至包括最愚蠢的人, 表明自己并无指责之意, 人们是会原谅很多有悖传统之事的.</li></ol><p>一个人对于舆论的尊重程度应以自我生存和不伤害他人为限. <strong>相信自己, 轻视舆论可以避免恐惧, 是幸福之源.</strong> 我们在社会中遇见的陌生人如果都是从一个标准里出来的, 是你已见过的人的简单复制, 讲会很无趣.</p><p>换一个身份, 我们也不应该把自己的标准强加于他人. 一旦到了能自主判断的年龄就有了选择的权利, <strong>必要的话还有犯错的权利.</strong></p><h3 id="幸福的原因"><a href="#幸福的原因" class="headerlink" title="幸福的原因"></a>幸福的原因</h3><h4 id="幸福的总则"><a href="#幸福的总则" class="headerlink" title="幸福的总则"></a>幸福的总则</h4><ul><li><p>**让你的兴趣尽量广泛. **</p><p>从兴趣上能获得幸福的逻辑是: <strong>通过艰苦努力, 然后获得成功.</strong> </p><p>在通过努力获得幸福上, 形式不重要, 可以是体力, 可以是深入科学, 也可以是研究楔形文字.</p><p>他们三者区别是: 体力能获得劳动成果, 科学能获得更多的劳动成果, 楔形文字只在很少时候有使用价值.</p><p>但他们都能使人获得幸福.</p><p>(题外话, 其实游戏和楔形文字是一种类型的. 所以游戏有他的正面意义, 在”兴致”中提到, 如果影响生活了这个类型的兴趣才被认为是负面的)</p></li><li><p><strong>对你关心的人与事表达出更多友善.</strong> </p><p>对人的友善, 是获得情爱的途径. 情爱是获得幸福必不可少的东西.</p><p>若不通过友善的方式, 而尝试用伪装行为的手段, 或是尝试占有, 或是从责任感出发等制造的感情, 都是不能获得真正情爱的. 甚至占有和期待回应的爱是不幸福的根源.</p></li></ul><p>下面开始会从各个方面来聊获得幸福的具体方式.</p><h4 id="兴致"><a href="#兴致" class="headerlink" title="兴致"></a>兴致</h4><p>书里用吃饭来观察兴致. 最能获得幸福的形式是: 食欲健康, 喜爱食物, 吃饱即止.</p><p>兴致的来源是人类天性. 这里聊了三个失去兴致的情况.</p><ul><li><p><strong>拜伦式</strong>(第二章: 悲观的理性): 认为吃饭是任务, 人生的各个节点都是任务.</p><p>这种是理性的走火入魔. (如果你是真的理性, 那是会懂的人是感性动物的)</p><p>书中把人比作火腿肠生产机. 拜伦式火腿肠机研究自己机构, 最后啥也没做. 而另一台制作出了很多火腿肠, 不但发挥了自己的功能, 也获得了幸福.</p></li><li><p><strong>无节制式</strong>: 吃饭吃饱了还不停. 推广到做一些事无节制, 从而影响生活. </p><p>虽然兴致使人幸福. 但<strong>良好的性质是在对生活有好的影响</strong>的前提下的. (其他不是坏的)</p><p>而无节制行为的根因是<strong>逃避</strong>. <strong>他们追求的不是本身的乐趣, 而是遗忘.</strong> </p><p>(我认为我们对手机&#x2F;游戏的负面理解, 就是在此. 如果不是无节制的, 手机&#x2F;游戏是个正面的东西)</p></li><li><p><strong>规则化的生活</strong>: 人的文明进展, 导致人的很多冲动&#x2F;自发的行为要被克制.</p><p>比如必须8点吃早饭, 12点吃午饭. 因为工作时候不能吃.</p><p>高文明的社会需要高度复杂的合作. 人必须按照规则行事, 就需要克制冲动.</p><p>于是高文明的社会给人带来物质丰富的同事, 对精神丰富增加了阻碍.</p></li></ul><h4 id="情爱"><a href="#情爱" class="headerlink" title="情爱"></a>情爱</h4><p>兴致丧失的一个重要原因是没有安全感. 而没有安全感的原因是缺爱.</p><p>书里讨论了在爱与被爱时几个场景的感情成分:</p><ul><li><p>“获得的爱”才能给安全感, 而不是”给予的爱”. 如果没有安全感, 人会胆怯, 恐惧, 自怜, 内向, 抑郁.</p></li><li><p>给对方的爱应该希望对方更优秀, 而不是更安全(也不是无视安全).</p><p>如果希望对方安全大于优秀, 那可能是控制欲. </p><p><strong>爱, 更多的是同情已经发生的不幸, 而不是担心可能发生的不幸.</strong></p></li><li><p>爱别人的时候, 一般都是”兴致”和”恐惧”的混合物.</p><p>一个来源于对目标的欣赏, 一个来自于害怕失去目标自己难以生存. (书中小船的故事描述得非常合适)</p><p>前者是好的感情, 后者来自于恐惧, 是不好的感情. (虽然也有部分作用: 消除不安感后才能追求前一种爱)</p></li></ul><p>上面聊的是如何爱别人, 以及爱别人的时候什么心态自己更幸福.</p><p>想要”获得爱”是有难度的. 因为人性是让缺爱的人更不容易获得爱的. (按道德经说, 得道的人才会让缺爱的人获得爱, 但很明显不是所有人都得道的)</p><p>除了父母天然的爱, 需要努力获得外貌(男对女)或性格(女对男)或令人尊敬的其他技能.</p><p>在爱已经发生的地方, “自我”和”保留”, “戒备”, 害怕丢脸, 迟疑与表达赞美, 害怕对方挑剔自己而让自己难堪. 是阻碍爱的心理机制, 需要我们去克服.</p><h4 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h4><p>家庭是个很大的话题, 在这里只讨论三个点.</p><ul><li><p>组成家庭是辛苦的, 和幸福的.</p><p>在这里的家庭是特指有孩子的那种. 家庭的辛苦困难和幸福都是指来自于孩子的.</p><p>辛苦来自于资源的缺乏. 很明显孩子是需要大量投入时间的, 这对家庭分工和结构是重大的挑战.</p><p>幸福来自于2点: 传承生命和对孩子喜欢的本能. 以及权力与温情的紧密结合.</p></li><li><p>父母对于孩子的权利应该是慢慢减小的. 只有<strong>对孩子抱有尊重态度的人, 才能获得为人父母的全部幸福</strong>.</p></li><li><p>母亲在家庭中面临着一个额外的重大挑战. 总结来说, <strong>母亲不应断绝自己所有兴趣与追求, 这对孩子和母亲自身都很重要</strong>.</p></li></ul><p>关于”有孩子是不能替代的幸福”, “要尊重孩子”, “不能失去自我”. 我都在看这书前就有很深的认识, 相信和我同龄的也非常能理解.</p><p>并且真正和孩子接触了以后, 甚至把之前没注意的, 对人的态度, 推广到所有人, 因此也很感谢孩子, 让自己成长了.</p><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>工作和学习一样, 是被功利主义抹黑的事情. 工作是幸福的.</p><p>所以我一直希望孩子能理解: 学习的目的是”想知道”, 即学习本身. 工作是因为我有想做的事.</p><p>而不是把学习和工作都看成”付出”时间精力来”换取”金钱的手段, 那样一方面是失去了学习和工作的幸福, 二是事情也做不好.</p><p>工作的幸福可以分成2个层面.</p><p>浅的层面是每个人都可以享受的幸福:</p><ul><li><p>避免无聊. </p><p>很多富人, 有钱女人还在勤奋工作. 很多退休的人完全不缺钱也继续找工作. 就能说明这点.</p></li><li><p>工作把假期变得格外美妙.</p></li><li><p>创造了获得成功的机会. </p><p>大部分人会有的工资收入, 和小部分获得成就的可能.</p></li></ul><p>更深层面的快乐不一定每个人都能体会:</p><ul><li><p>运用技能. </p><p>任何掌握了特殊技能的人都会乐此不疲地实践这种技能. 就像会倒立的男孩总是不情愿正常地站着.</p></li><li><p>工作具有建设性. </p><p>把混乱的东西变成有序, 也是人的一个本能. 人从此能获得胜利的快感.</p></li><li><p>投身一项伟大的事业. </p><p>我对此没啥感觉, 我认为这个需要对工作有积累, 有了自己的工作审美, 才有想做的事, 才能体会到”应该去做”的事.</p></li></ul><h4 id="闲情逸致"><a href="#闲情逸致" class="headerlink" title="闲情逸致"></a>闲情逸致</h4><p>闲情逸致指非主要的, 没有指责&#x2F;压力, 不需要得到收益的兴趣.</p><p>闲情逸致的优点有三个:</p><ul><li><p>使人放松. </p><p>没有目的, 没有压力, 可以随时停下的兴趣, 在做的时候是使人放松, 达到调节疲劳的效果的.</p></li><li><p>获得平衡感. </p><p>除了主要事物和工作外, 有别的”无用”的兴趣, 可以拓宽视野, 体会到自己的渺小和世界之大.</p><p>体会了世界之大, 会有更大的视野, 甚至个人生死也将被置之度外. <strong>摆脱了被环境奴役的恐惧, 将会感受到深刻的幸福.</strong> </p></li><li><p>面对失败.</p><p>人生会有不如意的时候, 如果一个人有一系列闲情逸致, 在不如意的时候可以分散注意力和获得快乐, 他能在每次打击后对生活产生兴趣, 战胜一切厄运.</p></li></ul><h4 id="努力与放弃"><a href="#努力与放弃" class="headerlink" title="努力与放弃"></a>努力与放弃</h4><p>想获得幸福, 努力是必须的.</p><p>谋生, 获得成就感, 婚姻, 养育孩子, 获得一些权力等, 都需要投入不同程度的努力.</p><p>想获得幸福, 学会放弃也想必须的. 而放弃的形式有多个:</p><ul><li>不是努力就可以获得的东西, 可以放弃. 比如成就, 比如名次, 通过对比才能获得的东西.</li><li>无法改变的事. 比如生病, 死亡. 放弃在无法改变的事上话不必要的精力. 如果能做到的话, 把目光放远, 看重人类的成就, 后代的成就, 就可以安心放弃不能改变的事.</li><li>放弃不重要的事. 其实不重要, 但影响情绪的小事, 需要学会放弃. 人的时间有限, 更值得做有幸福的事.</li></ul><p>总结: 人生精力有限, 把精力花在什么事情上能获得更多的快乐, 需要权衡把精力放在哪里.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sourcemap的使用</title>
      <link href="/2022/11/25/sourcemap-utilization/"/>
      <url>/2022/11/25/sourcemap-utilization/</url>
      
        <content type="html"><![CDATA[<p>上个月老板介绍了sourcemap的几个使用. 我现在才回头看了看, 也做下总结.</p><p>soucemap好像是12年上线的, 我的感觉是一直知道是什么, 但又没一点深入过.</p><span id="more"></span><h2 id="sourcemap是什么"><a href="#sourcemap是什么" class="headerlink" title="sourcemap是什么"></a>sourcemap是什么</h2><p>代码从源码编译完已经面目全非, 出bug的时候就基本不能debug了.</p><p>sourcemap是编译源码和浏览器约定的一种格式.</p><p>效果是编译后的代码加载了sourcemap就可以像看源码一样debug.</p><h3 id="soucemap的形式"><a href="#soucemap的形式" class="headerlink" title="soucemap的形式"></a>soucemap的形式</h3><p>默认情况下, 一份源码经过编译会产生一份sourcemap文件, 编译后的源码最后一行会有sourcemap的url信息, 这样浏览器在debug模式下就会去加载soucemap.</p><p>另外sourcemap也可以直接在行内.</p><p>sourcemap的内容是一个json. 有几个字段: <code>version</code>, <code>file</code>, <code>sourceRoot</code>, <code>sources</code>, <code>names</code>, <code>mappings</code>. </p><p>并且会用VLQ(Variable Length Quantity)把sourcemap的内容处理成base64来缩小体积.</p><p>其具体的对应关系我暂不打算深入, 浏览器能识别就行了.</p><h3 id="什么时候要打sourcemap"><a href="#什么时候要打sourcemap" class="headerlink" title="什么时候要打sourcemap"></a>什么时候要打sourcemap</h3><p>只要有编译过程, 源码和构建后代码有区别的, 都可以用soucemap: flow, ts, jsx, es, css预处理等. (这里说得非常不严谨, 但情况实在太多). 其实上线代码都必须minify和uglify, 所以sourcemap的问题在工程化里基本是全覆盖的.</p><p>那什么时候要打soucemap也比较明确了, 分为dev时和build时.</p><p>dev的时候直接关闭minify, uglify, es. 这个情况下不需要打sourcemap.</p><p>但dev flow, ts, jsx的时候需要开sourcemap来debug.</p><p>build的时候为了build速度考虑是不打soucemap的. (或者有的是为了不让用户轻松看到源码)</p><p>但在供开发者使用的lib里, 为了提升组件使用者体验可以打出sourcemap.</p><h2 id="关于debug源码"><a href="#关于debug源码" class="headerlink" title="关于debug源码"></a>关于debug源码</h2><p>说到了应用, 第一个是debug源码. 指第三方库的源码, 比如antd和react.</p><p>主要思路就是自己下载源码, 然后修改一些打包配置, 自己打包, 把sourcemap文件粘贴到node_modules里.</p><p>但具体的操作其实需要相当深的工程化基础, 至少看懂目标库打包流程的一半吧.</p><p>这里简单说说antd和react的流程.</p><p>antd的esm是gulp打的大家不熟悉, 所以选择了webpack打的umd流程, 所以在自己代码里要把import(‘antd’) 改成 require(‘antd’), 或者直接import对应目录的umd包.</p><p>antd的webpack已经打出了sourcemap, 但devtool的参数有问题, 要设成带module的, 才能最终指向源码, 而不指向webpack的打包结果. 因为antd源码是从tsx打成js再打es, antd自带的sourcemap只是从es5指到js的.</p><p>react是rollup打的, 在打包脚本里修改一系列参数, 自己打完包再把结果复制到node_modules里, 这个我没试.</p><p>另外, 如果项目语言和第三方库语言是同一种(比如tsx), 还可以通过直接复制源码到node_modules里来debug.</p><p>但还要做额外2件事: 修改打包脚本, 让打包规则走进node_modules里的这个包, 自己项目要安装第三方项目的所有依赖.</p><h2 id="关于debug线上代码"><a href="#关于debug线上代码" class="headerlink" title="关于debug线上代码"></a>关于debug线上代码</h2><p>在自己本地打好sourcemap的包以后, 在浏览器的source里找到对应的文件, 右击可以加载本地的sourcemap. 进一步还可以用override功能和抓包软件代理来进行本地代码调试线上.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.chrome.com/blog/sourcemaps/">https://developer.chrome.com/blog/sourcemaps/</a></p><p><a href="https://survivejs.com/webpack/building/source-maps/">https://survivejs.com/webpack/building/source-maps/</a></p><p><a href="https://webpack.js.org/configuration/devtool/">https://webpack.js.org/configuration/devtool/</a></p><p><a href="https://juejin.cn/post/7158430758070140942">https://juejin.cn/post/7158430758070140942</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个做购买决定的技巧</title>
      <link href="/2022/10/28/a-tip-for-making-purchasing-decision/"/>
      <url>/2022/10/28/a-tip-for-making-purchasing-decision/</url>
      
        <content type="html"><![CDATA[<p>人在买东西的时候不是理性人, 行为金融学探索了好多规律, 并已经被完美地应用到了吸引我们用钱的方法上.</p><p>你可以说”我愿意用这钱”, 但你应该不愿意知道赚了你钱的人在背后说你是个傻逼.</p><p>我做了个尝试来让自己做决定更理性.</p><span id="more"></span><p>锚点, 心理账户, 禀赋效应, 损失厌恶, 双曲贴现等一系列人脑思维模式导致的错误思考方式, 都让人容易做让自己后悔的买卖决定.</p><h2 id="让每一份东西的价格能归一化"><a href="#让每一份东西的价格能归一化" class="headerlink" title="让每一份东西的价格能归一化"></a>让每一份东西的价格能归一化</h2><p>归一这个词我是从knn算法获得的, 我们可以尝试把各个东西的价格映射到一个自己的标准上进行比较.</p><p>我把这个标准指定为<strong>在物品价值被消耗完前每一次使用的价格.</strong></p><p>简单的公式就是:</p><blockquote><p> ( 买入价格 - 残值 ) &#x2F; 使用次数.</p></blockquote><ul><li>在大多数场景下, 残值是0. 因为很多东西最简单的方式是直接扔, 处理他的成本会超过他的残值.</li><li>一些东西的使用次数是1(比如吃的), 一些日常使用东西的使用次数可以简化为每天.</li></ul><p>简单说说这么做在什么角度可以帮助我们做决策:</p><ul><li><p>平时我们是被锚点, 有了一些归一的价格, 锚点就是自己给的, 东西的价格贵不贵自然就清晰了.</p></li><li><p>被归一化的价格可以与目标价格比较, 从而打破心里账户的皮.</p><p>举例: 妈妈给我10万, 我用他买车不心疼. 在归一后发现也可以用妈妈给的10万在未来13年每天吃4块吮指原味鸡.</p></li><li><p>在算清楚未来的得失后, 厌恶损失可以被理性解决.</p></li><li><p>双曲贴现本身就是情绪的行为, 在算清具体利益后, 自然会选择利益比较高的方案.</p></li></ul><h2 id="一些东西的价格计算"><a href="#一些东西的价格计算" class="headerlink" title="一些东西的价格计算"></a>一些东西的价格计算</h2><p>算一些必需品, 是按照自己使用的东西, 或者是思考过价格想买的东西.</p><table><thead><tr><th>物品</th><th>日价格</th><th>月价格</th><th>年价格</th><th>总价</th><th>使用年限&#x2F;次数</th></tr></thead><tbody><tr><td>吃饭</td><td>66</td><td>1980</td><td>24090</td><td>早中晚6+30+30</td><td>一次</td></tr><tr><td>住房-全家-租</td><td>166</td><td>5000</td><td>60000</td><td>按5000一个月</td><td>-</td></tr><tr><td>住房-拥有</td><td>1660</td><td>15000</td><td>180000</td><td>450万按4%年化</td><td>-</td></tr><tr><td>手机-差</td><td>2.8</td><td>83</td><td>1000</td><td>3000</td><td>3年</td></tr><tr><td>手机-好</td><td>12</td><td>361</td><td>4333</td><td>13k</td><td>3年</td></tr><tr><td>手机-每年最新</td><td>22.5</td><td>675</td><td>8100</td><td>600(appcare)+13k&#x2F;2(折价)</td><td>1年</td></tr><tr><td>电脑-好</td><td>5.6</td><td>166</td><td>2000</td><td>12000 (14寸16+512m1pro)</td><td>6年</td></tr><tr><td>电脑-普通</td><td>3.4</td><td>101</td><td>1216</td><td>7300(8+256m1)</td><td>6年</td></tr><tr><td>鞋子</td><td>0.14</td><td>4.2</td><td>50</td><td>100</td><td>2年</td></tr><tr><td>头盔</td><td>0.3</td><td>8.3</td><td>100</td><td>300</td><td>3年</td></tr><tr><td>通货膨胀(每100万)</td><td>137</td><td>4167</td><td>50000</td><td>100万按5%</td><td>每年</td></tr></tbody></table><h2 id="如何比较决策与总结"><a href="#如何比较决策与总结" class="headerlink" title="如何比较决策与总结"></a>如何比较决策与总结</h2><h3 id="一直没有买的汽车"><a href="#一直没有买的汽车" class="headerlink" title="一直没有买的汽车"></a>一直没有买的汽车</h3><p>我们先来算一下平时的路费, 地铁10 * 22 * 12 &#x3D; 2640每年. 应该还有每个月多少消费后的打折我算不来.</p><p>摩托车油耗价格是地铁的一半, 即1320每年. (如果换以前的车油耗再减半, 700每年)</p><p>摩托车额外的费用是每年2次换机油150 * 2, 交强险 120, 黄牛买再加100, 车老了验车再加120.也就是420~640之间. 维修费用现在看来几乎是没. 所以比地铁便宜800一年左右.</p><p>车子买入价格是20000, 假设残值5000, 除以13年报废, 每年折旧1153, 大于800. 所以还是比公交贵, 但如果加上节假日的交通, 应该是便宜的.</p><p>而买汽车的话, 每年保险6000, 小区停车3000, 公司停车4200, 再加保养维修(具体不知道), 油耗也是摩托2倍以上, 保守估计每年多花15000, 每天就多花40块钱, 商场吃饭停车也比较贵.</p><p>这每天多的40, 加上地铁的10块钱, 单程打车25以内的上下班基本不用考虑汽车了.</p><p>这是没有算堵车和车折旧与维修的情况.</p><h3 id="优先买质量好的-其次才是价格"><a href="#优先买质量好的-其次才是价格" class="headerlink" title="优先买质量好的, 其次才是价格"></a>优先买质量好的, 其次才是价格</h3><p>刚毕业收入比较低的时候, 一个ipad1600, 安卓平板1000块.</p><p>那个安卓平板大概用了一个月, 坏了以后买了ipad, 竟然用到现在, 电池也没换过. 8年了, 如果归一到每天的价格, 质量好的东西比”所谓便宜”的东西便宜太多了.</p><p>所以买东西一定是质量优先.</p><h3 id="比较少用的东西"><a href="#比较少用的东西" class="headerlink" title="比较少用的东西"></a>比较少用的东西</h3><p>比如大冬天的衣服, 一次性的玩具(我买过一个牛反望远镜), 这些东西买的时候一定要多多思考.</p><p>一件大冬天的衣服可能一年就穿15天. 而价格一般四位数左右. 钱花完基本是没见他几眼就等着被丢了.</p><p>类似的”很少次数使用”的东西还是需要谨慎.</p><h3 id="租还是买了再买"><a href="#租还是买了再买" class="headerlink" title="租还是买了再买"></a>租还是买了再买</h3><p>像用得比较少的, 一些东西就可以靠租, 或者买了再买. 这就必须对物品的价值曲线比较了解了, 可以比较后再决定.</p><h3 id="游戏折现"><a href="#游戏折现" class="headerlink" title="游戏折现"></a>游戏折现</h3><p>游戏运营也是文章开头所说的”把行为金融学完美应用在运营上”的例子之一, 因为赚钱.</p><p>而尝试去把游戏价值归一的话, 就可以逃出运营了.</p><p>比如: 首胜给30蓝色精粹, 200天可以买个英雄, 价值45. 你每天的首胜只值0.225, 而要花费至少15分钟, 有时候会是很多精力和时间.</p><p>比如: 30买的月卡, 用了沉没成本, 让你60天天天来一把, 奖励是2个皮肤, 可能价值150吧.</p><p>比如: 说是免费的事情, 其实是买了我们的时间. 用我们大量的时间换了5块钱.</p><p>开着电瓶车去地铁站拉一个客只需要半小时(包含等待). 就可以赚15块钱了.</p><p>我们要清楚的知道, <strong>价格的本质是人的劳动时间</strong>. 你的时间本可以产生更多钱.</p><h2 id="人的时间和效用"><a href="#人的时间和效用" class="headerlink" title="人的时间和效用"></a>人的时间和效用</h2><p>我们归一的单位可能是每天使用多少钱, 或者每次.</p><p>我们深入这个角度, 还会发现一个问题: <strong>人每天只有24小时, 并且人一生的小时数也是有限的.</strong></p><p>所以每一份钱, 花到人身上如果平摊到小时. 可能数字又是不同的.</p><p>比如电脑和手机是我使用时间最长的, 也许可以在他们身上多用点钱.</p><p>而被咒术回战封印五条悟的脑内时间启发, 我们还忘记了信息密度和效用的问题.</p><p>比如衣服, 每买一件衣服, 就会提升其他衣服的单位时间费用.</p><p>而如果我只穿一件衣服, 虽然单位时间成本很低, 但他的效用降低了, 可能对我来说失去了衣服的漂亮的作用, 而人只有24小时, 钱可能是用不完的.</p><p>所以我们去计算归一价格的目的, 并不是为了购买最便宜的东西, 而是权衡价格和效用, 把钱花得最合理, 最舒服, 最让人开心.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何简单地阅读ct和mri报告</title>
      <link href="/2022/10/28/how-to-read-ct-and-mri-report/"/>
      <url>/2022/10/28/how-to-read-ct-and-mri-report/</url>
      
        <content type="html"><![CDATA[<p>ct和mri报告”诊断”栏是给患者看的, 但一般都不会说确诊了什么病. 扫描结果描述里有一些术语.</p><p>然后内科医生竟然也看不懂片, 外科号比较少, 等待的一周里自己了解下一些概念.</p><span id="more"></span><h2 id="ct"><a href="#ct" class="headerlink" title="ct"></a>ct</h2><p>ct用的是x光.</p><p>不同于x光片, x光片就射一次x光, 投影到片子上.</p><p>ct每隔5mm进行断层扫描, 所以可以看到目标内部情况.</p><p>每次x光射向目标组织, 不同的物质吸收x光的能力不同, 最后成像的x光密度也就不同.</p><p>所以ct里只有一个概念”密度”. 在片子上看到的效果也就是颜色(黑白)深浅.</p><p>由白到黑分别是: 高密度 &#x3D;&gt; 等密度(正常) &#x3D;&gt; 稍低密度 &#x3D;&gt; 低密度.</p><p>对应的物质是由硬到软, 可能是: 钙化 &#x3D;&gt; 血 &#x3D;&gt; 普通组织 &#x3D;&gt; 水 &#x3D;&gt; 空气.</p><h2 id="mri"><a href="#mri" class="headerlink" title="mri"></a>mri</h2><p>mri的成像原理比较复杂, 涉及到量子力学和数学, 我肯定是搞不懂. 大概流程是:</p><p>先用很大的磁场把人磁化. (磁化原理是人身体里有水, 水里有h, h有电磁. 所谓核磁指的就是h的电磁.)</p><p>磁化以后用(不同角度&#x2F;频率&#x2F;波长的)射频来让核磁发生能级跃迁, 从而产生磁场变化.</p><p>这些磁场变化会被接受线圈所记录.</p><p>不同组织因为水含量不同导致衰变速度不同, 于是通过复杂的数学结合一些策略就可以画出一系列点阵图了.</p><p>我在看的mri报告有几个概念: t1, t2, t1wi, t2wi, dwi, flair. </p><p>这几个序列看起来是平级的, 但一些序列是有先后关系的, 这个我们暂时不管, 只需要<strong>认为不同序列是用不同角度来看目标</strong>就可以了.</p><p>不同的序列可以看到的目标物质不同.</p><p>然后经过排列组合, 就能判断每个地方是什么物质了.</p><p>又然后通过不同层次, 角度, 可以在有经验的医生脑中形成三维的影像了. (不知道以后能不能通过技术做到.)</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>electron的mac包部署发布流程</title>
      <link href="/2022/10/19/things-about-electron-mac-deployment/"/>
      <url>/2022/10/19/things-about-electron-mac-deployment/</url>
      
        <content type="html"><![CDATA[<p>偶然发现<a href="https://github.com/cwj0417/schedule-pro">之前开发的效率软件</a>在github上下载了不能打开, 弄完签名发现以前弄过, 但没记录, 现在简要记录一下在mac平台上发布部署流程.</p><span id="more"></span><h2 id="icns图标"><a href="#icns图标" class="headerlink" title="icns图标"></a>icns图标</h2><p>mac打包需要icns图标, 是mac specified的. icns虽然会在finder里显示图片, 但他不是一个图片, 而是一个图片集合.</p><p>准备好一个<code>icon.png</code>后需要2个步骤来生成icns: 使用sips裁剪图片, 使用iconutil生成icns.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir icons.iconset</span><br><span class="line">sips -z 16 16 icon.png -o icons.iconset/icon_16x16.png</span><br><span class="line">sips -z 32 32 icon.png -o icons.iconset/icon_16x16@2x.png</span><br><span class="line">sips -z 32 32 icon.png -o icons.iconset/icon_32x32.png</span><br><span class="line">sips -z 64 64 icon.png -o icons.iconset/icon_32x32@2x.png</span><br><span class="line">sips -z 128 128 icon.png -o icons.iconset/icon_128x128.png</span><br><span class="line">sips -z 256 256 icon.png -o icons.iconset/icon_128x128@2x.png</span><br><span class="line">sips -z 256 256 icon.png -o icons.iconset/icon_256x256.png</span><br><span class="line">sips -z 512 512 icon.png -o icons.iconset/icon_256x256@2x.png</span><br><span class="line">sips -z 512 512 icon.png -o icons.iconset/icon_512x512.png</span><br><span class="line">sips -z 1024 1024 icon.png -o icons.iconset/icon_512x512@2x.png</span><br><span class="line">iconutil -c icns icons.iconset -o icon.icns</span><br></pre></td></tr></table></figure><p>这个sips在平时对图片进行裁切旋转拉伸也是好用的.</p><h2 id="code-sign"><a href="#code-sign" class="headerlink" title="code sign"></a>code sign</h2><p>mac打包必须经过code sign才能被下载使用. 步骤也挺简单的.</p><ol><li>网上下载一个最新的<code>apple wwdrca</code>(Apple Worldwide Developer Relations Certification Authority)放到keychain里的system里.</li><li>在xcode的account里生成一个apple development证书.</li></ol><p>好了, 完事. 但记得在换电脑或证书过期的时候要重新操作一遍. 我就是因为换电脑并过期重新操作的时候忘了以前怎么弄的又折腾了一下.</p><h2 id="ci-code-sign"><a href="#ci-code-sign" class="headerlink" title="ci code sign"></a>ci code sign</h2><p>我的ci用的github action, 其他的也类似.</p><p>electron-builder使用体验非常好, 接受base64证书, 而不需要在ci里写麻烦的流程. 我们要做的是:</p><ol><li>在keychains里把apple development证书导出p12文件.</li><li>获取p12文件的base64值.</li><li>在github新建一个environment, 设置2个秘密变量, 一个是base64值, 一个是导出p12时候设置的密码.</li><li>在ci里指定environment为上个步骤创建的environment.</li><li>在ci执行electron-builder的那一步新增2个env: <code>CSC_LINK</code>和<code>CSC_KEY_PASSWORD</code>分别指向环境的秘密变量. (要使用env变量不能export定义变量)</li></ol><p>好了, 又完事. 这样ci环境也会进行code sign了. <a href="https://github.com/cwj0417/schedule-pro/blob/main/.github/workflows/build.yml">如果觉得抽象就点这里看具体ci</a>.</p><p>另外有个小细节, 如果不小心在keychains里把证书删了无法导出, 去xcode新建一个项目, 证书就会重新被产生了.</p><h2 id="auto-update"><a href="#auto-update" class="headerlink" title="auto update"></a>auto update</h2><p>直接使用electron-builder的auto-updater. 按照文档做好配置, call几个api, 非常丝滑, 就能达到非常理想的程度.</p><p>用户第一次下载并右击打开软件后, 以后我们推了代码后用户就能丝滑更新了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动远程组件</title>
      <link href="/2022/09/24/manual-remote-component/"/>
      <url>/2022/09/24/manual-remote-component/</url>
      
        <content type="html"><![CDATA[<p>因为一些交付场景, 最近遇到了2个项目需要使用远程组件.</p><p>第一个在疫情居家期间, 使用了module federation实现了一下.</p><p>最近的项目尝试了手动加载远程组件, 所以产生了一些对比.</p><span id="more"></span><p>对比的方式是mf和手动.</p><p>我会从使用方式, 原理比较, 和各方面综合比较来进行对比.</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="mf"><a href="#mf" class="headerlink" title="mf"></a>mf</h3><p>mf的使用方式只需要照着webpack文档操作就行了, 分为主应用和子应用, 子应用比较简单先说</p><h4 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h4><p>在<code>ModuleFederationPlugin</code>插件里配置:</p><ul><li>子应用名字</li><li>输出的文件名</li><li>文件入口</li><li>共享模块</li></ul><p>于是webpack打包结果就会多出一个作为远程组件的文件.</p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>在<code>ModuleFederationPlugin</code>插件里配置:</p><ul><li>远程组件的url和名字</li><li>共享模块</li></ul><p>然后配置<code>ExternalTemplateRemotesPlugin</code>, 并把应用相关入口改成dynamic import.</p><p>使用的时候mf和手动都使用了React.Suspense和React.lazy, mf使用的时候lazy里dynamic import设置好的共享模块名字就可以了.</p><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><h4 id="remote-1"><a href="#remote-1" class="headerlink" title="remote"></a>remote</h4><p>在webpack配置里增加一个entry指向组件, 并设置output.library.</p><p>output.library我尝试过2种设置, umd和window, 都可以正常运行, 打包体积也基本一致(umd会稍微多一点), window的缺点是需要设置name, 让人有些不舒服. (即使可以随便写, 但在使用组件的时候得写额外的逻辑, 想名字也比较花时间)</p><h4 id="master-1"><a href="#master-1" class="headerlink" title="master"></a>master</h4><p>主应用只要做一件事: 手动请求remote组件资源并解析. 然后作为promise的结果返回给lazy方法.</p><p>对应着umd打包结果方式是: 准备<code>module, </code>exports<code>, 和一个对应着远程组件externals的</code>require()&#96;方法. 然后eval资源, 远程组件就在module.exports里了. 代码片段:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">require</span> = p =&gt; (&#123;</span><br><span class="line">    <span class="title class_">React</span>,</span><br><span class="line">    <span class="title class_">ReactDom</span></span><br><span class="line">  &#125;[p]);</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="built_in">exports</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">eval</span>(res);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="variable language_">module</span>.<span class="property">exports</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应window打包结果只需要准备1个变量, 名字随意, 把共享模块放上, 并留一个目标模块的placeholder键, 然后替换资源的<code>window.</code>成自己的变量, eval变量后, 就得到了模块.</p><p>如果觉得麻烦的话, eval以后直接取<code>window.xxx</code>就行了, 也能走通. 流程化是另外一个话题了.</p><h2 id="原理比较"><a href="#原理比较" class="headerlink" title="原理比较"></a>原理比较</h2><h3 id="mf-1"><a href="#mf-1" class="headerlink" title="mf"></a>mf</h3><p>我们这里其实指的是webpack的mf, 所以原理会和webpack比较相关. <a href="/2022/07/28/module-of-webpack-output-in-depth/">之前有文章</a>比较详细的讲了, 这里总结下.</p><ol><li>当主应用引入了子应用, 会通过网络请求获取到子应用的资源.</li><li>子应用通过<code>window.compName</code>把入口暴露给主应用. 但拥有自己独立的运行闭包.</li><li>子应用加载的时候主子应用会共享一个变量(webpack__.s), 变量里存着需要被共享的模块, 并指向子包的资源. (比如使用子包的react和react-dom)</li><li>主&#x2F;子应用配置过的模块都会去共享变量(webpack__.s)里取.</li></ol><h3 id="手动-1"><a href="#手动-1" class="headerlink" title="手动"></a>手动</h3><p>手动加载就简明很多. 主应引用子应用时, 通过网络请求获取子应用的资源, 并根据子应用打包方式最终获取react组件. (其实就是个js方法)</p><p>在加载子应用的时候, 通过中间变量将主应用的模块直接传给子应用, 以达到共享模块的目的.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过了比较以后, 发现这两个方案不可以比较.</p><p>因为mf是一套完整的解决方案, 而手动加载只是简单的poc.</p><p>但和所有框架的对比一样, 功能完备就会有大多场景都不需要的功能, 我的看法是, <strong>如果场景确定切重复, 推荐手动加载远程组件</strong>.</p><p>简单的在几个场景下比较一下:</p><ul><li><p>配置复杂度.</p><p>相比手动加载只需要把子应用externals的包都注入, mf的配置就比较复杂, 需要配置子应用名字也是一个不舒服的地方.</p></li><li><p>代码复杂度.</p><p>手动加载只有加载的时候有特殊的代码, 抽象一下调用会更简单.</p><p>而mf会要求远程组件入口前要dynamic import, 并且引入远程组件的名字也要和配置中的一样.</p></li><li><p>打包体积.</p><p>最明显的是, mf的包必须把依赖都打到包里, 而手动打可以设置externals.</p></li><li><p>开发体验.</p><p>mf在开发的时候要将主应用配置子应用的地址是localhost, 再用monorepo工具同时起2个应用.</p><p>手动加载的情况, 开发时主应用直接引用子应用, 但最后要改成加载远程组件的方法.</p><p>或者子应用单独作为组件开发, 写个模拟入口.</p></li></ul><h3 id="聊聊mf复杂的原因和手动加载的更大灵活性"><a href="#聊聊mf复杂的原因和手动加载的更大灵活性" class="headerlink" title="聊聊mf复杂的原因和手动加载的更大灵活性"></a>聊聊mf复杂的原因和手动加载的更大灵活性</h3><p>其实上面几个mf复杂的原因基本来自于对共享模块的处理, 而我们的场景固定在react组件, 整个应用里不会有多个react版本, 所以就可以少处理很多事.</p><p>当然, 有一些地方手动加载比mf更复杂的, 但根据我们自己的业务来开发工具和流程, 手动加载的可扩展性更强, 天花板更高.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们并不知道什么是正确</title>
      <link href="/2022/09/18/we-can-only-recognize-mistakes/"/>
      <url>/2022/09/18/we-can-only-recognize-mistakes/</url>
      
        <content type="html"><![CDATA[<p>我们其实没有知道”什么是正确的”的能力, 而只被赋予了知道”什么是错误的”的能力.</p><p>所以世上没有”人类定义的完美”的东西.</p><p>所以所有人一定会死, 所以技术框架会不断迭代.</p><span id="more"></span><h2 id="可能导致了这些现象"><a href="#可能导致了这些现象" class="headerlink" title="可能导致了这些现象"></a>可能导致了这些现象</h2><p>不知道为什么我会思考起了这个问题, 也许因为太多现象可能是由这个基础导致的了. 举一些例子</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>无论是软件设计, 还是视觉设计, 交互设计. 一个外行人评价一个设计只有能力找出设计的问题, 而说不出设计哪里好, 对一个设计最好的评价可能是自然. </p><p>有相应经验的人才能说出设计具体好在哪里.</p><h3 id="身体和人际关系"><a href="#身体和人际关系" class="headerlink" title="身体和人际关系"></a>身体和人际关系</h3><p>我们不知道一个正常的身体是如何运行的, 在一个器官出问题前, 是不知道他的存在的.</p><p>一段健康的人际关系也是如此, 有句歌词叫”说不清哪里好, 但就是谁都替代不了”.</p><p>如此就产生了一个比较严重的问题: 因为我们不知道好在哪里, 所以会没有能力去探测好的东西开始变坏的时候.</p><h3 id="幸福感不来自于拥有"><a href="#幸福感不来自于拥有" class="headerlink" title="幸福感不来自于拥有"></a>幸福感不来自于拥有</h3><p>而来自于获得时候的喜悦. 所以对一个拥有着的东西最好的评价是: “离不开他了”. 有很多类似的情况:</p><ul><li>胃出血恢复了, 于是又开始吃香喝辣了. (这可能说明症状真的好了)</li><li>工资慢慢变高, 但并没有持续开心, 只有涨&#x2F;跌&#x2F;对比的时候情绪有变化.</li><li>追到了女朋友后, 感觉也就那样了.</li><li>买了更好的车, 骑了一段时间开心程度就和老车一样了.</li></ul><p>哦, 上面的工资和车的前提当然是, 够用. 手机也是一样. 所以物质的东西其实有这么一个线的.</p><p>还有一些我们天生就拥有着的东西, 比如健康, 父母和他们的照顾, 国家的运行和保护, 空气, 甚至”使人类产生并可以存活的环境和契机”</p><h2 id="猜想一下原因"><a href="#猜想一下原因" class="headerlink" title="猜想一下原因"></a>猜想一下原因</h2><p>我尝试问自己某个做法&#x2F;现象是否正确, 比如: <code>红灯应不应该过马路</code>.</p><p>我们思考过程只能是回忆以往的知识和错误经验.</p><p>也许从别人告知的结论是不应该, 但如果一直没有被警察抓或者被别人骂或者出车祸, 人慢慢地尝试红灯过马路.</p><p> (从某个角度来说这是人在尝试进化, 车祸死亡只是进化的尝试, 希望减少死亡率是政府的目标, 所以强调红灯过马路是错误的)</p><p>所以<strong>也许没有什么东西是所谓正确的, 只是我们在当前情况下尝试寻求最优解.</strong> 正如生物进化其实是”演化”.</p><p>以前的老规矩是基于熟人社会的, 现在城市化现代化的发展, 很多规则以前是奏效的, 但现在不奏效了. 这也是我们和父辈的一个矛盾来源. 而我们去思考老规则对不对的起点, 也是”感受到了老规则的错误”对我们造成的痛苦.</p><p>总结原因: 世界不是我们造的, 人类只能以这个复杂程度的大脑来认识世界.</p><p>客观地来讲, 人类只能主观地认识世界, 客观是不存在的. 只有”我在思考”, “我的意识”是唯一的真相, 其他的知识都是通过客体与主观的交互, 产生经验并进行一些逻辑推演而记住的短暂的结论.</p><p>并且, 人类的逻辑非常有限, 这也是我们必须理论结合实际的原因.</p><h2 id="学习的本质可能是"><a href="#学习的本质可能是" class="headerlink" title="学习的本质可能是?"></a>学习的本质可能是?</h2><p>假设”我们不知道正确的东西是什么”, 那么人类构造的一切, (钱, 国家, 各种方法, 各种模式, 软件等等一切东西), 是以什么为蓝图的呢?</p><p>可能就是发生的导致痛苦的点. (原本的措辞是”错误”, 虽然更好理解, 但实际并不是)</p><p>举例: 为什么软件设计会有很多规则, 设计模式? 软件规模变大以后会变乱, 规则和设计模式可能都是有了bug才会有的. (为了解决bug的产物)</p><p>基于这个推论, 我对于学习的认知和心态, 有了一些变化:</p><ul><li>发生问题错误不用觉得是”不正常”, 软件的进化就是由错误造就的. (人生也是如此, 只是已有知识库更大一些) 所以没有必要害怕错误, 错误是正常的过程. (并会永久伴随)</li><li>在看别人代码的时候, 要体会到, 每句代码都是有写他的理由的, 理由一定是曾经发生了什么非预期的错误或解决一些问题. 所以软件是由业务问题(需求)和软件问题(bug)产生的. (所以也感受到了tdd的合理性)</li></ul><h2 id="我们应该注意点什么"><a href="#我们应该注意点什么" class="headerlink" title="我们应该注意点什么"></a>我们应该注意点什么</h2><p>因为我们不能知道”什么是正确的”, 所以人很难察觉身体正在变坏的点, 或者是自己哪里做错伤到了人际关系. 我认为<strong>我们需要有意识地主动从2个角度思考</strong>:</p><ul><li>观察别人发生了的错误和痛苦, 来思考自己身上同样的问题.</li><li>回忆”不曾拥有”的时刻, 或假设失去的时候. 来珍惜&#x2F;意识&#x2F;感激现在所拥有的. 比如健康&#x2F;家人&#x2F;国家&#x2F;宇宙环境(不是开玩笑).</li></ul><p>这个结论也带给了我一个重要的心态变化: <strong>看到别人遇到问题的时候, 应该警惕或感谢自己身上同样的点.</strong> 而不是别的心态. (可能是嘲笑可能是与我无关)</p><p>最后, 思考一个功利的问题. “如何让别人觉得我好”.</p><p>以前听了个扁鹊的故事, 扁鹊是三兄弟里水平最差的, 因为他的2个哥哥在病人没感到痛苦的时候就预防了问题发生.</p><p>那么”我做得好, 别人反而感受不到”怎么办呢.</p><p>比如自己做得好, 老板看不见. 或者自己对小孩很好, 小孩却不觉得自己好, 最后造成很不好的结果.</p><p>思考了一会, 意识到, 这是一个伪命题.</p><p>因为问题&#x2F;错误会不断地出现的, <strong>我们要做的是多学习思考, 让自己有储备来解决不断出现的问题.</strong> 这样别人会体会到我们的价值.</p><p>另外, 错误是一直出现的, 其实自己也一直在犯错的, <strong>如果一直思考这个伪命题, 会导致自己犯更多的错.</strong></p><p>最后的最后, 解释一下”大人对小孩很好, 小孩却不知道, 还对大人不好”的问题. </p><p>这个问题也许是我比较害怕的, 因为周围有比较恐怖的例子. 但后来我想明白了: 问题中的”大人对小孩好”, 是指大人为小孩付出金钱和体力. 但这并不是”对孩子好”.</p><p>真正的对孩子好是心力的付出, 包含2部分. </p><ul><li>去认真思考孩子需要什么. (生存的能力与快乐) 只是付出钱与体力只是一种懒惰, 并不是对孩子好. (这里不用”害了孩子”这种措辞, 每个父母都是爱孩子的)</li><li>尊重孩子. (太难了, 需要尽量频繁的质问自己, 在一些场景下是不是尊重孩子了, 似乎不尊重孩子是一种天性, 需要去克服)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作也没那么坏</title>
      <link href="/2022/09/14/working-is-not-that-bad/"/>
      <url>/2022/09/14/working-is-not-that-bad/</url>
      
        <content type="html"><![CDATA[<p>我算是个经常说工作垃圾的人, 最近八卦到一些别人的事儿, 反过来看自己, 觉得自己的工作还是有一些优点的.</p><span id="more"></span><h2 id="关于喜欢-钱-闲"><a href="#关于喜欢-钱-闲" class="headerlink" title="关于喜欢, 钱, 闲"></a>关于喜欢, 钱, 闲</h2><p>我一直很追求喜欢. 我认为喜欢等同于幸福, 在做喜欢的事的时候, 就是幸福的.</p><p>并且只有喜欢才能使人深耕, 因为没有喜欢是很难从困难中坚持下来的.</p><p>不止在工作中, 在所有人际关系中, 喜欢也是获得幸福的唯一途径.</p><p>以前有个问题困扰着我, 关于工作中的学习的: </p><blockquote><p>我工作就是为了钱, 不想学那么多东西, 好羡慕那些喜欢工作的人.</p></blockquote><p>我目前的观点是: 让自己喜欢上正在做的事, 是一种能力.</p><p>与喜欢相对的概念, 是钱.</p><p>举个例子: 理想与欲望. 理想是追逐与得到的时候快乐; 欲望是得不到会痛苦.</p><p>举个例子: 我们一开始喜欢一个手机游戏是因为游戏内容; 慢慢的变得追求数据.</p><p>很明显地, “有想要去做的事”, “有想要玩的游戏” 的时候是幸福的.</p><p>而”死磕收益细节”, “追求游戏装备” 的时候是无趣的, 麻木的, 甚至受控制的.</p><p>但也许我的判断不可靠, 因为我并没有尝试过在游戏上达到巅峰, 或者是买喜欢的装备. 我一直想买的摩托车没有买, 手机也一直用老款的, 是因为我一直相信即使得到了, 快乐只能持续很短的时间.</p><p>希望我以后的经济水平能让我买下所有想买的东西, 并证明钱不能比喜欢让人更幸福.</p><p>闲, 是我最近看到, 或八卦到的别人的生活.</p><p>有的人很有钱, 据说月收入二十多万, 有的人经济条件还没有我好.</p><p>我认为他们过得都没有我开心. 因为我有空的时候有想写的项目和想写的博客, 很充实.</p><p>闲是万恶之源, 我一直持有这样的观点, 并且闲的源头是懒和自我封闭, 也是我的观点.</p><p>最后, 有钱的闲, 似乎比不那么有钱的闲更可怕. (钱富余的, 正好的, 缺钱的有不同的表现)</p><p>所以感谢我的工作, 给了我喜欢和兴奋的感觉, 给了我很多需要去做的事.</p><h2 id="为什么爸妈不肯用主动降噪耳机"><a href="#为什么爸妈不肯用主动降噪耳机" class="headerlink" title="为什么爸妈不肯用主动降噪耳机"></a>为什么爸妈不肯用主动降噪耳机</h2><p>我刚接触觉得这很酷, 想分享给爸妈, 结果当然是被敷衍.</p><p>从工作中学到了, 要分析用户的需求后, 感觉到生活中还有很多类似的事.</p><p>钱是个稀缺的东西, 一个东西的稀缺会导致我们高估他的价值. 基于这个基础, 我们很多人都认为钱能解决一切事情.</p><ul><li>比如喜欢爸妈就给爸妈买东西; </li><li>想孩子幸福就留给她钱和房子; </li><li>想和朋友搞好关系就送他礼物;</li></ul><p>经过一系列思考, 我放弃了给爸妈买礼物, 得到了一些结论:</p><ul><li>自己身体好, 生活正常, 就能让爸妈开心. 如果想给父母extra快乐就陪他们一起玩.</li><li>我能给孩子的是少做让他难受的事, 和在他需要帮助的时候帮助他.</li><li>与朋友相处能静心地聊天, 听别人的故事, 安慰别人的焦虑.</li></ul><p>显而易见地, 这些需求比直接给钱难得多. </p><p>但也减少很多扣款的心疼.</p><h2 id="我应该去做什么"><a href="#我应该去做什么" class="headerlink" title="我应该去做什么"></a>我应该去做什么</h2><p>这个问题也是工作推动我去思考的. 因为软件的开发比硬件快得多, 在很多的工作变化, 项目中, 我才意识到我们应该试着去思考形而上的问题.</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>软件工程追求的东西: 效率, 质量, 可维护性.</p><p>前端不断在发展的框架, 工具链都是在想办法提高这三个东西.</p><p>时代的脚步是不可阻挡的, 所以工作和生活, 我们都得思考如何工程化, 流程化, 自动化.</p><h3 id="cv战士的反思"><a href="#cv战士的反思" class="headerlink" title="cv战士的反思"></a>cv战士的反思</h3><p>在工作中, 大家都会使用复制-粘贴-修改三部曲的模式来完成大多数工作. 我的朋友称这是cv战士.</p><p>cv战士的缺点大家都知道: 他们不完全知道自己在做什么, 所以会偶尔产生问题从而降低工作效率. 之前我一直吐槽的redux-thunk的用法和action type算是一个.</p><p>最近进行了一些code review, 竟然发现, 盲目遵从一些代码规范也会产生问题.</p><p>比如大名鼎鼎的dry原则. dry的目的是让代码更好维护, 所以在抽取代码的时候一定要预判将来的需求会如何维护代码.</p><p>抽取过程和对需求的预判都是消耗时间的, 盲目dry可能导致代码更不易维护.</p><p>所以我现在认为: <strong>任何事情都需要思考: 为什么要这样做. 不要闭着眼睛遵循任何规定.</strong></p><h2 id="关于老板为什么不给这么强的我加工资"><a href="#关于老板为什么不给这么强的我加工资" class="headerlink" title="关于老板为什么不给这么强的我加工资"></a>关于老板为什么不给这么强的我加工资</h2><p>这也是我最近才想明白的问题.</p><p>答案有2部分: </p><ul><li>这么强的我, 只是我的以为.</li><li>老板也是人.</li></ul><p>我那么强为什么不给我加工资, 其实是无视客户需求的表现. 我们要做的是<strong>去成为老板需要的人</strong>, 而不是<strong>去成为自己以为老板需要的人</strong>.</p><p>技术人往往在某些时间段高估了自己技术对别人的价值.</p><p>第二, 我进行了换位思考.</p><p>老板拿了钱只分一小部分给员工. 和我们拿了工资存起来很大一部分, 是一个行为.</p><p>老板明知道员工水平上升, 但不给加工资, 和我们希望不加活也能加工资, 是一个行为.</p><p>所以我认为, 我和老板是同一种人, 所以就理解他了. (并没有)</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>有个话题叫”工作生活平衡”.</p><p>但有时候我觉得,  工作是生活的一部分.</p><p>我们要吃饭, 以前要采集, 后来要种地, 现在分工品种更多了而已.</p><p>不工作本就不应该可以存活下去.</p><p>有人谈到工作, 说要谈job而不是work. 我觉得job离不开work, 是work组成job的.</p><p>最后, 我喜欢工作, 并不影响我讨厌现在公司的老板和一些领导和一些同事.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编写一个eslint rule</title>
      <link href="/2022/08/29/create-an-eslint-rule/"/>
      <url>/2022/08/29/create-an-eslint-rule/</url>
      
        <content type="html"><![CDATA[<p>上周参加了职业生涯来第一次code review, 我的老板收集了好几个问题. review结束后我产生个想法, 是不是可以把这些rule写到公司的eslint里. </p><p>于是看了下文档, 总结是: 流程非常简单.</p><span id="more"></span><p>流程简单, 但rule的难度上限不低. 比如<code>useEffect</code>的依赖. 但大多数我认为还是挺简单的.</p><h2 id="rule构成"><a href="#rule构成" class="headerlink" title="rule构成"></a>rule构成</h2><p>一个eslint rule的形式是一个对象. 类型是<code>import(&#39;eslint&#39;).Rule.RuleModule</code>.</p><p>很简单2个key: </p><ul><li>meta: 描述这个rule的名字, 文档地址, 描述等基本信息.</li><li>create: rule的具体内容.</li></ul><h2 id="runtime开发流程"><a href="#runtime开发流程" class="headerlink" title="runtime开发流程"></a>runtime开发流程</h2><p>文档里对runtime的开发流程说得不太清爽, 所以这里说明一下.</p><p>首先: runtime开发指什么? 答: 直接在项目里编写规则, 而不是发到npm.</p><p>优点: 开发的时候可以直接使用项目代码作为开发资源, 不需要使用npm link.</p><p>缺点: 不能在ide上看到自己文件的划线. 因为eslint resolve plugin的方式不支持本地. (不确定, 只是经验性的)</p><p>解释优缺点, 说一下开发流程:</p><ul><li>创建一个文件夹.</li><li>在运行eslint的时候加上配置: <code>--rulesdir [dir]</code>. (推荐写到npm script里)</li><li>在这个文件夹下创建js文件. 每个js文件都会被读取.</li><li>js文件只要<code>module.exports = &#123; meta: &#123; type: &#39;name&#39; &#125;, create: function () &#123;&#125; &#125;</code>就可以了.</li><li>在eslintrc的<code>rules</code>字段配置自己写的rule.</li></ul><p>然后一遍编写rule, 一边运行npx eslint就可以开发调试了.</p><p>##npm包开发流程</p><p>正儿八经的开发, 直接看文档就行了. 总结下:</p><ul><li>直接用yoeman生成模板, 文件结构都弄好了.</li><li>开发的时候只能tdd开发, 可以把项目里真实的例子拷过来, 但不如直接写完在项目里跑爽, runtime开发等于直接加载了很多case.</li><li>开发完按照一定命名规范发到npm上, ide里就可以看到划线了. (巨大优点, 真帅)</li></ul><h2 id="如何编写rule"><a href="#如何编写rule" class="headerlink" title="如何编写rule"></a>如何编写rule</h2><p>终于到了正题, 如何编写rule. </p><p>首先明确, rule的内容都在<code>create</code>方法里. 于是我们看一下<code>create</code>方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">create</span>: <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// declare the state of the rule</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title class_">ReturnStatement</span>: <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">      <span class="comment">// at a ReturnStatement node while going down</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// at a function expression node while going up:</span></span><br><span class="line">    <span class="string">&quot;FunctionExpression:exit&quot;</span>: checkLastSegment,</span><br><span class="line">    <span class="string">&quot;ArrowFunctionExpression:exit&quot;</span>: checkLastSegment,</span><br><span class="line">    <span class="attr">onCodePathStart</span>: <span class="keyword">function</span> (<span class="params">codePath, node</span>) &#123;</span><br><span class="line">      <span class="comment">// at the start of analyzing a code path</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onCodePathEnd</span>: <span class="keyword">function</span>(<span class="params">codePath, node</span>) &#123;</span><br><span class="line">      <span class="comment">// at the end of analyzing a code path</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档里粘来的例子, 我们来看看结构:</p><ol><li>接受一个参数<code>context</code>, 提供了一系列方法.</li><li>返回一个对象, 键是ast的节点名字, 会在遍历ast的时候调用.</li></ol><p>(题外话: 之前看vuejs设计与实现编译部分还写了<a href="/2022/05/04/compile-html-piece-to-sass-structure/">一篇总结</a>, 但提到如何组织traverse函数, 如何组织context一笔略过了, 之后可能再补补详细内容)</p><p><code>create</code>方法结构很简单, <strong>我们要做的事也很简单</strong>:</p><ol><li>在需要查找的ast节点中判断代码是否符合rule.</li><li>使用<code>context.report</code>方法来报错. (如果判断到代码不符合rule的话)</li><li>使用<code>fix</code>方法提供的<code>fixer</code>对象来进行修复. <code>fixer</code>的方法很少, 就简单的新增&#x2F;替换&#x2F;移除操作.</li></ol><p>ast的查看方式到<a href="https://astexplorer.net/">这个网站</a>, 选一个eslint的parser, 不同parser的ast结构有所不同.</p><p>我猜想的执行方式是: 每个文件会新建一个context对象和一个新闭包, 遍历ast, 执行对应的create里的方法.</p><p>由此得出结论: </p><ol><li>在<code>create</code>方法里可以保存变量来辅助我们判断和修复.</li><li><code>create</code>方法返回的不同方法执行的顺序是遍历ast的顺序.</li></ol><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>最后贴一下我假想的例子: 提示并修复魔法数字.</p><p>这是个简单的demo, 只处理了<code>res === 1</code>类似的情况, 甚至还没能处理<code>res.code === 1</code>(因为修复的时候比较麻烦). 所以只是个demo并不能使用. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;eslint&#x27;).Rule.RuleModule</span>&#125; */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;no-magic-string&quot;</span>,</span><br><span class="line">        <span class="attr">fixable</span>: <span class="string">&quot;code&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">create</span>: <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> enums = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title class_">BinaryExpression</span>(node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">operator</span> === <span class="string">&#x27;===&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node.<span class="property">left</span>.<span class="property">type</span> === <span class="string">&#x27;Identifier&#x27;</span> &amp;&amp; node.<span class="property">right</span>.<span class="property">type</span> === <span class="string">&#x27;Literal&#x27;</span>) &#123;</span><br><span class="line">                        context.<span class="title function_">report</span>(&#123;</span><br><span class="line">                            node,</span><br><span class="line">                            <span class="attr">message</span>: <span class="string">&#x27;magic string was not desirable&#x27;</span>,</span><br><span class="line">                            <span class="title function_">fix</span>(<span class="params">fixer</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!enums[node.<span class="property">left</span>.<span class="property">name</span>]) enums[node.<span class="property">left</span>.<span class="property">name</span>] = <span class="keyword">new</span> <span class="title class_">Set</span>([])</span><br><span class="line">                                enums[node.<span class="property">left</span>.<span class="property">name</span>].<span class="title function_">add</span>(node.<span class="property">right</span>.<span class="property">value</span>)</span><br><span class="line">                                <span class="keyword">return</span> fixer.<span class="title function_">replaceText</span>(node.<span class="property">right</span>, <span class="string">`enum_<span class="subst">$&#123;node.left.name&#125;</span>.type_<span class="subst">$&#123;node.right.value&#125;</span>`</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;Program:exit&#x27;</span>(node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">keys</span>(enums).<span class="property">length</span>) &#123;</span><br><span class="line">                    context.<span class="title function_">report</span>(&#123;</span><br><span class="line">                        node,</span><br><span class="line">                        <span class="attr">message</span>: <span class="string">&#x27;magic string was not desirable&#x27;</span>,</span><br><span class="line">                        <span class="title function_">fix</span>(<span class="params">fixer</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> fixer.<span class="title function_">insertTextBefore</span>(node.<span class="property">body</span>[<span class="number">0</span>],</span><br><span class="line">                                <span class="title class_">Object</span>.<span class="title function_">entries</span>(enums)</span><br><span class="line">                                    .<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> <span class="string">`const enum_<span class="subst">$&#123;k&#125;</span> = &#123; <span class="subst">$&#123;[...v].map(type =&gt; <span class="string">`type_<span class="subst">$&#123;type&#125;</span>: &#x27;type_<span class="subst">$&#123;type&#125;</span>&#x27;`</span>).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span> &#125;</span></span><br><span class="line"><span class="string">                                    `</span>)</span><br><span class="line">                                    .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单解释:</p><ul><li>寻找”变量 &#x3D;&#x3D;&#x3D; 字面量”的情况, 并报错.</li><li>建立一个上下文变量, 保存各个不符合rule的”变量”的名字, 并尝试把”字面量”的值直接改成设定的值.</li><li>在遍历完整个ast后, 如果上下文变量有内容, 就在程序头部插入刚才替换掉”字面量”的设定的值的定义.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite-plugin-inspect工作流程</title>
      <link href="/2022/08/17/vite-plugin-inspect/"/>
      <url>/2022/08/17/vite-plugin-inspect/</url>
      
        <content type="html"><![CDATA[<p>在vite的plugin开发中或看使用的plugin行为时, vite-plugin-inspect非常有用, 于是简单看一下这个plugin的工作流程.</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在vite配置中引入这个插件, 启动dev后命令行会多打印一个url, 点开可以看到一个页面.</p><p>页面的内容是一个当前应用所有module的列表, 点击列表会弹出一个新列表, 内容是当前module被哪些plugin处理过, 点击plugin还能看到这个plugin对module处理前后的diff.</p><p>所以明显地, 这个插件分为2个部分: 插件部分, 网页部分.</p><p>对应的代码在<code>src/node</code>和<code>src/client</code>下, node部分是个普通ts, client部分是个普通vue网页.</p><p>所以node部分用unbuild打包, client部分用vite打包.</p><h2 id="主要工作流程"><a href="#主要工作流程" class="headerlink" title="主要工作流程"></a>主要工作流程</h2><ol><li>使用者在vite配置引入插件. 插件只使用了2个hook: <code>configResolved</code>, <code>configureServer</code>.</li><li><code>configResolved</code>这个hook可以拿到应用最终的vite配置.</li><li><code>configResolved</code>阶段: 建立一个公共变量<code>config</code>来保存获取到的vite配置, 便于需要时读取.</li><li><code>configResolved</code>阶段: 建立一个公共变量<code>transformMap</code>. 遍历vite配置中的plugin, 并把每个plugin的信息(plugin名字, 输出结果)存到变量中.</li></ol><p>到了这个阶段, 这个插件所需要的数据都已经准备好了.</p><p>并且从这个插件的公共变量闭包看, 所有module运行的是同一个plugin实例, 这样所有module信息才会被收集到一起.</p><ol start="5"><li><code>configureServer</code>这个hook在建立server的时候被调用, 有一个入参是vite-server.</li><li><code>configureServer</code>阶段: 让vite-server增加<code>__inspect</code>路由, 指向打好包的client网页. 这个就是我们使用的时候看到的网页.</li><li><code>configureServer</code>阶段: 通过vite-server暴露的ws实例, 提供接口给client调用获取数据. 数据内容都来自于在上个阶段收集的<code>transformMap</code>.</li><li><code>configureServer</code>阶段: 把client网页的url打印到控制台提示用户使用.</li></ol><p>到这个阶段, 插件做的事已经完成了. 与普通网页不同, client端是通过ws获取数据的.</p><p>看到这里, 这个插件的工作流程已经很清晰了, 下面再深入看一些细节.(optional read)</p><h2 id="rpc细节"><a href="#rpc细节" class="headerlink" title="rpc细节"></a>rpc细节</h2><p>client端的rpc是通过ws的, 那么我们就要明确ws的server和client分别是哪里建立的.</p><p>代码里<code>createRPCServer</code>传入的参数是<code>configureServer</code>hook暴露出来的vite-server里的ws实例.</p><p><code>createRPCClient</code>传入的是<code>vite-hot-client</code>.</p><p>我对vite的原理一点不了解, 所以直接去查看了浏览器请求. 在dev页面和inspect页面都请求了<code>/@vite/client</code>, 点开这个请求看返回值, 可以明确ws的客户端是在这里建立的.</p><p>总结: <strong>这个插件的rpc通信是直接使用了vite的ws连接.</strong> vite可能拿他来做hmr和一些其他事的, 也暴露出来让plugin开发者做更多的事情.</p><p>client端调用rpc的方法是直接调用<code>createBirpc</code>的返回值, 返回值是一个proxy对象, 被调用方法以后会去和ws的server端通信, server端就执行对应的方法然后通过ws推给他.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
            <tag> vite-plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入查看webpack打包结果中的模块</title>
      <link href="/2022/07/28/module-of-webpack-output-in-depth/"/>
      <url>/2022/07/28/module-of-webpack-output-in-depth/</url>
      
        <content type="html"><![CDATA[<p><strong>经过webpack打包后, 项目中引入的依赖是存在在哪里, 不同chunk的依赖是如何加载的?</strong></p><p>本文通过查看打包结果, 了解了下webpack中的模块化, externals, code splitting, module federation的细节.</p><span id="more"></span><h2 id="项目被老板要求换方案"><a href="#项目被老板要求换方案" class="headerlink" title="项目被老板要求换方案"></a>项目被老板要求换方案</h2><p>居家办公期间接到了个比较不常见的需求: 一个嵌入各个系统的widget, 这个页面的一个部分希望得到”云更新”, 于是我把页面分成了2部分, 使用module federation来连接.</p><p>而在完成的时候, 发现使用部署在公司环境上的远程模块时, react hooks报错了, 只好用cc来重新fc.</p><p>经过排查, 发现即使module federation配置了共享模块, 远程模块依然把react, react-dom打入了包中.</p><p>领导提出了2个疑问: </p><pre><code>1. module fedration为什么打了2份react.(主子应用都打包了一份)1. 2份react在用react hooks的时候报错的原理是什么.</code></pre><p>我一个都没答上. 于是花了额外的功夫把项目重构成了基于iframe的远程模块.</p><p>所以打算解决这2个问题, 本文是问题之一: <strong>webpack打包结果中, 我们引用的依赖具体在哪里?</strong></p><p>我用webpack(大版本是5)打包了写demo, 查看了打包结果. 接下来几个章节由最简单打包结果开始介绍.</p><h2 id="webpack打包结果结构"><a href="#webpack打包结果结构" class="headerlink" title="webpack打包结果结构"></a>webpack打包结果结构</h2><p>这里得简单说下webpack配置. 我们需要在配置里设置<code>mode: &#39;development&#39;</code>以避免代码被压缩.</p><p>而设置了<code>mode</code>实际是对一系列配置的preset. 还要设置一下<code>devtool: false</code>来取消每个module的<code>eval</code>的调用, <code>eval</code>调用是为了调试的时候可以让每个module在单独的source里, 而对于我们直接查看代码并不友好. (这段指导是打包结果中提示的)</p><p>接下来看下打包结果, 是个iife, 所以第一个结论: <strong>webpack的执行和依赖的引入都是在closure里进行的.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">__webpack_require__</span> (moduleId) &#123;&#125;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;&#125;)()</span><br><span class="line">  <span class="keyword">var</span> __webpack_exports__ = <span class="title function_">__webpack_require__</span>(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这五个部分的作用分别是:</p><ul><li><code>__webpack_modules__</code>: 这里是所有代码存在的地方, 键是模块名字, 值是一个函数, 函数被注入了一些变量和方法, 函数体就是具体模块的代码, 和模块引入相关的import, require都会被替换成注入的方法, 以此来连接各个模块.</li><li><code>__webpack_module_cache__</code>: 字面意思.</li><li><code>__webpack_require__</code>: 尝试读取cache, 如果没有就新增, 然后去执行<code>__webpack_modules__</code>里对应的模块.</li><li>其他的若干iife: 给<code>__webpack_require__</code>增加一些方法. 这些方法会根据需求打到包里, 不同场景含有的方法是不同的.</li><li>__webpack_require__(“.&#x2F;src&#x2F;index.js”): 入口, 执行的开始.</li></ul><p>所以第二个结论也有了: <strong>所有模块都存在__webpack_module_cache__里, 第一次会从__webpack_modules__中找到模块定义并执行获取模块</strong>.</p><h2 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h2><p>在默认情况下, 设置了externals后, <code>__webpack_modules__</code>里被external的内容会被直接引入(window), 如果设置了模式, 也只是包装简单的模块格式. 类似于: <code>module.exports = React</code>, <code>module.exports = require(&#39;React&#39;)</code>等. 如果在全局没有React变量, 或者是没有require方法, 就会报错, webpack没有对他做任何其他动作.</p><p>但主流的case是: 含有externals的包被其他的包引入, 而直接引用宿主包里的依赖.</p><p>在这个case里, 如果不设置打包输出format是umd的话, 宿主webpack不会做任何处理, 继而会包上面所说的错. 所以我们得把包输出format改为umd.</p><p>那么在umd输出的情况下, webpack做的事是:</p><ul><li>在被依赖的模块输出中: iife外面被包了一层iife, 注入了<code>factory</code>, 在被external的模块就会引入factory, 类似: <code>module.exports = __WEBPACK_EXTERNAL_MODULE_react</code>. 而factory的实现去尝试引入了amd, cjs等format.</li><li>在宿主的<code>__webpack_modules__</code>中, factory实现的部分会被直接替换成<code>__webpack_require__(&quot;node_modules/react&quot;)</code>, 这样子模块就通过依赖注入使用了宿主应用的模块.</li></ul><h2 id="chunk加载方式"><a href="#chunk加载方式" class="headerlink" title="chunk加载方式"></a>chunk加载方式</h2><p>在加载一些当前文件不存在模块时, webpack在调用<code>__webpack_require__</code>前还会调用<code>__webpack_require__.e</code>方法.</p><p>code splitting, module federation都是通过<code>__webpack_require__.e</code>来加载的. 接下来就来了解一下这个方法的主要流程.</p><h3 id="ensure-chunk"><a href="#ensure-chunk" class="headerlink" title="ensure chunk"></a>ensure chunk</h3><p><code>__webpack_require__.e</code>应该是ensure chunk的意思. 这个方法是个入口, 因为chunk的类型是多种的, 但目的是一致的: <strong>调用<code>__webpack_require__.e</code>后, 保证__webpack_modules__中被新增了需要加载的模块</strong>.</p><p><code>__webpack_require__.e</code>的做法是: 写了几个不同类型的chunk加载方法, 并依次调用, 下面来介绍一下这几个方法.</p><h3 id="ensure-function-jsonp"><a href="#ensure-function-jsonp" class="headerlink" title="ensure function: jsonp"></a>ensure function: jsonp</h3><p><code>__webpack_require__.f.j</code>这个方法调用了<code>__webpack_require__.l</code>加载chunk.</p><p> <code>__webpack_require__.l</code>的行为也很简单: 创建一个src为url的script, 贴到dom上, 浏览器就加载了一段js.</p><p>接下来我们来看看被加载的chunk做了什么:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self[<span class="string">&#x27;webpackChunk&#x27;</span>].<span class="title function_">push</span>([<span class="string">&quot;chunk_name_js&quot;</span>], &#123;<span class="string">&quot;chunk&quot;</span>: <span class="function">(<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>self[&#39;webpackChunk&#39;]</code>这个变量的push方法已经在初始化的时候被改写过了, 在调用push放的时候会执行<code>webpackJsonpCallback</code>.</p><p><code>webpackJsonpCallback</code>拿到chunk的模块信息, 遍历并逐个加入自己closure内的<code>__webpack_modules__</code>.</p><p>至此, chunk文件的内容已经和入口文件合二为一了. 只需要正常<code>__webpack_require__</code>就可以了.</p><h3 id="ensure-function-remote"><a href="#ensure-function-remote" class="headerlink" title="ensure function: remote"></a>ensure function: remote</h3><p>module federation的远程模块并不会像code splitting一样与主入口共享一个closure, 而是拥有自己的closure, 自己的<code>__webpack_require_</code>, 模块, 缓存, 方法等.</p><p>所以就产生了包共享问题, 这使得mf的加载比code splitting加载复杂一些, 这里先说<code>__webpack_require__.f.remotes</code>.</p><p><code>__webpack_require__.f.remotes</code>会先根据配置找到远程模块, 并和jsonp一样使用<code>__webpack_require__.l</code>加载他.</p><p>jsonp通过<code>self[&#39;webpackChunk&#39;]</code>这个全局变量与主应用进行交互,</p><p>而remote通过<code>remoteApp</code>与主应用进行交互. (remoteApp这个名字是在webpackconf里配置的)</p><p>加载远程模块后, 我们得到的内容是: 一个含有<code>init</code>方法和<code>get</code>方法的对象.</p><ul><li>init: 与主模块共享scope.</li><li>get: 获取模块入口. (可能会先ensure一些chunk, 所以需要写这个get方法)</li></ul><p><code>__webpack_require__.f.remotes</code>获取到远程模块后, 会调用远程模块的init方法和get方法, 最后把get方法的调动结果放到<code>__webpack_modules__</code>里, 这样主应用已经可以require到他了!</p><p>(其实在此之前, init方法已经被调用过了, 所以这里会走缓存, 下面的部分会说到什么时候第一次调用init)</p><h3 id="ensure-function-consume"><a href="#ensure-function-consume" class="headerlink" title="ensure function: consume"></a>ensure function: consume</h3><p>所有被mf定义共享的模块都会走到这个ensure流程里. (我跑的例子是mf配置share module, singleton的)</p><p><code>__webpack_require__.f.consumes</code>会建立一个主应用&#x2F;远程模块的共享scope: <code>__webpack_require__.S</code>. (也有可能是share的缩写, 暂定他为scope)</p><p>然后主要做2件事:</p><ol><li>初始化&#x2F;注册&#x2F;共享.</li><li>把<code>__webpack_modules__</code>对应的模块指向共享模块. (通过<code>loadSingletonVersionCheckFallback</code>)</li></ol><p>所有的<code>loadSingletonVersionCheckFallback</code>的方法都会先调用初始化方法: <code>__webpack_require__.I</code>.(initialize sharing). </p><p>并且主&#x2F;子应用都会调用<strong>各自</strong>的<code>__webpack_require__.I</code>, 调用的流程为:</p><ol><li>主应用调用<code>register</code>, 把<code>__webpack_require__.S</code>的<code>react</code>指向到自己closure里的react模块. (react是举例模块)</li><li>主应用调用<code>initExternal</code>. 读取远程模块, 并调用远程模块的<code>init</code>方法, 传入<code>__webpack_require__.S</code>.</li><li>子应用调用<code>init</code>方法, 把主应用的<code>__webpack_require__.S</code>设置为自己的<code>__webpack_require__.S</code>, 实现共享.</li><li>子应用调用<code>register</code>, 把<code>__webpack_require__.S</code>的react指向自己closure里的react模块.</li></ol><p>主应用的<code>__webpack_require__.S</code>也会随着子应用的注册而变化, 所以主应用的react都会调用子应用打包的react了.</p><p>第二步很简单, 实例中就是使主&#x2F;子应用在引入react的时候都去读共享scope里的实例.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对上面分析和开始的问题做一些总结:</p><ul><li>webpack的模块都在iife里, 每个模块也拥有自己的closure.</li><li>被依赖的externals包需要打umd包, 在加载的时候通过di获取主应用的模块.</li><li>code splitting通过<code>window.webpackChunkName</code>共享, mf通过<code>window.remoteAppName</code>共享.</li><li>code splitting和主应用共享closure, mf的远程模块有独立closure和一切方法变量.</li><li>mf在共享模式下, 主&#x2F;子应用打包结果都有被共享的模块, 但所有的引入都被指向子应用的模块.</li></ul><h2 id="聊聊看完后的感受"><a href="#聊聊看完后的感受" class="headerlink" title="聊聊看完后的感受"></a>聊聊看完后的感受</h2><p>虽然东西不复杂, 但断断续续看了一个月才看完, 关于调试方面走了些弯路. 最后的部分想聊一下”调试的方法”和module federation.</p><h3 id="如何调试代码-x2F-功能"><a href="#如何调试代码-x2F-功能" class="headerlink" title="如何调试代码&#x2F;功能"></a>如何调试代码&#x2F;功能</h3><p>在我看来有2个选择: 看代码和浏览器debug. 一开始选择了看代码, 折腾好久才决定用浏览器debug, 他们的优劣是:</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>看代码</td><td>容易掌握所有函数和代码总体结构</td><td>对执行时变量难以把握</td></tr><tr><td>浏览器debug</td><td>执行栈和作用域都很明确</td><td>需要编写demo, 调试时可能进入不想查看的方法调用中或重复的循环</td></tr></tbody></table><p>所以如果只选择一种, 情况是:</p><ul><li>只看代码不调试: 对执行时状态只靠猜, 复杂的情况无法应对.</li><li>直接调试: 顺着代码执行, 对全局情况没有概念, 跑完以后还是一头雾水.</li></ul><p>所以我最后的经验是: 先看代码, 再写demo执行. </p><p>再附加2个建议: </p><ul><li>看代码的方式, 最好是带着问题, 从一个变量&#x2F;方法入手, 观察这个变量的改变. (因为很复杂的东西并没必要细节很透彻)</li><li>如果实在有困难, 不放弃, 多看几遍, 就会有感觉的.</li></ul><h3 id="module-federation的期待"><a href="#module-federation的期待" class="headerlink" title="module federation的期待"></a>module federation的期待</h3><p>这个项目确实是第一次接触module federation. 我之前给公司写了vite的脚手架, 而这次用了webpack5的功能, 本来都觉得vite没用了.</p><p>经过一些搜索, 原来module federation的作者在各个框架(angular, react, vue, svelete)和各个工具(webpack, vite, rollup)都写了例子. 甚至还有跨构建工具的例子.</p><p>所以我理解module federation只是一种方案或者协议. 不是新技术, 只是新应用.</p><p>而mf应该是一个底层方案, 基于mf可以建设公司的免更新组件库.</p><p>mfsu已经出来一年多了, 也是对mf的一个应用, 我觉得很奇妙.</p><p>关于mf的应用, 可能以后还会深入了解别人, 或者自己思考一些使用流程.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于房子, 经济, 劳动, 生活偶然的思考</title>
      <link href="/2022/07/05/ideas-about-house-eco-labor-life-and-resolution/"/>
      <url>/2022/07/05/ideas-about-house-eco-labor-life-and-resolution/</url>
      
        <content type="html"><![CDATA[<p>每年的7月和8月的天空都特别漂亮, 在看天的时候看到了好多房子, 房子虽然这么多, 但每一套可能都是几个人一辈子的劳动换取的.<br>上海又刚经历了疫情, 听外国亲戚说外国多好. 想了下自己的生活, 有了写偶然的思考.</p><span id="more"></span><h2 id="关于”国外的生活好”"><a href="#关于”国外的生活好”" class="headerlink" title="关于”国外的生活好”"></a>关于”国外的生活好”</h2><p>关于国外的好, 我听说的分为2个方面. 一是国外福利好, 看病不要钱, 动不动发钱等. 二是国外工作不加班, 工资又高.<br>总结就是: <strong>付出更少的劳动, 获得更多的财富.</strong> 那国外可以这么做的原因是什么, 我们尝试简单分析.</p><p>下面我想了一个简单的贯穿全文的例子. 说故事前先提示一个基础知识: 财富和钱的区别. (这里不展开)</p><h3 id="一个简单的模型"><a href="#一个简单的模型" class="headerlink" title="一个简单的模型"></a>一个简单的模型</h3><p>世界上只有三种人: 生产者, 不工作或无效生产的人, 进行研究来进化生产工具的人.</p><ul><li>生产者: 所有我们生活中可能付钱给他的人. 他们提供了所有人的基础需求和心理(娱乐)需求等.</li><li>不工作或无效生产的人: 没有对他人产生价值的人, 或者是无效工作的人(有时候他们还会被分配到财富).</li><li>进行研究来进化生产工具的人: 他们不直接产生财富, 但成功地改进了生产工具, 可以使生产者效率提升. (短期对于研究者的拥有人, 长期对于全社会)</li></ul><p>为了理解简单, 我把3种人简化为: 做包子的人, 闲人, 发明家.</p><p>所以正常世界的流程是: </p><ul><li>三种人都必须吃包子才能生存, 做包子的人养活了所有人.</li><li>发明家如果成功发明了新机器, 可以提高做包子的效率, 能使做包子的人同样劳动可以养活更多人.</li><li>闲人是系统中各种地方产生的, 现实生活中的例子可能是: 没有教育好而啃老的青年人, 伪发明家: 发现不用做包子也能吃包子很爽就失去了梦想.</li></ul><h3 id="可能的答案"><a href="#可能的答案" class="headerlink" title="可能的答案"></a>可能的答案</h3><p>回答问题, 为什么一个人, 他的劳动力去了国外应当是差不多, 甚至减少的(因为语言), 那么他为什么付出同样的劳动可以获得更多的财富呢?<br>我想有几个可能:</p><ul><li>各个国家对不同阶级的财富分配不同, 可能国外的政策把更多的财富分配给了底层人民来维持社会稳定, 或者是把更多的财富分配给了”发明家”.</li><li>外国的科技比较高, 总体财富产生效率高, 所以每个人分配到的财富多.</li><li>国外分配给”发明家”的财富少, 所以分配给其他2个角色的财富多了. 这样的情况会导致国家进步比较慢.</li><li>国际的不公平, 比如利用国际地位或者技术, 使别的国家的人民劳动为自己买单.</li><li>国外的”闲人”身份比较少, 所以劳动者和发明者都可以被分配更多的财富.</li></ul><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>发明家如果发明了包子, 那么收益的是所有人, 而不是供应他吃饭的做包子的人.<br>那么为什么做包子的人还愿意供应发明家呢?</p><p>人性是不会这么做的, 所以需要金融游戏, 或者是政策游戏, 来使社会往这个地方发展.</p><h3 id="国家-x2F-政府的目的"><a href="#国家-x2F-政府的目的" class="headerlink" title="国家&#x2F;政府的目的"></a>国家&#x2F;政府的目的</h3><p>所以我认为, 一个好的国家&#x2F;政府, 目的就是: <strong>使劳动者满足所有人生存需求的前提下, 尽可能让研究者提高科技, 而提高劳动者的劳动效率.</strong></p><p>那这个目标可以被拆解为: 1. 尽可能让所有人都工作起来, 减少闲人. 2. 激发高科技工作人员的能力和工作态度.</p><p>这里提一个小想法, 我认为贪官并不那么有害, 不作为或是思路不正确更有害. 一个人能享受的财富有限, 13亿人一人给1块钱都满足一个人享受上限好几次了. 国家管理者满足私欲并不能影响管理国家的效果, 管理国家的效果在于是否让大家都有效劳动.</p><p>让所有人都动起来, 就是货币的作用了. 而很明显, 光有”钱”这个游戏还不够, 得增加一些花活.</p><h2 id="关于房子"><a href="#关于房子" class="headerlink" title="关于房子"></a>关于房子</h2><p>前阵看了个视频, 说只有中国是鸟笼房, 其他大国都是独栋别墅.<br>中国不是没地, 也不是人口密度高, 就是纯政策.</p><p>所以房子就中国人民剩余价值的出口, 而美国可能是股市. (出口这个词我想了挺久)</p><p>用刚才的例子说就是: <strong>做包子的人愿意把自己吃不掉的包子给发明家&#x2F;闲人吃, 来换取房子.</strong><br>如果没有房子这个东西, 那做包子的人也不愿意做给其他人吃了.<br>所以除了房子, 还有许多别的出口, 他们的特点是: 没有他我也能活着, 但我想得到他.</p><p><strong>我们可以切身的思考这个问题:</strong> (假设你不是闲人的身份)如果你对你的生活完全满意, 你就不会继续劳动来赚钱. 我们一定是心里有想买的, 想得到的东西来劳动的.<br>这个东西可以是一台电脑, 一辆豪车, 一幢别墅.<br>当然, 如果你真的很顶级, 这个东西可以是富人排行榜. (这是我认为的富人排行榜的意义, 所以也许人性就是向上的, 才有了今天的人类社会)</p><h2 id="关于利息"><a href="#关于利息" class="headerlink" title="关于利息"></a>关于利息</h2><p>对于利息, 我之前一直有错误的认知. 这个错误的认知起源于: <em>复利是世界第八大奇迹</em>. 这个营销话术, 这根本不是鲁迅说的.</p><p>之所以有人会给你利息, 是因为他可以用你的钱创造更多的钱. (而且比给你的利息多很多, 因为还有中间商的利润和坏账率)</p><p>所以<strong>利息存在的前提是: 有事可做.</strong> 如果所有可以产生价值的事都有人在做了, 那么利息就不会存在了.</p><p>所以利息高低是有社会或科技发展阶段决定的.</p><p>利息的本质是: 你用你存着的货币帮助”让大家劳动起来”而获得的奖励. 这也是货币的基本职能之一: 蓄水池.<br>严格来说, 利息的来源是劳动者的剩余价值, 所以拿利息的人也是资本家了. 只不过风险和收益都小.</p><h2 id="对于个人的现实意义"><a href="#对于个人的现实意义" class="headerlink" title="对于个人的现实意义"></a>对于个人的现实意义</h2><p>上面思考的这些都是宏观的, 那思考了这些以后也想了下对于自己的现实意义:</p><h3 id="个人的发展规律也是如此"><a href="#个人的发展规律也是如此" class="headerlink" title="个人的发展规律也是如此"></a>个人的发展规律也是如此</h3><p>其实”个人”, “公司”, “国家”, “人类” 都是相似的.<br>我们个人需要做的也是: 保证生存, 然后减少内耗, 减少对成长意义少的事, 成长来提高做事效率, 使自己以后更轻松.</p><p>仔细观察会发现, 公司也是如此, 国家也是如此. 也许我们的身体也是如此.</p><h3 id="合理分配资源"><a href="#合理分配资源" class="headerlink" title="合理分配资源"></a>合理分配资源</h3><p>知道了我们所在的系统, 会设计”吸引出我们劳动所得资源”的东西.<br>这些东西的特点是: 不是生存必需品, 但有强烈的欲望想得到他.<br>他们的作用是: 让我们付出”除了维持生存的劳动”以外更多的劳动.</p><p>而得到这些东西确实会给我们造成幸福感. 所以我们必须对付出进行权衡.</p><p>举一些具体的例子. 吸引我们劳动所得的东西可能有: 新潮的手机, 帅气的跑车, 舒适的别墅.<br>我说不清怎么是合理分配, 但能说一些”不合理分配”的例子.</p><ul><li>购买临期食品存钱来购买新潮的手机.</li><li>熬夜学习&#x2F;喝酒讨好客户来获得更多的钱, 来买一辆跑车.</li><li>我的父辈, 持有比较多的存款, 年纪也比较大了, 但不舍得吃比较好的食物, 极端空气不舍得开空调.</li></ul><h3 id="选择更好的方向"><a href="#选择更好的方向" class="headerlink" title="选择更好的方向"></a>选择更好的方向</h3><p>在真正的深度合理思考了国家&#x2F;政府的目的, 结合当前的情况, 我们确实可以给自己选更好的城市, 国家.</p><p>同样地, 在思考了公司的目的, 我们也可以知道公司哪个部门更稳定, 更愿意涨薪, 在有机会的时候往好的部门走.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>haha成长记录</title>
      <link href="/2022/06/12/haha-blog/"/>
      <url>/2022/06/12/haha-blog/</url>
      
        <content type="html"><![CDATA[<p>疫情在家待了2个半月, 至今还没恢复正常上班, 日子的体感也慢慢变快.</p><p>看了haha以前的照片, 已经不太记得请每个节点, 于是现在回忆记录一下, 以便之后的回忆.</p><span id="more"></span><h2 id="出生"><a href="#出生" class="headerlink" title="出生"></a>出生</h2><p>因为妈妈身体的情况, haha在出生的第7天才被接回家. 回家的时候肚脐已经掉了, 所以我们的经历也缺失了这一段.</p><p>回家的时间是天刚黑的晚上, 医生嘱咐3小时吃奶, 把haha接回家很突然, 只是突然想试试能不能接, 医院在没预约的情况下还给接回家了. 在家找了奶瓶和奶粉就匆忙地给haha喂起了奶.</p><p>那个时候抱着haha觉得实在不敢碰他, 肚子也特别大, 感觉内脏都露在外面.</p><p>回家的第二天约到了月嫂, 持续时间一个月. 这个一个月的时间也慢慢得在打疫苗了.</p><p>我们觉得特别有意思的是: haha在梦里会翘起一边嘴角笑, 我们觉得特别有意思.</p><h2 id="第二个月"><a href="#第二个月" class="headerlink" title="第二个月"></a>第二个月</h2><p>月嫂走了后请奶奶来全职帮带haha, 大概也持续了一个月, 在这个月里, haha会在床上边笑边蹬腿, 奶奶说每天能持续45分钟, 特别活跃.</p><p>普通标准第二个月是会抬头的, haha抬得不太好, 他妈妈经常带他练.</p><h2 id="第三个月"><a href="#第三个月" class="headerlink" title="第三个月"></a>第三个月</h2><p>奶奶全职带haha比想象得累, 就没有每天来了.</p><p>在妈妈的坚持努力下, haha能比较好的抬头了. 然后haha的笑也从无意变成了会有意地笑了.</p><h2 id="第四个月"><a href="#第四个月" class="headerlink" title="第四个月"></a>第四个月</h2><p>haha身上的疹子一直比较厉害, 再加上头型是歪的(他妈妈一直很努力也买了道具让他调整睡姿). 我们去了2次新华医院. 在医院很累, 总体来说, 病都不严重, 只是我们比较在意他.</p><h2 id="3-x2F-7"><a href="#3-x2F-7" class="headerlink" title="3&#x2F;7"></a>3&#x2F;7</h2><p>因为haha妈妈快上班, 我们打算住到爷爷奶奶家, 提前几天来适应, 于是来了奶奶家住. haha的生日是10&#x2F;13, 所以这个时间点是5个月不到10天左右.</p><p>五个月不到的时候, haha进行了第一次独自翻身, 这个时候还只会翻一边.</p><p>小孩有一个有意思的特点, 刚学会一个新动作的时候, 会经常反复地去做. 除了翻身其他的所有动作都会, 比如右手敲东西, 用上嘴唇包着下嘴唇, 甚至来回点头.</p><p>在学会翻身之后, haha会尝试爬, 但方式是用手, 在手的推动下, 只能进行倒爬和原地调头.</p><h2 id="3-x2F-22"><a href="#3-x2F-22" class="headerlink" title="3&#x2F;22"></a>3&#x2F;22</h2><p>这天晚上很突然地, 小区因为疫情被封控了. 直到6月1号才开始开小区门.</p><p>当然haha也很意外地, 获得了爸妈的额外3个月陪伴. (6月1号以后还是持续着居家办公).</p><p>在第六个月这个节点, haha学会了很多新的技能.</p><ul><li><p>在戴森吸尘器的吸引下, 学会了爬行. (右手不动, 左手扒地板)</p></li><li><p>开始长牙, 具体位置是下排最中间的2颗. 一直到今天(8个月左右, 6&#x2F;12)也就长了这2颗. </p><p>(7&#x2F;15更新)已经有五颗牙了, 下面2个, 上面2个, 上面右边额外一颗. 上面牙的顺序是: 右1&#x3D;&gt;左1&#x3D;&gt;右2</p></li><li><p>产生自我意识, 一看到镜子里的自己就会笑得很厉害.</p></li><li><p>发出”妈妈”(很标准)的声音. 但几天后一直到今天也没什么发出来过.</p></li></ul><p>当然也有了一个比较烦人的行为: 用嘴来认识东西. 这个行为持续至今, 我们的策略也只是”实在太脏就拿开”, 一是开发一下haha免疫力和肠道菌群, 另一方面怕对心理潜意识有不良影响.</p><h2 id="至今"><a href="#至今" class="headerlink" title="至今"></a>至今</h2><p>从6个月到现在(8个月). haha逐渐学会了坐(但不明显), 7个月左右开始.</p><p>为什么坐不明显, 因为他看到人就喜欢爬过去.</p><p>而到7个月半, 他看到东西逐渐喜欢扶着东西跪起来.</p><p>然后直到今天. 8个月, 他爬得很少了, 而看到东西就会尝试扶着东西站起来, 需要人扶才能站, 而且会发抖, 摔了几次, 摔下来就哭, 大人们管得也挺累的, 毕竟haha只要不睡觉就在折腾.</p><p>除了扶站, 最近开始他还话特别多, 什么话? 婴语. 虽然语言不同, 但能感觉到他在尝试与我们交流.</p><p>我们没有你聪明, 所以请你学习我们的普通话(或者是别的什么话)吧. </p><p>(7&#x2F;29更新)现在9个半月, 熟练爬&#x2F;坐&#x2F;扶站, 会叫爸爸妈妈啊呀, 并感觉大多数时候能叫对人.</p><h2 id="因为haha而学到的"><a href="#因为haha而学到的" class="headerlink" title="因为haha而学到的"></a>因为haha而学到的</h2><p>突然想总结下因为haha而学到的一些东西.</p><h3 id="haha的渺小-原来我也那么渺小"><a href="#haha的渺小-原来我也那么渺小" class="headerlink" title="haha的渺小, 原来我也那么渺小"></a>haha的渺小, 原来我也那么渺小</h3><p>这么小个东西竟然自己活着, 也有着我们完全不能理解的复杂系统.</p><p>再看到haha生病, 为什么会生病, 很简单: 环境和遗传.</p><p>于是我深刻了解到了<strong>这个小东西已经被确定了大部分命运, 他的智力, 健康, 外貌, 体型, 很大程度上被确定了.</strong></p><p>再反思自己, 不也一样吗. 人都有自我主义, 但其实你只是被决定了很多的一个…..(生物?) 罢了.</p><h2 id="爱"><a href="#爱" class="headerlink" title="爱"></a>爱</h2><p>说实话, haha妈妈怀孕的时候, 我一直认为: 小孩学习啥我都不担心, 只担心小孩是个畸形, 又生了出来, 是最麻烦的.</p><p>与haha相处的几个月, 我完全改变了想法.</p><p>记得之前在b站看到的一个瞎妈妈做鱼给智障孩子吃(孩子和我差不多大). emmm, 当时的想法不好说. 但我现在想到会感动.</p><p>我现在的感觉是: haha是一个人, 真实的人, 即使他是智障什么的, 我也很喜欢他.</p><p>我形容不清这个感觉, 但能确定这是其他东西(钱什么的)不能代替的东西.</p><p>所以暂时称这个感觉为爱. 而且不光是私人的, 可能是对生命的, 人类的. 是写在我身体里的让人愉悦的感情, 只是现在被触发了.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haha </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把html片段编译成选择器嵌套结构</title>
      <link href="/2022/05/04/compile-html-piece-to-sass-structure/"/>
      <url>/2022/05/04/compile-html-piece-to-sass-structure/</url>
      
        <content type="html"><![CDATA[<p>之前写了个<a href="https://github.com/cwj0417/vscode-get-sass-structure-from-html">vscode插件</a>, 功能是选取一段html片段, 产生对应的css嵌套结构. (描述很有问题, 这2年里我也一直没想明白应该怎么说)<br>那次写完后写了个<a href="/2020/09/30/build-a-vscode-extension/">总结</a>, 留了几个todo, 现在回头来补一部分.</p><span id="more"></span><h2 id="要解决哪些问题"><a href="#要解决哪些问题" class="headerlink" title="要解决哪些问题"></a>要解决哪些问题</h2><p>因为上一版的做法是: 在消费html片段时分析tag, 直接新建了个<code>ret</code>变量, 在分析的时候直接去拼接字符串了.<br>上次的博客记录了一些问题:</p><ol><li>对非法或不完整的html片段没有校验, 所以输出可能也是不完整的.</li><li>同级别有重复的选择器, 输出的时候没有处理.</li><li>输出的内容没有格式化.</li></ol><p>这些问题只要通过转成ast就都可以解决, 2年前的总结也提到了, 那么现在来简单走一遍ast流程.</p><p>因为是场景性的问题, 所以是正常编译流程的超级简化版, 因为输出和输入结构类似, 甚至少了转换ast的步骤.</p><p>下面开始, 所有代码都在文章开头的仓库链接中, 文章中不贴代码了.</p><h2 id="分析html片段"><a href="#分析html片段" class="headerlink" title="分析html片段"></a>分析html片段</h2><p>分析html片段的过程是个有限状态自动机.<br>我们场景需要的状态很少: 标签开始, 标签结束, 剩下的状态都作为text处理就可以.</p><p>从html片段的第一个字符开始消费, 判断状态的类型, 并用正则取出对应的内容, 记录内容和类型, 并将html片段切割掉(消费动作).</p><h2 id="构建ast"><a href="#构建ast" class="headerlink" title="构建ast"></a>构建ast</h2><p>分析完html片段, 我们会得到一个tokenizer的数组, 元素内容是token类型(如标签开始&#x2F;标签结束)和元素内容.<br>(虽然代码中我把这个步骤和构建ast合起来了, 并不重要, 想象已经获得一个tokenizer数组就可以了)</p><p>构建ast需要2步: 设计ast, 遍历tokenizer数组, 根据类型和内容生成ast.</p><p>ast的设计很简单, 属性有tag, attrs, children.</p><p>构建ast我们需要用到一个栈, 在标签开始的时候把当前元素推入栈, 后面的元素就可以挂在栈头元素的children上, 在关闭标签的时候让栈弹出一个就行.</p><p>这样, 如果遍历完毕, 栈不为空, 就可以知道html片段不完整.<br>另外, 在栈弹出的时候, 判断弹出元素的tag是否等于关闭标签的tag也可以判断非法html片段.</p><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>构建完ast, 其实就可以利用我们熟悉的js对ast进行任何处理了, 而能解决多少问题或做多少优化, 就看个人算法能力了.</p><p>而在transform这步我们要先做的是设计一个函数调用结构, 来方便后续添加功能.</p><p>这里想参考babel, 但ast简单所以没这么多生命周期.<br>就创建一个context传给插件, 让插件可以获取一些状态, 并在遍历ast的合适的时间更新这些状态.</p><h2 id="codegen"><a href="#codegen" class="headerlink" title="codegen"></a>codegen</h2><p>code generate其实是字符串拼接流程.<br>有了层级, 代码就可以方便的做缩进了. 这里也维护了个context来让代码调用更舒服, 当然我们的场景只有一种nodetype, 可能过度设计了, 具体代码看文章开头链接.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件简单原理</title>
      <link href="/2022/04/30/dive-into-vue-component/"/>
      <url>/2022/04/30/dive-into-vue-component/</url>
      
        <content type="html"><![CDATA[<p>简单记录下vue组件的大致思路</p><span id="more"></span><h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><p>组件2大功能, 区分代码块和复用.<br>从实现上来说是没区别的, 就像是一大段代码要抽象方法一样.<br>把一段代码抽象一些方法, 和把一个vnode抽象一些组件. 这2件事感觉是一样的.</p><h2 id="组件在vue里的形式"><a href="#组件在vue里的形式" class="headerlink" title="组件在vue里的形式"></a>组件在vue里的形式</h2><p>vue的组件的形式是一个对象, 对象会返回一段vnode.<br>所以renderer在判断vnode的type是对象的时候, 就会尝试调用mountComponent和patchComponent.<br>以下是mountComponent的内容:</p><p>在组件的编写中, 需要的获取this, 并可以获取state, props, slot, emit等信息.<br>另外在renderer的时候也需要记录上次组件的vnode, 或者一些拦截.<br>所以在render组件的时候会新建一个instance.<br>然后在instance里去获取并用响应式包裹state&#x2F;props, 给合适的参数来执行render函数&#x2F;setup函数, 最后获取到组件实例的vnode内容.</p><h2 id="渲染更新流程"><a href="#渲染更新流程" class="headerlink" title="渲染更新流程"></a>渲染更新流程</h2><p>在mountComponent的时候会新建一个render-effect, 在这里执行render函数&#x2F;setup函数, 进行mount或patch.<br>所以整个vue的应用是由组件维度形成的嵌套render-efeect, 由于响应式系统已经设计成符合预期的嵌套行为, 所以子effect是不会触发父effect的.</p><p>另外这个render-effect是要作为更新用的, 所以加了一个防止重复更新的scheduler, 书里只写了个很简单的.<br>scheduler把所有更新操作改成微任务, 并放入一个set的进行去重, 并加一个变量isFlushing来防止重复刷新.</p><p>那么父组件更新是如何影响子组件的呢?<br>父组件的diff走到类型为对象, 会进入patchComponent.<br>patchComponent会对比新老props的每个元素, 如果有变化, 就直接mutate老props.<br>老的props在mountComponent的时候已经被套上了shallowReadOnly的响应式, 所以直接mutate老props, 就能触发mountComponent时候注册的render-effect了.</p><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>option api的组件生命周期, 只要在各个合适的地方调用就行了.<br>composition api的生命周期, 用了一个全局变量来记录当前实例(这个模式和effect的做法很像).<br>再在生命周期函数里去设置当前实例的某个生命周期就行了.</p><h2 id="emit与slot"><a href="#emit与slot" class="headerlink" title="emit与slot"></a>emit与slot</h2><p>这2个功能没什么让人感觉特别厉害的, 就顺便提一下. (另外有一章说异步组件和函数组件的, 也没啥好说的)<br>emit就是写一个方法暴露给组件声明参数, 调用的时候会去找父组件的props有没有对应的注册, 有就执行.<br>slot其实是编译器一起配合的, 使用的时候直接调用对应的数据结构就可以了.</p><h2 id="built-in组件"><a href="#built-in组件" class="headerlink" title="built-in组件"></a>built-in组件</h2><p>字面意思可以看出, 内置组件就是个组件.<br>所以(根据上文)就是个对象, 然后有个setup函数.<br>内置组件在patch的时候也会因为类型而走到mountComponent&#x2F;patchComponent.</p><p>但我们写不出内置组件, 因为vue在其他对应的地方配合内置组件, 修改了一些行为, 暴露了一些方法.</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>keep-alive的组件会有个字段<code>__isKeepAlive</code>让其他地方识别他.<br>在mount和unmount的时候, 判断到是keep-alive组件, 就会调用组件的active和deactive方法, 而不是本来的mount和unmount操作.</p><p>所以keep-alive组件要实现active和deactive方法.<br>原理就是创建一个用不挂到dom上的div.<br>在active和deactive的时候, 把div里对应的元素移动到真实dom上, 或者从真实dom上移动到div里.<br>那在active的时候如何寻找被隐藏的dom呢, 用个缓存, node的type作为key. (这个type是个对象, 因为是component)</p><p>用什么缓存? 默认lru, 也可以自己重写, 只要符合一定输入输出.</p><h3 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h3><p>teleport和keep-alive的原理很相似, 在mount和unmount的时候判断了是否是teleport组件, 并拦截了操作.</p><p>teleport在mount的时候把子元素循环mount到目标节点上, unmount的时候循环unmount.<br>更新的时候除了循环更新, 如果是目标节点变了, 还要循环把子节点从老目标移动到新目标.</p><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>transition比较简单, 把自己的子元素定义上transition对象, 里面写着不同生命周期的行为, 并把子元素return出去.</p><p>而在renderer的各个阶段, mount&#x2F;unmount的时候, 判断vnode有没有transition对象, 如果有的话调用就行了.</p><p>在不同的生命周期中, 做的事就是添加&#x2F;删除对应的class.<br>剩下还有个问题, 是transition需要执行时间, 一些class的添加&#x2F;删除和dom移除动作, 必须等到transition执行完再进行.<br>在元素进入时, 使用requestAnimationFrame来移除enter-class从而避免enter-class不被添加.<br>使用监听’transitioned’事件来移除dom, 以保证transition动画执行完毕.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3不经过编译优化的diff</title>
      <link href="/2022/04/25/vue-diff-without-compile-optimization/"/>
      <url>/2022/04/25/vue-diff-without-compile-optimization/</url>
      
        <content type="html"><![CDATA[<p>在看hcy的vue源码解析, 看完了渲染器部分, 简单总结下vue3的diff流程. (作为之后复习用, 并不作为学习.)</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>vue的大致流程是: 把一些数据变成响应式, 在数据变化的时候去更新对应的视图.<br>视图是由vnode产生的, vue会保存一份vnode, 在之后更新时与新产生的vnode对比来尽量找到最小的变化, 并把这变化执行到真实dom上.</p><p>对比的过程大致是这样:</p><ol><li>对比type, type不同就直接unmount老的, mount新的.</li><li>type相同, 对attributes进行修改.</li><li>attributes种类繁多, 要对class, style, 事件做处理.</li><li>diff子节点. 子节点有2个类型, 字符串和数组.</li><li>新老子节点非同一个类型, 就直接unmount老的, 遍历新的并mount.</li><li>新老子节点都是数组, 才是本文的主题: diff.</li></ol><p>因为书还没讲到compiler, 所以compiler做的优化这里还不包括, 可以认为这个diff流程是手写render function产生的vnode的diff.</p><p>另外, 这里考虑的是数组被key的情况, 如果数组没有被key, 不会有diff过程, 只是简单地将公共长度部分做patch, 如果新的数组长, 就mount, 如果旧的数组长, 就unmount.</p><p>下面进入主题: <code>patchKeyedChildren</code></p><h2 id="diff流程"><a href="#diff流程" class="headerlink" title="diff流程"></a>diff流程</h2><p>源码的注释写得非常体贴, 所以我就模仿源码中的注释来写例子.</p><h3 id="去头去尾"><a href="#去头去尾" class="headerlink" title="去头去尾"></a>去头去尾</h3><p>(a b) i j k (c d)<br>(a b) x y z (c d)</p><p>找出头尾可以复用的dom, 只patch他们的attributes, 减少diff范围.</p><p>具体方法:<br>两次遍历. 分别用1跟指针和2跟指针(数组长度可能不同, 去尾的时候需要2跟指针)<br>循环判断指针节点是否可复用.<br>如果可以, patch他们的attributes, 并移动指针.<br>如果不可以复用. 停止指针.<br>最后得到3个指针. 来判断需要进一步diff的内容.</p><h3 id="简单的情况-纯新增或减少"><a href="#简单的情况-纯新增或减少" class="headerlink" title="简单的情况: 纯新增或减少"></a>简单的情况: 纯新增或减少</h3><p>(a b) c<br>(a b)</p><p>或</p><p>(a b)<br>(a b) c</p><p>需要diff的内容有一边是完全没有的情况, 只需要新增或卸载节点就可以了.</p><p>具体方法:<br>判断指针是否重合, 可以判断出是否有一边的数组被完全处理完了.<br>如果新数组的指针还为重合, 循环2个指针中间的索引, 逐个新增.<br>反之逐个卸载.</p><h3 id="新老数组都还有长度"><a href="#新老数组都还有长度" class="headerlink" title="新老数组都还有长度"></a>新老数组都还有长度</h3><p>a b [c d e] f g<br>a b [e d c h] f g</p><p>面对这2个序列, 我们要做的事有3个:</p><ol><li>找出可以复用, 并不需要移动的元素, patch他们的attributes.</li><li>移动可以复用但需要移动的元素, patch他们的attributes.</li><li>新增或卸载节点.</li><li>如果需要移动节点, 则移动节点.</li></ol><p>具体方法:</p><ol><li>遍历新数组, 创建一个新数组的key-value的map<code>keyToNewIndexMap</code>.</li><li>创建一个数组<code>newIndexToOldIndexMap</code>, 长度为新数组的长度, 内容是”新元素在老数组里是第几个”, 初始值为0. 代表”新元素在老数组里不存在”</li><li>遍历老数组, 利用第一步创建的<code>keyToNewIndexMap</code>寻找每个老元素是否有对应的新数组.</li><li>如果老元素在新数组中存在, patch这个元素的attributes, 并更新第二步创建的<code>newIndexToOldIndexMap</code>.</li><li>如果老元素在新数组中不存在, 则卸载当前老元素.</li><li>建立一个变量来计数被patch的数量, 如果新元素已经都被patch, 就卸载当前老元素.(这个算算法优化)</li><li>建立一个变量<code>moved</code>, 初始值为false, 如果每次从<code>keyToNewIndexMap</code>取出的不是递增, 就将<code>moved</code>设为true, 后续根据<code>moved</code>来判断是否移动节点.</li><li>至此, 老元素的卸载已完成, 并且我们获得了每个新元素对应了哪个老元素的信息<code>newIndexToOldIndexMap</code>.</li><li>从<code>newIndexToOldIndexMap</code>里获取一个最长递增子序列. 意义是: 新数组和最长递增子序列重合的部分是不需要移动的. (lss: longest stable subsequence)</li><li>反向遍历新数组. 同时增加一根lss的指针, 一起遍历.</li><li>如果新元素符合lss, 则不动. 并向上移动lss的指针.</li><li>如果新元素在<code>newIndexToOldIndexMap</code>里的索引是0, 则新增元素.</li><li>如果都不是, 则将这个新元素移动到当前的指针位置.</li></ol><h2 id="简单diff和双端diff"><a href="#简单diff和双端diff" class="headerlink" title="简单diff和双端diff"></a>简单diff和双端diff</h2><p>书里还介绍了没key时候的diff, vue2的双端diff, 和(我认为是快速diff核心部分雏形的)简单diff.</p><h3 id="简单diff"><a href="#简单diff" class="headerlink" title="简单diff"></a>简单diff</h3><ol><li>遍历新数组, 寻找每个新元素在老数组中的索引, 并记录这个索引.</li><li>如果下个新元素在老数组中索引比记录的大, 则patch他的attributes.</li><li>当发现索引不是递增的, 代表这个元素需要被移动, 则移动到合适的位置并patch他的attributes.</li><li>如果找不到索引, 则新增一个节点放到合适的位置.</li><li>最后遍历老数组, 把新数组中不存在的老元素卸载掉.</li></ol><h3 id="双端diff"><a href="#双端diff" class="headerlink" title="双端diff"></a>双端diff</h3><ol><li>建立4跟指针: 新老数组的头和尾. 并开始遍历.</li><li>每次遍历, 4个方案对比指针上的元素是否是同一个元素: 新头-老头. 新尾-老尾. 新尾-老头. 新头-老尾.</li><li>如果发现是同一个元素, 就patch他的attrbutes, 并把对应的指针向上&#x2F;向下移动一格.</li><li>如果是”新尾-老头. 新头-老尾.”这2个情况下命中的, 还需要移动元素到合适的位置.</li><li>如果4个方案都找不到相同的元素, 就去老数组里找新元素的索引.</li><li>如果找到, 则把新元素移动到合适的位置, 并patch, 并把旧数组对应的元素置为undefined, 并在循环中判断如果指针对应的元素为undefined, 就移动指针并进入下个循环.</li><li>如果没找到, 就新增一个节点.</li><li>如果遍历到”新头指针&gt;新尾指针”并且”老头指针&lt;&#x3D;老尾指针”的情况, 说明剩下的老元素都要被卸载, 使用老数组的2个指针遍历卸载.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用vite来起公司的react项目</title>
      <link href="/2022/04/10/create-vite-server-in-react-project/"/>
      <url>/2022/04/10/create-vite-server-in-react-project/</url>
      
        <content type="html"><![CDATA[<p> 尝试给公司脚手架新增个用vite起react项目的功能, 分享一下思路和遇到的问题.</p><span id="more"></span><h2 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h2><p>因为是公司项目, 总体代码结构会顺着已有的走, 没有参考性, 所以本文只记录碰到的问题, 并贴一些代码片段, 没有贴出整个仓库.<br>另外, 经过了一段时间的努力, 电脑里的30个左右的项目都可以跑了, 但方法也许并不通用, 并且有许多地方可以优化的.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>现有的dev server用的是webpack, 迁移vite的大方向要先看看他们间的区别.</p><ul><li>webpack用了自己写的一些函数把module graph连接起来, vite作为bundleless工具的根本是基于esm. 于是非esm的module就成了问题, vite目前解决得也不太好, 需要我们进一步操作.</li><li>webpack加载module的时候可以用loader&#x2F;plugin进行一些操作, vite也有插件系统, 所以我们的工作之一就是要让webpack存在的配置迁移到vite上.</li></ul><h2 id="关于vite插件"><a href="#关于vite插件" class="headerlink" title="关于vite插件"></a>关于vite插件</h2><p>在vite插件上我算是踩了一些坑, vite(写作时版本2.9.1)对于plugin文档写得比较粗糙.<br>文档里的意思是<code>vite插件包含rollup插件</code>, 所以文档的hook分为2部分: universal和vite-specific.<br>而事实是: 很多rollup插件是不兼容vite的, vite在dev的时候options只有<code>ssr</code>, 而没有rollup的所有options.<br>所以vite插件的开发办法是: console.log硬调试. 安东尼大佬的<code>vite-plugin-inspect</code>在很多场景(并不是所有)上很有用.</p><h2 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节</h2><p>与webpack的dev-server一样, 先获取一些配置, 入口文件等, 用api起一个dev-server. 报什么错就处理什么的方式来调试这个vite服务.</p><h3 id="rollup兼容插件"><a href="#rollup兼容插件" class="headerlink" title="rollup兼容插件"></a>rollup兼容插件</h3><p>因为公司脚手架已经写了一套对应着webpack配置的rollup配置, 就直接拿来用了. 这些配置我把他们分成2类.</p><ul><li>与vite兼容的插件, 如resolve, alias, image, json, polyfill, babel等.</li><li>在vite环境下要禁用的插件. 我们传个参数就可以解决禁用的问题. 而这些插件又分为2类: 第一类是vite out-of-box的功能, 比如sass&#x2F;less, postcss, ts. 第二类是会报错的不兼容插件, 比如cjs插件用到了<code>isEntry</code>.</li></ul><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><p>vite的index.html需要有script[type&#x3D;module]的引入, 秉持让用户不动的原则, 我们要给index.html插入这段js.<br>幸运的是, vite提供了这个hook, 很方便.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">transformIndexHtml</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [&#123;</span><br><span class="line">        <span class="attr">tag</span>: <span class="string">&#x27;script&#x27;</span>,</span><br><span class="line">        <span class="attr">attrs</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>, <span class="attr">src</span>: <span class="string">&#x27;./&#x27;</span> + <span class="title function_">basename</span>(entry) &#125;,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个包报了<code>global is not defined</code>的错误, 也可以用这个hook来解决. 只要加一个script让global指向window或globalThis.</p><h3 id="multiple-entry"><a href="#multiple-entry" class="headerlink" title="multiple entry"></a>multiple entry</h3><p>webpack的entry如果配置成Array, 那么会依次引入并打到一个bundle里.<br>而vite&#x2F;rollup没有这个功能.<br>我们公司脚手架在项目entry前还引入了antd的css和babel的polyfill, 如果不引入就会失去样式, 或是报async&#x2F;await失去垫片的错误<code>regeneratorxxx is not defined</code>.</p><p>这个问题我选择了transform的时候, 判断是否是入口文件来添上对应的引入.<br>而判断入口文件, 只能靠自己, 而不能靠rollup的isEntry.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">transform</span>(<span class="params">code, id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id.<span class="title function_">endsWith</span>(entry)) &#123;</span><br><span class="line">        <span class="keyword">return</span> entries.<span class="title function_">map</span>(<span class="function"><span class="params">eachentry</span> =&gt;</span> <span class="string">`import &#x27;<span class="subst">$&#123;eachentry&#125;</span>&#x27;;`</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) + code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>代码中的entries是外部传入的配置, 能让这个plugin更灵活, 完整的代码会在后面贴上.</p><h3 id="神策埋点"><a href="#神策埋点" class="headerlink" title="神策埋点"></a>神策埋点</h3><p>也不是说埋点有问题, 我们项目中是用神策压缩后的js放在项目文件里的. 鉴于dev时本来就不需要埋点, 于是我用正则的方式把神策埋点都去掉了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">transform</span>(<span class="params">code, id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id.<span class="title function_">endsWith</span>(entry)) &#123;</span><br><span class="line">        <span class="keyword">return</span> code.<span class="title function_">replace</span>(<span class="regexp">/sensorsdata\.init\([^)]*\);/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/.*sensorsdata.*\n/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="umd-external包"><a href="#umd-external包" class="headerlink" title="umd+external包"></a>umd+external包</h3><p>项目中有个包是rollup打的umd+external包. 我尝试了很多插件, (也许是基础不牢固的原因), 我没能力把umd转esm.</p><p>最后解决方案, degit那个包, 然后修改rollup配置, 获得一个esm包, 直接放脚手架里, 然后替换.</p><p>这里要用到2个新的hook, 因为transform的时候找不到这个import. (可能是node_module里的关系, 具体我不懂)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resolveId</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id.<span class="title function_">includes</span>(<span class="string">&#x27;@hanyk/rc-viewer&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> virtualImport;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">load</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id.<span class="title function_">includes</span>(virtualImport)) &#123;</span><br><span class="line">        <span class="keyword">const</span> code = <span class="title function_">readFileSync</span>(<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;rc-view-esm.js&#x27;</span>)).<span class="title function_">toString</span>()</span><br><span class="line">        <span class="keyword">return</span> &#123; code &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件完整代码"><a href="#插件完整代码" class="headerlink" title="插件完整代码"></a>插件完整代码</h3><p>到这里, 插件解决的问题都齐了, 把完整的插件贴上来记录一下.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inspect = <span class="built_in">require</span>(<span class="string">&#x27;vite-plugin-inspect&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; basename, resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; readFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">replacercviewer</span>(<span class="params"></span>) &#123; <span class="comment">// 因为rc-viewer的打包结果是umd+external. 我想不到怎么umd转esm, 直接把esm包打出来吧. (待优化?)</span></span><br><span class="line">    <span class="keyword">const</span> virtualImport = <span class="string">&#x27;\0rc-viewer&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;replacercviewer&#x27;</span>,</span><br><span class="line">        <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">        <span class="attr">apply</span>: <span class="string">&#x27;serve&#x27;</span>,</span><br><span class="line">        <span class="title function_">resolveId</span>(<span class="params">id</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id.<span class="title function_">includes</span>(<span class="string">&#x27;@hanyk/rc-viewer&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> virtualImport;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">load</span>(<span class="params">id</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id.<span class="title function_">includes</span>(virtualImport)) &#123;</span><br><span class="line">                <span class="keyword">const</span> code = <span class="title function_">readFileSync</span>(<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;rc-view-esm.js&#x27;</span>)).<span class="title function_">toString</span>()</span><br><span class="line">                <span class="keyword">return</span> &#123; code &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">entryappendency</span>(<span class="params">&#123; entries, entry &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;entryappendency&#x27;</span>,</span><br><span class="line">        <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">        <span class="attr">apply</span>: <span class="string">&quot;serve&quot;</span>,</span><br><span class="line">        <span class="title function_">transform</span>(<span class="params">code, id</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id.<span class="title function_">endsWith</span>(entry)) &#123;</span><br><span class="line">                <span class="keyword">return</span> entries.<span class="title function_">map</span>(<span class="function"><span class="params">eachentry</span> =&gt;</span> <span class="string">`import &#x27;<span class="subst">$&#123;eachentry&#125;</span>&#x27;;`</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) + code;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">transformIndexHtml</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [&#123;</span><br><span class="line">                <span class="attr">tag</span>: <span class="string">&#x27;script&#x27;</span>,</span><br><span class="line">                <span class="attr">attrs</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>, <span class="attr">src</span>: <span class="string">&#x27;./&#x27;</span> + <span class="title function_">basename</span>(entry) &#125;,</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="attr">tag</span>: <span class="string">&#x27;script&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: <span class="string">&#x27;global = globalThis&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeSensor</span>(<span class="params">&#123; entry &#125;</span>) &#123; <span class="comment">// todo: 改成修改ast, 粗糙正则必有问题</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;removesensor&#x27;</span>,</span><br><span class="line">        <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">        <span class="attr">apply</span>: <span class="string">&quot;serve&quot;</span>,</span><br><span class="line">        <span class="title function_">transform</span>(<span class="params">code, id</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id.<span class="title function_">endsWith</span>(entry)) &#123;</span><br><span class="line">                <span class="keyword">return</span> code.<span class="title function_">replace</span>(<span class="regexp">/sensorsdata\.init\([^)]*\);/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/.*sensorsdata.*\n/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactProjCompatible</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; entry, multiEntry, dev &#125; = options;</span><br><span class="line">    <span class="keyword">let</span> plugins = [<span class="title function_">entryappendency</span>(&#123; entry, <span class="attr">entries</span>: multiEntry ?? [] &#125;), <span class="title function_">removeSensor</span>(&#123; entry &#125;), <span class="title function_">replacercviewer</span>()]</span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        plugins.<span class="title function_">push</span>(<span class="title function_">inspect</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plugins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = reactProjCompatible</span><br></pre></td></tr></table></figure><p>调用的时候:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [<span class="title function_">reactProjCompatible</span>(&#123;</span><br><span class="line">              <span class="attr">dev</span>: <span class="literal">true</span>,</span><br><span class="line">              entry,</span><br><span class="line">              <span class="attr">multiEntry</span>: [<span class="string">&#x27;@babel/polyfill&#x27;</span>, <span class="string">&#x27;antd/dist/antd.css&#x27;</span>]</span><br><span class="line">          &#125;) <span class="comment">// (当然还有别的很多plugin)</span></span><br></pre></td></tr></table></figure><h3 id="react-virtualized"><a href="#react-virtualized" class="headerlink" title="react-virtualized"></a>react-virtualized</h3><p>这个是react常用的table库, 而这个库有奇怪的引用, 提了issue作者也没回复. 所以我们只能通过hack的方式来处理了.<br>因为这个依赖项属于pre-bundle阶段的代码, 所以插件的hook不能获取到, 等以后提供esbuild插件的hook的时候可以用esbuild插件来处理.<br>方式有2个, 一个是用patch-package, 一个是修改node_modules.<br>还是出于”让用户修改最少”的角度, 我选择修改node_modules. 所以写了个脚本, 在每次起dev-server前把node_modules修改了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> slash = os.<span class="title function_">platform</span>() === <span class="string">&#x27;win32&#x27;</span> ? <span class="string">&#x27;\\&#x27;</span> : <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bogusImportString = <span class="string">`import &#123; bpfrpt_proptype_WindowScroller &#125; from &quot;../WindowScroller.js&quot;;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">removeBogusImportLine</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rvPath = <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;react-virtualized&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">paths</span>: [process.<span class="title function_">cwd</span>()]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> filePath = rvPath.<span class="title function_">replace</span>(<span class="regexp">/([\\\/])commonjs\1index.js/</span>, <span class="string">`<span class="subst">$&#123;slash&#125;</span>es<span class="subst">$&#123;slash&#125;</span>WindowScroller<span class="subst">$&#123;slash&#125;</span>utils<span class="subst">$&#123;slash&#125;</span>onScroll.js`</span>)</span><br><span class="line">        <span class="keyword">const</span> filecontent = fse.<span class="title function_">readFileSync</span>(filePath)</span><br><span class="line">        <span class="keyword">if</span> (filecontent.<span class="title function_">toString</span>().<span class="title function_">includes</span>(bogusImportString)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;removing bogus import&#x27;</span>)</span><br><span class="line">            fse.<span class="title function_">writeFileSync</span>(filePath, filecontent.<span class="title function_">toString</span>().<span class="title function_">replace</span>(bogusImportString, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;react-virtualized not found&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = removeBogusImportLine</span><br></pre></td></tr></table></figure><p>相关issue: </p><ul><li><a href="https://github.com/bvaughn/react-virtualized/issues/1632">https://github.com/bvaughn/react-virtualized/issues/1632</a> : 问题没人管</li><li><a href="https://github.com/vitejs/vite/issues/1652">https://github.com/vitejs/vite/issues/1652</a> : evanyou说只能删, 或者用patch-package(不兼容pnpm)</li><li><a href="https://github.com/vitejs/vite/issues/3124">https://github.com/vitejs/vite/issues/3124</a> : 因为是pre-bundle, vite插件touch不到, 等支持esbuild钩子可以解决. 这个issue暂时还open.</li></ul><h3 id="错误的文件拓展名"><a href="#错误的文件拓展名" class="headerlink" title="错误的文件拓展名"></a>错误的文件拓展名</h3><p>记得在做这个迁移项目前我就看到过一个issue, webpack可以把js也是用jsx的loader, 但vite不行, evan认为这是错误的, 正确做法是把js改成jsx.</p><p>把转换做在vite插件里又难又没有必要, 只需要第一次执行的时候检查所有文件就可以了. 于是我写了段脚本.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; extname, join &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; readdirSync, lstatSync, readFileSync, renameSync, writeFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> excludes = [<span class="string">&#x27;node_modules&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cwd = process.<span class="title function_">cwd</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">walk</span> = (<span class="params">dir, cb</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">readdirSync</span>(dir).<span class="title function_">forEach</span>(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> curDir = <span class="title function_">join</span>(dir, d);</span><br><span class="line">        <span class="keyword">const</span> stat = <span class="title function_">lstatSync</span>(curDir)</span><br><span class="line">        <span class="keyword">if</span> (stat.<span class="title function_">isDirectory</span>() &amp;&amp; !excludes.<span class="title function_">includes</span>(d)) &#123;</span><br><span class="line">            <span class="title function_">walk</span>(curDir, cb)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stat.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">            <span class="title function_">cb</span>(curDir)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUnusedImport</span> = (<span class="params">content</span>) =&gt; &#123; <span class="comment">// todo: 混合使用的case没写: import React, &#123; useState &#125; from &#x27;react&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> defaultImportRegex = <span class="regexp">/import (\w+)\b from/g</span></span><br><span class="line">    <span class="keyword">const</span> multiImportRegex = <span class="regexp">/import \&#123;(.*)\&#125; from/g</span></span><br><span class="line">    <span class="keyword">const</span> defaultImports = [...content.<span class="title function_">matchAll</span>(defaultImportRegex)].<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> i[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">const</span> multiImports = [...content.<span class="title function_">matchAll</span>(multiImportRegex)].<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> i[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)).<span class="title function_">flat</span>().<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">trim</span>())</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        defaultImports,</span><br><span class="line">        multiImports,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isJsx</span> = (<span class="params">content</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/&lt;(\w+)([^&gt;]|\n)+&gt;/</span>.<span class="title function_">test</span>(content) <span class="comment">// todo: 完全不对, 太难写, 感觉正则搞不定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isTs</span> = (<span class="params">content</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/(\bdeclare\b|\binterface\b|import type|function \w+\b\(\w+\b: \w+\b)/</span>.<span class="title function_">test</span>(content) <span class="comment">// todo: 也是很草率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">transform</span> = (<span class="params">file</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fileExt = <span class="title function_">extname</span>(file)</span><br><span class="line">    <span class="keyword">let</span> newExt = fileExt</span><br><span class="line">    <span class="keyword">if</span> (![<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>].<span class="title function_">includes</span>(fileExt)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="title function_">readFileSync</span>(file).<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123; defaultImports, multiImports &#125; = <span class="title function_">getUnusedImport</span>(content)</span><br><span class="line">    <span class="keyword">if</span> (defaultImports.<span class="property">length</span> || multiImports.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> changed = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">isUnused</span> (str) &#123; <span class="comment">// todo: 在注释中的case还没考虑到</span></span><br><span class="line">            <span class="keyword">return</span> content.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`\\b<span class="subst">$&#123;str&#125;</span>\\b`</span>, <span class="string">&#x27;g&#x27;</span>)).<span class="property">length</span> === <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        defaultImports.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isUnused</span>(item)) &#123;</span><br><span class="line">                changed = <span class="literal">true</span></span><br><span class="line">                content = content.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`import <span class="subst">$&#123;item&#125;</span> from .*\n`</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        multiImports.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isUnused</span>(item)) &#123;</span><br><span class="line">                changed = <span class="literal">true</span></span><br><span class="line">                content = content.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`(?&lt;=import.*)\s?<span class="subst">$&#123;item&#125;</span>,?\s?`</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="title function_">writeFileSync</span>(file, content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isJsx</span>(content) &amp;&amp; !fileExt.<span class="title function_">endsWith</span>(<span class="string">&#x27;x&#x27;</span>)) newExt += <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTs</span>(content) &amp;&amp; !fileExt.<span class="title function_">includes</span>(<span class="string">&#x27;t&#x27;</span>)) newExt.<span class="title function_">replace</span>(<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (fileExt !== newExt) <span class="title function_">renameSync</span>(file, file.<span class="title function_">replace</span>(fileExt, newExt))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">transformfile</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">readdirSync</span>(cwd).<span class="title function_">find</span>(<span class="function"><span class="params">dir</span> =&gt;</span> [<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;packages&#x27;</span>].<span class="title function_">includes</span>(dir))) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请在项目下运行&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">walk</span>(cwd, transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = transformfile</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>webpack转vite, 非esm的第三方包会是个问题.</li><li>webpack转vite, 各种特性会是个问题. (就像不同浏览器对同一个约定进行了不同的实现)</li><li>webpack转vite不容易写成共用库, 反而更像是修修补补, 在内部小范围可以快速响应问题的地方使用更合理.</li><li>期待vite后续版本解决这系列问题. (如果vite足够流行, 都用vite起项目, 那这也将会不成为问题, 就像抛弃ie)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue和react的简单比较</title>
      <link href="/2022/02/18/vue-and-react-brief-compare/"/>
      <url>/2022/02/18/vue-and-react-brief-compare/</url>
      
        <content type="html"><![CDATA[<p>因为看了尤老板带着写vue的视频, 之前也看过didact. 那么这次自己试着把<a href="https://github.com/cwj0417/sxdm/tree/main/vue3simplepoc">简单版vue</a>和<a href="https://github.com/cwj0417/sxdm/tree/main/reactsimplepoc">简单版react</a>敲了一下, 来简单总结一下感受.</p><span id="more"></span><h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><p>这2个视频说的都是react&#x2F;vue的最简流程, 所以其实不必要区分哪个版本, 甚至vue的大版本2和3都是这个思路. react暂时只实现了fc, 基于fiber.</p><p>我为了更有手写的感觉, 脱离工具, <strong>没有使用编译器, 所以2个框架都是直接写render function的</strong>.</p><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ol><li>使用一个watch effect来启动应用. (vue的响应系统在之前的文章有详细讲解)</li><li>effect的内容是: 执行<code>render function</code>获得vnode, 将新老vnode进行patch, 保存老vnode.</li><li>第一次执行没有老vnode时, 遍历vnode贴到真实dom上.</li><li>后续执行有新老vnode时, 把新老vnode进行diff, 尽量作出最小的dom操作来更新dom.</li><li>触发后续执行effect的点是render function中响应式数据的更新.</li></ol><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><ol><li>使用一个scheduler来启动应用. 启动后会循环执行至没有wipFiber. (我这里暂用requestIdleCallback无限循环了)</li><li>启动的方式是给wipFiber和一些其他变量赋值. (wip &#x3D; work in progress).</li></ol><p>然后fiber的更新流程开始. 先简单说一下fiber是什么:</p><p>为了不打断用户操作, 希望不整个更新vdom, 一个个节点分开更新, 为遍历方便, 把vdom的树结构变成链表结构. 然后逐个更新, 所以<strong>fiber就是多了链表指针的vnode节点</strong>. 当然实际还多了一些属性, 比如真实dom, 这个在vue上是直接存在vnode里的, 还有fiber逐个更新需要的”更新方式”的字段.</p><p>每一次fiber更新分为2个大步骤:</p><ol><li>循环perform unit of work. 遍历fiber处理链表指针和产生dom.</li><li>commit work. 为了用户看到完整的界面, 在处理完所有fiber后再进行dom操作.</li></ol><p>这里的perform unit of work做的事情为:</p><ol><li>根据type创建出真实dom, 并存在fiber的stateNode字段中.</li><li>为子节点创建fiber, 确定更新类型, 并整理自己和子节点的指针. (reconcile children)</li><li>找到下个待处理的fiber, 等待进入下次循环.</li></ol><p>此时fiber都有了自己的真实dom, commitWork把dom贴到恰当的地方:</p><ol><li>从根fiber遍历, 把dom贴到自己的父级dom上. (不是每个fiber节点都有dom, 有些fiber节点是抽象的, 所以要递归查找父dom)</li><li>递归遍历fiber的siblings和children.</li></ol><h2 id="框架特点思考"><a href="#框架特点思考" class="headerlink" title="框架特点思考"></a>框架特点思考</h2><h3 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h3><p>fiber是react的大重写(据evanyou说写了3年), 我理解是降低性能来砍掉性能天花板, 建立fiber的处理本身是有消耗的, 每次更新还需要给fiber计算effectFlag.</p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>相对于react的fiber, 说到vue就会想到响应式, 我理解是通过降低性能来免去setState的调用. 消耗在2点, 更新时要重新收集依赖, 依赖和effect占用的内存.</p><p>vue2的响应式每个响应的节点都有个闭包存着依赖数据, 用了proxy以后更原生, 性能应该会好些.</p><h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><p>框架最重要的性能就是更新时候的表现. </p><p>经过调试, vue和react的更新节点都是组件.</p><p>react的setState, useState, hmr都调用了<code>scheduleUpdateOnFiber</code>方法, 在三个情况下, 这个方法的第一个参数<code>fiber</code>都接收到了被改动状态组件所在的fiber.</p><p>vue的自动更新是以effect为节点的, 而vue选择的effect粒度是: component. vue的组件数在运行时其实就是多个watch effect的嵌套, 如何做到子effect的更新不触发父effect, 也是响应式做的处理: activeEffect是个栈.</p><p>vue比react性能好的点是: vue只更新当前组件, 不会深入到子组件, 子组件的更新依靠对props的effect, 所以没有合理写scu的react项目会比vue的更新性能差很多.</p><p>另外, 经简单测试, vue的hmr是会更新整个vdom的, 这个暂不深入探索了, 但这对dx还是有影响的, 可能需要一些配置.</p><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><p>vue的编译优化其实是对标react的fiber的. vue在编译时加了静态标记, 和渲染器配合减少patch的复杂度. 要注意的是, 这个编译优化是在sfc的编译做的, render function有没有要看vue的更新, jsx有没有要看jsx插件的更新. 所以vue的主推开发方式还是sfc, 虽然可以用jsx写.</p><p>静态标记有3种:</p><ol><li>纯html会被提取(hoist), 永久复用.</li><li>绑定了props的组件会被记录下改动了什么props. (patchFlag) 这里的二进制写法还很优雅, 并且runtime的renderer使用二进制判断很快.</li><li>block tree. 除了v-if和v-for不影响结构的都会被看作一个block, block里的可能的改变会被打平存着. 有v-if或者v-for就产生新的block, 所以vnode最后形成了一颗block tree.</li></ol><p>为什么react不做? 21年react conf里hux说在做编译时给react自动加useMemo, useCallback的工具. 可能和框架设计理念有关.</p><p>vue为什么不写fiber? 我认为最大的原因还是实现时间, 第二才是fiber带来的性能消耗, vue认为只要足够快就不需要fiber.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理负面情绪和拖延习惯</title>
      <link href="/2022/02/09/power-of-present/"/>
      <url>/2022/02/09/power-of-present/</url>
      
        <content type="html"><![CDATA[<p>过完年了, 计划的一点都没做. 克服拖延似乎是很难的事.</p><p>读完了一本书提供了一个解决思路, 这种思路还可以对付所有负面情绪, 包括愤怒, 悲伤, 生死.</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="当下的力量"><a href="#当下的力量" class="headerlink" title="当下的力量"></a>当下的力量</h3><p>&lt;当下的力量&gt;的描述核心就是”当下”, 详细描述”当下”的含义, 以及解决的问题.</p><p>作者是个德国人, 但作品的核心思想很中国, 并且引用了很多古代著作: 坛经, 心经, 道德经, 圣经. 这点我不太清楚是译者引用的还是作者那么厉害. 这些作品都不容易读的.</p><p>而核心概念”当下”, 在我看来是对禅宗思想的布道. <code>终日吃饭，未曾咬到一粒米.</code> 也就是禅定的境界.</p><p>书里也说到, “当下”的概念, 就是道德经所描述的”道”.</p><h3 id="本文内容序"><a href="#本文内容序" class="headerlink" title="本文内容序"></a>本文内容序</h3><p>书里也有一些我不认可的玄学, 比如中间部分的”用身体思考, 不用大脑思考”. 很明显地, 这最多能理解为一种感受, 但实际思考的一定是大脑.</p><p>还因为只看了一遍, 所以本文和书里的内容结构是有差别的. 目标是提供一种<strong>拖延和不良情绪的解决方案.</strong></p><p>这个解决方案和之前的<code>意志力</code>, <code>生存本能</code>, <code>道德经</code>等的关系是互相补充, 也有一些重合, 毕竟所有思想的顶点如果最后是汇聚到一起, 这是证明真理最好的证据, 也是大家想看到的.</p><h2 id="大脑的问题"><a href="#大脑的问题" class="headerlink" title="大脑的问题"></a>大脑的问题</h2><p>&lt;你的生存本能正在杀死你&gt;, 一些现代行为经济学, 都是以<strong>承认大脑现在的运行方式是有缺陷的</strong>为基础的. 本文也是, 解决问题必须先承认问题, 我们来看看一些事实:</p><ul><li>世界是有个远比大脑更厉害的智能在运作的. 那么小的dna细胞中包含那么多信息. 我们的大脑比我们以为的笨得多.</li><li>大脑只是个工具, 而且还很不完善. 人思考有百分之80, 90都是翻来覆去想无用的内容, 并且大脑是”散弹枪”模式, 想一件事的时候会去想相关的事, 并最终离开主题导致主要问题没解决.</li><li>大脑会产生情绪, 情绪会导致事情变坏, 即使你本有能力使事情变好.</li><li>大脑有个快速思考的模式, 这个模式在大多时候是奏效的(也就是规则), 但一定有做错决定的时候(有规则就有例外). 这也是行为经济学的基础理论.</li></ul><p>而本文要解决的所有问题, 都是基于大脑<strong>想太多</strong>导致的问题.</p><p>那么想太多会导致那些问题, 每个问题又如何解决, 下面一一列举.</p><h2 id="过度思考让人无法行动"><a href="#过度思考让人无法行动" class="headerlink" title="过度思考让人无法行动"></a>过度思考让人无法行动</h2><p>我们都是天生的”等待者”. 大脑过度思考未来, 而不是现在. 这是蹉跎的关键, 因为<strong>人只能活在当下</strong>.</p><p>你不得不承认这个现实, 你的每个思想, 行为, 都是在当下发生的. 所以<code>你思考未来的时候, 你当下就啥事没干.</code>也就导致了你时间过去, 一事无成.</p><p>举几个例子:</p><ul><li>产品提了个需求, 程序员提出了很多可能的问题与产品battle. 实际如果开始做早做好了. 生活中被要求做一些事也是如此.</li><li>在纠结学英语还是学日语, 纠结去这个公司还是去另一个公司. 纠结了好久, 别人都学成了.</li></ul><p>这个问题古人也说了: 明日复明日, 万事成蹉跎.</p><blockquote><p>​解决方案: 认识到自己的问题, 抓紧行动, 另外还有一些小技巧.</p><p>​对进入当下有益的行为: 指定合理的目标(小胯部, 有小成果), 责任感, 本能.</p><p>​对进入当下有害的行为: 计算得失, 过多思考结果.</p></blockquote><h2 id="二元对立思维导致追求无意义的快乐"><a href="#二元对立思维导致追求无意义的快乐" class="headerlink" title="二元对立思维导致追求无意义的快乐"></a>二元对立思维导致追求无意义的快乐</h2><p>大脑的思考是遵从二元对立的, 没有坏就没有好. 我们追求的有对立的快乐都是无意义的.</p><p>有个段子: 欲望与理想的区别是得不到会产生痛苦的是欲望.</p><p>所以: 享受过程的是理想, 享受结果的是欲望. 而<strong>享受过程</strong>就是本书所说的”当下”.</p><p>再来说说二元对立的感情, 每一种愉悦或情绪上的兴奋都孕育了痛苦的种子, 痛苦迟早会出现. </p><p>可以举出很多例子: 毒品, 赌博, 游戏, 醉酒, 股票. </p><p>赢了&#x2F;醉了&#x2F;赚了就开心了. 那么输了&#x2F;醒了&#x2F;亏了是必然发生的事, 于是痛苦也就是必然出现的事了.</p><p>所以放弃二元思维的”好坏”. 也是避免痛苦的方法, 道德经也提到了有好才会有坏.</p><p>卖肉的说: “你问我哪块猪肉是最好的? 我卖的每块猪肉都是最好的”. 每个事物, 每个人, 都是最棒的, 不是吗. 很多衡量人的指标只是想象出来的, 众生是平等的.</p><p>比较表面的感情也是如此, 比较表面的感情是以结果为目标的, 而不是以付出本身为目标的.</p><blockquote><p>​解决方案: 追求过程的快乐, 进入当下状态, 享受当下状态. 理解追求结果是无意义的.</p></blockquote><h2 id="无限心给人带来的痛苦"><a href="#无限心给人带来的痛苦" class="headerlink" title="无限心给人带来的痛苦"></a>无限心给人带来的痛苦</h2><p>痛苦有2种, 肉体的和精神的.</p><p>我们仔细分析自己的痛苦, 几乎都来自于精神, 并且肉体痛苦的上限是远低于精神痛苦的.</p><p>这些来自精神的痛苦, <strong>完全是想象未来导致的</strong>. 并且<strong>如果不去想象, 痛苦根本就不存在了</strong>.</p><p>我们来做个思想实验: 在痛苦的时候<strong>感受当下</strong>, 我现在的处境痛苦吗?</p><ul><li><p>别人比我有钱, 可以买更好的房子&#x2F;车子&#x2F;衣服&#x2F;吃的.</p><p>感受当下: 我吃饱喝足, 身体没有任何不适, 地球没爆炸, 周围的人也没有会来打我杀我的.</p><p>所谓有钱, 只是对未来可能性的推断, 与人的地位比较也纯在想象中, 没有实际影响肉体.</p></li><li><p>患有很严重的疾病, 残疾, 功能障碍.</p><p>感受当下: 我身体有疼痛, 行动不便, 功能障碍, 虚弱, 难以呼吸, 头晕.</p><p>虽然很难受, 但比起对疾病的恐惧, 仔细对比, 肉体的痛苦是比精神痛苦少的.</p><p>我们对疾病的恐惧在于: 病治不好, 只会一天比一天严重, 一定会面对死亡. 而这个恐惧导致的痛苦已经远超过疾病痛苦本身了.</p><p>其实”疾病”的基础是时间, 是未来, 是思考. 如果去除对未来的思考, 疾病的概念本身并不存在, 我当下所经历的只是”疼痛, 功能障碍, 虚弱, 难以呼吸, 头晕”等症状.</p></li><li><p>死亡.</p><p>这是每个人都恐惧的东西, 但他也只存在想象中, 因为你永远感受不到死亡, 你的”当下”是不会有”死亡”的, 而你的所有感受一定是”当下”. 所以其实死亡是不存在的, 死亡只是我们的想象.</p><p>道德情操论也指出, 对死亡的恐惧是社会维持秩序的根本基础.</p></li></ul><p>那么: <strong>只感受当下的肉体, 不思考, 就不会痛苦.</strong> 在这条方案下, 奢侈品牌(普通品牌是质量保障, 奢侈品牌是地位象征), 金钱权力地位, 疾病, 死亡. 这些造成的痛苦都不是问题了.</p><p>但我们有没有意识到: 对应的快乐: 赚钱存钱的快乐, 买奢侈品的快乐, 疾病康复的快乐, 明天春游的快乐. 也不复存在, 都是假想了?  回答是: 是的, 都是假象, 但我们可以享受这些假象. 综上所述, 提出无限心的解决方案.</p><blockquote><p>解决方案: 快乐时享受快乐, 但降低预期. 悲伤时感受当下肉体, 用上帝视角观察自己的境遇, 是必然的, 是公平的.</p></blockquote><h2 id="负面情绪"><a href="#负面情绪" class="headerlink" title="负面情绪"></a>负面情绪</h2><p>情绪是大脑思考的产物, 大脑思考到以前发生过的危险的事, 遇到一些触发点时, 会预测为来发生的危险, 于是产生了负面的情绪.</p><p>而负面情绪并不等于痛苦, <strong>痛苦体还有另外个条件, 是你的抗拒.</strong> 你对情绪的触发事件的抗拒.</p><p>产生了痛苦体以后, 痛苦体会以”思考”作为养料, 并且让负面情绪占据你, 此时<strong>你会以为负面情绪就是自己的真实想法</strong>, 但事实不是, 他只是情绪, 并且以你思考为养料, 更多地占据你.</p><p>对应地, 分析了原因, 解决方案自然也就有了.</p><blockquote><p>解决方案: </p><p>初级方案: 有了负面情绪后不去继续思考分析, 断开负面情绪的养料, 保持一段时间负面情绪就会消失.</p><p>高级方案: 把抗拒变成接纳, 没有抗拒, 痛苦体就不会产生了.</p></blockquote><h2 id="接纳"><a href="#接纳" class="headerlink" title="接纳"></a>接纳</h2><p>接纳是负面情绪的完全解决方案. 单独一章来解释接纳.</p><p>什么是接纳? <strong>在发生任何事情, 产生任何情绪后, 能分析产生情绪的原因, 并理解到这种情绪是正常的.</strong></p><p>接纳以后的效果是什么? 平和, 平静. 以平静取代抗拒产生的无尽痛苦. 因为没有痛苦, 所以可以让自己做更正确的行为.</p><p>下面再说几个接纳的特点和具体例子.</p><h3 id="接纳不是接受"><a href="#接纳不是接受" class="headerlink" title="接纳不是接受"></a>接纳不是接受</h3><p>有人对自己提出了不合理的要求后(比如长辈喜欢让孩子”叫人”), 我们会产生愤怒的情绪, 并且生气地拒绝对方.</p><p>疑问: 接纳是指接受别人的不合理要求吗?</p><p>回答: 接纳是指<strong>理解世上总有人会提出不合理的要求, 已经发生的事是有他存在的原因的.</strong> 然后拒绝他, 但没有带着痛苦地拒绝.(当然也可以接受, 以慈悲心, 接受拒绝已经不重要了, 都不影响内心的平静)</p><h3 id="接纳不是消灭情绪"><a href="#接纳不是消灭情绪" class="headerlink" title="接纳不是消灭情绪"></a>接纳不是消灭情绪</h3><p>疑问: 学会接纳的人是没有负面情绪了吗?</p><p>回答: 接纳是允许情绪的存在, 并且分析情绪的来源, 以上帝视角看着他, 此时情绪只是情绪, 不再是痛苦了.</p><h3 id="接纳是不是放弃"><a href="#接纳是不是放弃" class="headerlink" title="接纳是不是放弃"></a>接纳是不是放弃</h3><p>疑问: 如果我陷入泥潭, 是不是接纳这个事实, 然后放弃挣扎?</p><p>回答: 接纳是指接纳自己掉入泥潭的事实, 不产生痛苦. 然后意识到自己可以挣脱, 最后努力挣脱泥潭.</p><p>这个例子也可以换成玩游戏碰到不好的队友. 开悟前的人反应可能是抗拒, 责怪, 谩骂, 然后自己挂机, 也成了导致游戏走向失败的一个因素. 接纳不好队友现实的人, 自己保持平静, 才能更好尽力成为游戏走向胜利的因素.</p><p>在尹烨的视频里看到个例子. 一个屎壳郎推屎碰到了石头, 经过不断努力, 突破了阻碍. 他没有欢呼庆祝, 继续往前推屎. 遇到困难的时候也不气馁放弃. 一个没有感情的人做事是多牛逼啊.</p><h3 id="悲剧和死亡的负面情绪"><a href="#悲剧和死亡的负面情绪" class="headerlink" title="悲剧和死亡的负面情绪"></a>悲剧和死亡的负面情绪</h3><p>疑问: 悲剧, 疾病, 死亡的负面情绪也能通过接纳来获得平静吗?</p><p>回答: 是的. 这是最难的接纳, 所谓接纳就是理解发生的一切都是客观存在的.</p><p><strong>一朵百合花从种子到开花, 花儿需要努力吗? 不需要. 你拼尽全力保护的东西就不会死亡了吗? 还是会的.</strong></p><p>这就是事实. “努力就会有好结果”, “世界是公平的”. 这些都是认知误区, 都是自以为是. 在之前的博客介绍过<code>心理防御机制</code>, 不接受现实, 即使看到现实也要坚持心中模型的防御机制叫做”否认”, 而接受他就是”接纳”. “否认”就是一种比较低级的防御机制. 接纳更能让人获得平静.</p><p><strong>也许我们做什么都是徒劳的, 认清了这点离绝望只差一步, 离开悟也只差一步.</strong> 享受可以享受的, 接纳不能改变的.</p><h3 id="关于接纳他人的不接纳"><a href="#关于接纳他人的不接纳" class="headerlink" title="关于接纳他人的不接纳"></a>关于接纳他人的不接纳</h3><p>我们常常会有一种情况: 想教别人道理, 比如想教别人接纳, 但别人冥顽不灵, 自己就开始生气了.</p><p>这个故事的结果是: 自己产生了痛苦. 究其原因是: <strong>自己抗拒别人的不接纳.</strong> 所以人心态要小心翼翼保持, 一不小心就走到了抗拒的陷阱里.</p><p>那我们应该如何做呢? 接纳别人的不接纳. 自己继续努力如何能让别人能接纳. 就像<strong>你不跟黑暗斗争, 而是带进光明.</strong> </p><p>回头想一想, 自己在开悟之前, 也都是不接纳的. 为何不接纳别人当前的不接纳呢. 其实也许<strong>全世界的东西都已经开悟, 只在等待人类的开悟</strong>.</p><h3 id="接纳的总结"><a href="#接纳的总结" class="headerlink" title="接纳的总结"></a>接纳的总结</h3><ol><li>接纳是指承认碰到的事情, 不产生坏情绪, 然后意识到事情可以更好, 然后去把事情做好.<br>其实是指接受不能改变的, 而不是不动. 改变能改变的, 是另一个话题.</li><li>表面看是灾难制造了苦难, 其实是你的抗拒制造了苦难.</li><li>接纳的结果是平静. 获得了平静, 就不会有痛苦. 还能更好的面对未来的事.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>react-refresh介绍</title>
      <link href="/2022/01/29/react-refresh-mechanism/"/>
      <url>/2022/01/29/react-refresh-mechanism/</url>
      
        <content type="html"><![CDATA[<p>公司一个业务框架在修改代码后竟然没有自动更新页面. 于是想尝试解决这个问题, 还是失败了.</p><p>出现问题的框架使用的是react-refresh来进行hmr, 虽然失败但记录下过程.</p><span id="more"></span><h2 id="react-refresh现状"><a href="#react-refresh现状" class="headerlink" title="react-refresh现状"></a>react-refresh现状</h2><p>hmr是hundler提供的一种功能, 是需要配合具体业务来实现的.</p><p>比如css通过css-loader, vue通过vue-loader. 而react没有官方支持, 社区有个react-hot-loader.</p><p>2年前react提供了官方hmr支持. 但是提供给rn的. 虽然react-refresh代码在react仓库里, 但react文档是搜不到ract-refresh的, rn文档里可以搜到.</p><p>react-refresh的react集成又是社区做的, 叫react-refresh-webpack-plugin.</p><p>umi的fast-refresh是用这个插件做的, vite的实现方法是基于那个<code>react-hot-loader退役issue</code>做的.</p><h2 id="react-refresh组成部分"><a href="#react-refresh组成部分" class="headerlink" title="react-refresh组成部分"></a>react-refresh组成部分</h2><h3 id="react-refresh-x2F-runtime"><a href="#react-refresh-x2F-runtime" class="headerlink" title="react-refresh&#x2F;runtime"></a>react-refresh&#x2F;runtime</h3><p>这部分代码在react包里, 所以react-refresh的最低react版本要求是要有这个文件.</p><p>除了runtime, react-dom里也新增了代码来配合runtime更新fiber. 这react内部的支持能比之前的react-hot-loader包一层组件更好地支持hmr.</p><h3 id="hmr机制"><a href="#hmr机制" class="headerlink" title="hmr机制"></a>hmr机制</h3><p>runtime提供了更新fiber的方法, 也必须触发点去调用他, 这就需要hmr机制了.</p><p>hmr机制流程是: watch文件改动 &#x3D;&gt; 重新运行这个文件包含的module &#x3D;&gt; 运行module中的更新逻辑.(runtime的代码应该在此执行).</p><p> (这是最小实现流程, 全部机制还包含各种向下退级操作, 拒绝后寻找父模块更新逻辑)</p><h3 id="react-refresh-x2F-babel"><a href="#react-refresh-x2F-babel" class="headerlink" title="react-refresh&#x2F;babel"></a>react-refresh&#x2F;babel</h3><p>下一个问题, runtime更新fiber, 需要知道哪个fiber改动过需要更新. 而代码是顺序执行的, runtime没法知道当前module执行的是哪个fiber.</p><p>解决思路: hmr时会重新执行module, 初始化会执行所有module. 那么最后特点是: 需要更新的module执行了2次, 其他的module执行一次.</p><p>所以需要在每个react组件声明完增加一个注册动作. 如果发现了重复注册, 就说明这个module是被hmr机制重新运行的, 就需要更新了, 于是把他推到<code>待更新节点</code>的队列里.</p><p>这需要把所有的react组件都增加注册的动作, 所以这个功能用babel插件来完成. (因为jsx也是依赖babel的, 所以用babel不会引入额外流程)</p><h3 id="串起全流程的实现逻辑"><a href="#串起全流程的实现逻辑" class="headerlink" title="串起全流程的实现逻辑"></a>串起全流程的实现逻辑</h3><p>以上说的内容, 都需要在编译时在代码里修改, 那么如果用webpack, 就是<code>react-refresh-webpack-plugin</code>这个插件做的, vite里是vite写的. </p><p>这个实现逻辑是和hmr系统强相关的, 基本流程说明在<code>react-hot-loader退役issue</code>里写了.</p><p>当然我们只要直接用webpack或者vite的插件就行了.</p><h2 id="与真实业务的关系"><a href="#与真实业务的关系" class="headerlink" title="与真实业务的关系"></a>与真实业务的关系</h2><p>其实说完组成部分, react-refresh的流程也说完了. 下面总结一下, 再结合实际问题聊聊.</p><h3 id="一般开启react-refresh方法"><a href="#一般开启react-refresh方法" class="headerlink" title="一般开启react-refresh方法"></a>一般开启react-refresh方法</h3><ul><li>遵循<code>react-refresh-webpack-plugin</code>文档, 三步走: 开启webpack hmr &#x3D;&gt; babel配置新增react-refresh&#x2F;babel &#x3D;&gt; webpack-plugin新增react-refresh-webpack-plugin.</li><li>umi: 配置fast-refresh插件. (内置插件配置即可)</li><li>vite: 使用react插件, 天然开启.</li></ul><h3 id="react-refresh执行角度全流程"><a href="#react-refresh执行角度全流程" class="headerlink" title="react-refresh执行角度全流程"></a>react-refresh执行角度全流程</h3><ol><li>代码dev阶段经过编译, 所有react组件被增加了一系列hmr的逻辑.</li><li>初次运行, 所有的react组件都被注册到了一张大表中.</li><li>修改文件, 被监测到, hmr机制重新运行被改动的module.</li><li>在重新运行时, 注册方法又被调用了一次, 于是更新过的组件, 被推到了<code>待更新队列</code>.</li><li>module最后被添加的代码会执行performRefresh尝试hmr.</li><li><code>待更新队列</code>的组件会被分析, 需要热更新还是直接替换, 分别调用scheduleRefresh或者scheduleRoot方法.</li><li>调用成功, 更新完成.</li><li>失败流程还没看.</li></ol><h3 id="最初发生问题的场景-为什么修改配置没有hmr"><a href="#最初发生问题的场景-为什么修改配置没有hmr" class="headerlink" title="最初发生问题的场景: 为什么修改配置没有hmr"></a>最初发生问题的场景: 为什么修改配置没有hmr</h3><p>因为react-refresh是基于<code>组件文件</code>的hmr系统. 如果大组件内部是基于props在render时运行产生组件的话, hmr触发时会invalid并向上级组件抛出, 最后重新整个渲染大组件.</p><p>(在我遇到的业务场景中, 业务组件比较复杂, 出于性能考虑组织了props更改重新渲染)</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>react源码相比vue遇到一个困难: 函数定义时很多是空, 不知道何时给函数赋值, 这个问题可以用浏览器下断点来解决.</p><p>可以看到类组件, 函数组件和hmr都是通过调用<code>scheduleUpdateOnFiber()</code>来进行更新视图的, 这个函数涉及到调用的fiber和一些全局变量, 打算之后再分析</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乾坤初尝试</title>
      <link href="/2022/01/23/qiankun-trial/"/>
      <url>/2022/01/23/qiankun-trial/</url>
      
        <content type="html"><![CDATA[<p>因为工作原因必须了解一下<a href="https://qiankun.umijs.org/">乾坤</a>, 总结一下乾坤使用级别的入门. </p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>乾坤是: 把多个应用结合成一个大应用. 这样可以单独开发, 动态部署.</p><p>作者说多数场景在”后台系统”. 确实, 我工作的公司是做2b系统的, 并且每个老用户都是有收入的, 在不断的迭代中, 前端框架, 仓库形式, 开发方式都有很大的改变. 乾坤可以说是很适合了.</p><p>(乾坤是基于什么开发的, 为什么不用iframe, 等等和使用无关的零碎信息都在乾坤文档中)</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>乾坤的具体工作形式是: 一个主应用(大多情况是一个后台系统的菜单), 加载多个微应用(每个菜单对应的应用), 并且微应用是不需要关注前端框架的.</p><p>大致流程是: 主应用通过路由, 或是应用中主动调用乾坤api来加载子应用. 主应用读取子应用配置的url, 或者js&#x2F;css来加载子应用.</p><p>下面是主&#x2F;子应用的介绍.</p><h3 id="主应用"><a href="#主应用" class="headerlink" title="主应用"></a>主应用</h3><p>乾坤对主应用同样是没要求的. 我选择用vite起了一个原生应用, 只要在main.js贴上几行代码就行了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerMicroApps, start &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerMicroApps</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;microapp&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;//localhost:3001&#x27;</span>,</span><br><span class="line">    <span class="attr">container</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">activeRule</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// start qiankun</span></span><br><span class="line"><span class="title function_">start</span>();</span><br></pre></td></tr></table></figure><p>是的, 就这几行.</p><p>当然在真实应用中会比较复杂, 至少涵盖一个菜单系统, 可能还有用户系统等, 然后用乾坤api主动加载子应用.</p><h3 id="子应用"><a href="#子应用" class="headerlink" title="子应用"></a>子应用</h3><p>子应用依然是框架无关, 但暂时不支持vite, 因为加载方式和依赖webpack特有配置. 并必须满足几个条件. 其中几个条件其实是能不考虑技术细节猜到的.</p><p>另外要提到的是, <strong>文档中所说的方法并不是唯一的, 甚至是应该根据自己具体项目来定的.</strong> 我们现有脚手架暴露了webpackchain, 那么直接在webpackchain可以设置很多东西.</p><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><p>原因: 主应用和微应用在dev时大多是跨域的, 因为port是不同的.</p><p>方法: 在起dev-server的时候加入允许跨域的响应头. </p><h3 id="webpack-public-path"><a href="#webpack-public-path" class="headerlink" title="webpack_public_path"></a><strong>webpack_public_path</strong></h3><p>原因: 微应用的资源如果不设置public-path会访问到主应用的host, 导致资源404.</p><p>方法: 在应用中判断是否在乾坤主应用中, 如果是, 把webpack_public_path设置为乾坤放到全局的publich-path.</p><p>关于public_path: webpack_public_path经过打包后是<code>webpack.p</code>变量. 这个变量会在引入相对资源的时候被追加在前面. 比如引用图片, 引用chunk file等. 默认值是从webpack配置的outpub.public_path取的, 也能接受在业务代码里修改这个值.</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>原因: 主应用要知道如何加载, 销毁子应用.</p><p>方法: 把加载应用流程写到方法里. 然后写一个销毁方法, 写到销毁方法里. 这里是与通常spa不同的, 因为通常spa不需要销毁应用.</p><h3 id="umd输出"><a href="#umd输出" class="headerlink" title="umd输出"></a>umd输出</h3><p>原因: 乾坤主应用加载js的方式, 需要把outpub.library改成指定的名字和umd模式.</p><p>方法: 修改webpack配置.</p><h3 id="history路由"><a href="#history路由" class="headerlink" title="history路由"></a>history路由</h3><p>原因: 乾坤主应用本身是要通过路由来判断子应用的, 避免冲突.</p><p>方法: 判断作为乾坤子应用时使用history路由, 并且设置好base.</p><h3 id="关闭hmr"><a href="#关闭hmr" class="headerlink" title="关闭hmr"></a>关闭hmr</h3><p>原因: hmr会建立websocket链接, 可能webpack还没给二开配置所以会404导致报错.</p><p>caveat: 如果加载了社区版的fast-refresh插件, 关闭了hmr是会报错的. 并且要同时关闭react-refresh&#x2F;babel插件, 他们都是强依赖, 少了互相就会白屏. 这就想到了umi设计的精妙之处.</p><p>如果通过webpack-chain关闭还需要注意首字母小写. 这个还是通过log了config对象看到的.</p><p>并且webpack-chain的api移除babel插件好像不好操作, umi里没使用webpack-chain来操作, 因为公司脚手架没那么厉害, 所以只能硬干了一串长代码, 还是解决了问题. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.<span class="property">module</span>.<span class="property">rules</span>.<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&#x27;js&#x27;</span>).<span class="property">uses</span>.<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&#x27;babel&#x27;</span>).<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&#x27;options&#x27;</span>).<span class="property">plugins</span> = config.<span class="property">module</span>.<span class="property">rules</span>.<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&#x27;js&#x27;</span>).<span class="property">uses</span>.<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&#x27;babel&#x27;</span>).<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&#x27;options&#x27;</span>).<span class="property">plugins</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item[<span class="number">0</span>] || item[<span class="number">0</span>] !== <span class="string">&#x27;react-refresh/babel&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当然也可以通过新写一个plugin来给react-refresh&#x2F;bable调用的函数写一个空函数. (react-refresh相关知识后续补充)</p><h2 id="我们why乾坤"><a href="#我们why乾坤" class="headerlink" title="我们why乾坤"></a>我们why乾坤</h2><p>我们公司之前一直使用js-entry的方式从菜单加载应用. 很显然把所有资源只加载到一个js和css中会产生问题.</p><p>code spliting和file-loader不打成base64的大资源等”除了主js会引入其他资源”的应用都是不可行的.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊阴阳</title>
      <link href="/2021/12/09/yin-yang-in-everywhere/"/>
      <url>/2021/12/09/yin-yang-in-everywhere/</url>
      
        <content type="html"><![CDATA[<p>中国古代哲学的基础概念是太极. 命理, 奇门遁甲, 中医, 道德经, 周易等无不以太极的概念作为基础.</p><p>而这古代哲学并不是玄学, 对于哲学来说”信不信”是伪命题, 哲学的基础是现实, 而生活中太极就无处不在.</p><span id="more"></span><h2 id="什么是太极"><a href="#什么是太极" class="headerlink" title="什么是太极"></a>什么是太极</h2><p>中国古代哲学把”世界的一般原理”称作为<code>道</code>, 或者叫天理(阳明心学), 也就是太极. 西方哲学科学追求的也是这个东西, 不过名字不同, 方法不同而已.</p><p>三命通会说: <code>夫天地未立, 道本天地, 天地既立, 则太极之理散在万事.</code> 世界所有事情都有阴阳, 这个是能很明确体会出来的, 之后再具体举例.</p><p>道德经第一章: <code>无名，天地之始，有名，万物之母。</code>这里的”无”和”有”, 也许是最大的阴和阳.</p><p>其实阴阳的思维就是西方哲学的<strong>辩证法</strong>. 而唯物辩证法正是马克思主义哲学的核心部分.</p><p>阴阳其实包含了唯心辩证法和唯物辩证法的思想.</p><p>其实阴阳指的就是任何实物的两面. 而阴阳没有明确定义, 是靠举例和说明来悟的. 下面展开说说.</p><h2 id="阴阳的特性"><a href="#阴阳的特性" class="headerlink" title="阴阳的特性"></a>阴阳的特性</h2><p>这里按照顺序说说我认为的重要的特性.</p><ol><li>阴阳之理是覆盖所有事物的, 一切事物皆有阴阳之理. 既一切事物都是关联, 对立, 统一的.</li><li>阴阳是相对的, 递归的, 自相似的. 人头为阳, 身体为阴. 而在头里, 器官为阳, 皮肤为阴. 鼻头为阳, 鼻孔为阴.</li><li>阴阳互根. 有阴才有阳, 有阳才有阴. 阴阳本是一元.</li><li>阴阳互相抑制. 自然有一个目的是达到平衡.</li></ol><h2 id="身边的阴阳"><a href="#身边的阴阳" class="headerlink" title="身边的阴阳"></a>身边的阴阳</h2><p>阴阳是真实的. 下面举几个生活中体会的例子.</p><ul><li><p>有痛苦才有快乐. 其实快乐就是”不痛苦”.</p><p>周末的快乐是因为工作日的痛苦. 在连续放假很久后, 也不觉得快乐. 所以很多退休的人去找工作.</p></li><li><p>自行车&#x2F;摩托车都有个概念就”counter-steering”, 既转向前要先往反方向转.</p></li><li><p>人的第一反应是反驳.</p></li><li><p>人对自己的评价是与实际相反的.</p><p>认为自己善良的时候其实在作恶, 认为自己很厉害的时候其实在退步.</p></li><li><p>一个指标有效的时候, 他就失效了.</p></li><li><p>当意识到一个问题的时候, 这个问题就快被解决了.</p></li><li><p>觉得开心的时候正在退步, 觉得困难的时候正在为进步(以后就会开心).</p></li><li><p>价值与价格互为阴阳. 价格是价值的形式, 但又不能完全表现价值.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 五行八卦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊换位思考</title>
      <link href="/2021/12/02/put-ourselves-in-other-s-shoes/"/>
      <url>/2021/12/02/put-ourselves-in-other-s-shoes/</url>
      
        <content type="html"><![CDATA[<p>第一次家里有了个新生儿, 面对的第一个问题就是孩子哭了应该怎么办.</p><p>那为什么会思考这个问题呢, 因为新生儿还没有语言. </p><p>接触到不会语言的人, 又必须与他交互时, 我才体会到了这个习以为常的<code>语言</code>的存在.</p><span id="more"></span><h2 id="语言与语言的能力边界"><a href="#语言与语言的能力边界" class="headerlink" title="语言与语言的能力边界"></a>语言与语言的能力边界</h2><h3 id="没有语言时候的窘迫"><a href="#没有语言时候的窘迫" class="headerlink" title="没有语言时候的窘迫"></a>没有语言时候的窘迫</h3><p>人类简史的作者认为语言是人类到达现在地位的重要因素. 确实, 所以面对一个没有语言能力并需要获得帮助的新生儿时, 我们会很无力.</p><p>同样的情况也会发生在濒死的人身上, 这时会让人更难受: </p><ol><li>濒死的人的需求往往比新生儿更迫切.</li><li>濒死的人的需求没被满足会留下更大的遗憾.</li><li>濒死的人的需求往往比新生儿更难猜.</li></ol><p>那在无语言的情况下, 去猜测对方需求的方法, 只有<strong>换位思考</strong>了.</p><h3 id="有语言真的就行了吗"><a href="#有语言真的就行了吗" class="headerlink" title="有语言真的就行了吗"></a>有语言真的就行了吗</h3><p>首先要表明我对”语言和换位思考的关系”理解: 换位思考并不是没有语言时的第二选择, 而是<strong>换位思考是高于语言的, 语言只是一个捷径.</strong> </p><p>我们把”想表达的东西”暂成为<code>&quot;意思&quot;</code>, 举例一些情况:</p><ul><li><p>语言是不完整的. </p><p>了解过多国语言会发现, 有一些单词是不能互译的, 这正是那个语言里的不完整部分.</p><p>不完整是因为那个文化环境还不需要经常表达那个意思.</p><p>并且语言其实是在发展的, 每个阶段都会多出一些词汇, 或者一些词汇变意.</p><p>所以任何语言, 几乎都是”意思”的真子集, 因为”意思”也许是无限的. 虽然语言会跟上, 但顺序是先有意思再慢慢产生语言的.</p></li><li><p>不是每个人都有很好的语言表达能力的. </p><p>同样地, 也不是每个人都有很好的语言接受能力的.</p></li><li><p>很多人不知道自己的真正意图. </p><p>这个情况在生活中太常见了. 例如顾客认为菜不好吃, 但怎么更换也不满意, 其实因为接受不了价格. 认为老板不好, 伴侣不好. 换了一个个也不满意, 其实是自己的期望错了.</p><p>在这些情况下, 语言甚至还不如没语言. 因为语言成了一个错误选项, 不如直接用换位思考去猜测对方的需求.</p></li></ul><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>不管是新生儿, 还是濒死的人, 语言的缺席给人的感受是: <strong>可惜</strong>.</p><p>但细想, <strong>语言的出现并不能完全解决人类的沟通问题.</strong> 所以即便是语言存在之处, 也存在着很多误解, 存在着很多可惜. 这里就聊聊最近在眼前发生的.</p><h3 id="参观与被参观"><a href="#参观与被参观" class="headerlink" title="参观与被参观"></a>参观与被参观</h3><p>一个成人与新生儿在一起的场景: 成人对新生儿说好多话, 说你真可爱, 你真幸福, 不要哭, 马上给你换尿布&#x2F;吃奶.</p><p>特别是作为第三者在看到这个场景的时候 (甚至看到月嫂大声呵斥孩子), 不知是可笑还是可惜.</p><p>他们甚至会觉得<strong>我已经告诉过你马上给你吃奶, 奶在加热了. 你还在吵, 你真不是个好小孩.</strong> </p><p>作为强势方(成人)开启自闭模式, 此时弱势方(新生儿)其实是非常可怜的. </p><p>类似的场景还出现在动物园.</p><p>参观的人很快乐, 觉得动物好可爱, 动物好开心.</p><p>其实是教科书式的投射. 他们<strong>把快乐建立在别人的痛苦上, 还认为正在痛苦的人是快乐的.</strong> </p><p>类似的场景甚至还出现在抢救濒死病人的时候. 我认为这是最最可惜的事情.</p><p><strong>往往在病人被抢救的时候, 家属会进入”参观模式”</strong>.</p><p>我认为, 家属开始<strong>分析</strong>病人情况或病人感受的时候, 就进入了”参观模式”. 正在被抢救的人希望的是亲人在旁, 最好握着手, 在一起战斗的感觉. 而不是被冷冰冰的看成一个东西分析.</p><h3 id="小时候的爸妈对我们-现在的我们对爸妈"><a href="#小时候的爸妈对我们-现在的我们对爸妈" class="headerlink" title="小时候的爸妈对我们, 现在的我们对爸妈"></a>小时候的爸妈对我们, 现在的我们对爸妈</h3><p>妈妈觉得我冷了, 该吃饭了, 这个东西不好不能碰.</p><p>我觉得爸妈衣服太旧了, 吃的东西太差了, 应该买个最新款手机&#x2F;电脑&#x2F;耳机&#x2F;车子, 应该去哪旅游, 不要不舍得花钱.</p><p>在明白了这两个行为是同一回事后, 确实开始理解爸妈, 也开始转换思维, 思考什么是真正的对爸妈好了.</p><p>当然也要开始思考, 我们提供给别人的东西, 别人是不是真的要. (在任何地方: 朋友, 工作)</p><h3 id="知识的学习"><a href="#知识的学习" class="headerlink" title="知识的学习"></a>知识的学习</h3><p>工作认识了几个很好的朋友, 会分享最近所学的东西. 但实际上, 消息是可以传递的(学什么), 而真的学习并不能传递, 还是得独自的花时间.</p><h3 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h3><p>正像人是独立的一样, 人是孤独的.</p><p>人自然就是孤独的, 人的成长是孤独的, 人在经历快乐&#x2F;痛苦的时候其实都是孤独的.</p><p>如果你认为你在快乐, 别人也为了你快乐的话. 就想一下, 有个家人提早下班了, 有个朋友加工资了. 你真的能感受到他正在经历的快乐吗?</p><p>而人类还有一个本能, 就是感到与他人同感时会获得快乐(道德情操论基本理论). 而<strong>获得这种快乐的前提正是孤独.</strong> (就像如果洗澡是快乐的, 前提是身体会自动慢慢变脏)</p><p>就像<code>看到活着的东西会感到自己也活着</code>一样, 感受到别人的感受时, 我们也会感受到<code>我不是一个人</code>的快乐.</p><p>那最后的问题就是: 我们如何去感受别人的感受, 避免那些可惜, 获得快乐呢.</p><h2 id="怎么去换位思考"><a href="#怎么去换位思考" class="headerlink" title="怎么去换位思考"></a>怎么去换位思考</h2><p>经过了思考, 我认为换位思考并没有技巧可以快速练成, 而是两个维度: 意愿和经历.</p><h3 id="意愿"><a href="#意愿" class="headerlink" title="意愿"></a>意愿</h3><p>感受别人来获得快乐是一种本能.</p><p>但自私也是一种本能.</p><p>同样地举个例子.</p><blockquote><p> 家里人告诉你: 我身体不舒服. 自私的做法: 回答, 快去看病, 不要病严重了再看来不及.</p><p>这种自私回答的意思是: 有事赶紧处理, 不要问题大了之后麻烦我. (不接受反驳, 也许当事人自己还真以为自己很关心家人, 这只是一种叫否认的心理防御机制)</p></blockquote><p>分析:</p><blockquote><p>看病他自己会去看, 之所以告诉你, 是害怕需要安慰.</p><p>如果你意识到了. 自己那种回答是自私的, 并且如果尝试感受家人, 双方都能获得快乐. (代价是付出一些精力)</p><p>那么去询问家人, 听他的经历, 感受他的感受. 然后和他一起作出判断, 和家人一起经历困难. 大家都会感受到另一种快乐的.</p></blockquote><p>其实<strong>意愿就是爱</strong>. 意愿并不能很快的解决问题, 但也许对方会感受到你的爱和善意(而不是最需要亲人的时候被忽视), 这正是人类最美好的东西.</p><h3 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h3><p>相比意愿, 经历是个硬的指标. 以为<strong>以己度人是我们与世界交互的根本法则.</strong></p><p>同样举例.</p><ul><li>我看见过绿色, 所以知道别人看到的绿色是什么.</li><li>我被针刺过, 才能知道别人被针刺了是痛苦的.</li></ul><p>当然, 经历过的也不能完全同感, 没经历过的也可以同感(比如死亡). (具体的在之前道德情操论的文章有详解.)</p><p>但有一点是肯定的, <strong>经历更多的人能去同情更多的人</strong>, 比如:</p><ul><li>老师能知道”没带作业”就是没做. 而学生不知道老师知道.</li><li>大人更能猜到孩子的心思. 而小孩猜不到大人的.</li><li>从穷到富的人能体会天生富人. 而天生富人不能体会穷人.</li><li>玩游戏&#x2F;看剧更多的能跟更多人聊天. 玩得少&#x2F;看得少的人能聊的人的范围更少.</li></ul><p>所以我把同感理解为: <strong>同路人.</strong> 我们走过的路更多, 就有更大概率和更多人同路.</p><p>而如果走的路更大, 可能走一条路就会有更多的人同路. 比如亲子, 夫妻, 工作, 朋友关系等遇到问题的思考和同感, 就更大概率能和其他人产生同感. (相比较某个游戏&#x2F;电视剧而言)</p><h3 id="我们并不只是一个身份"><a href="#我们并不只是一个身份" class="headerlink" title="我们并不只是一个身份"></a>我们并不只是一个身份</h3><p>一直从上帝角度说如何同情他人, 其实是一种自大. 如果说有同情和被同情2种角色, 那么每个人都是在2种角色间转换的. 当我们是需要被理解的一方, 该如何做呢?</p><p>答案是认识自己. (这个非常难) 正确认识自己, 正确认识自己的需求, 然后诚恳的向别人提出要求, 并且为别人想好如何帮助自己, 不光给别人提问题. 比如:</p><ul><li>能不能陪我去一次医院? (而不是: 我有点不舒服)</li><li>能不能帮我去xxx咨询一下如何xxx? (而不是: 某某事好麻烦, 我好心烦)</li></ul><p>可见, 被同情的人, 也需要去同情同情自己的人, 如何让同情自己的人更容易, 更方便同情自己.</p><p>所以无论如何, 这些表现的根源都是同一个: 对人(或其他一切)的爱与善意.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haha </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个简单的前端脚手架</title>
      <link href="/2021/11/26/scaffolding-basics/"/>
      <url>/2021/11/26/scaffolding-basics/</url>
      
        <content type="html"><![CDATA[<p>之前写了一些写electron, 浏览器插件, vscode插件这样的项目. 这些项目其实是有一些固定模板的, 但又没有主流脚手架, 于是观察了一些其他脚手架, 写个<a href="https://github.com/cwj0417/haha">自己的脚手架</a>来快速启动项目.</p><span id="more"></span><h2 id="脚手架的来历和构成"><a href="#脚手架的来历和构成" class="headerlink" title="脚手架的来历和构成"></a>脚手架的来历和构成</h2><p>脚手架是前端工程化的一个部分.</p><p>前端工程化的起点是nodejs.</p><p>脚手架就是用nodejs写一些脚本, 来提高日常开发的效率.</p><p>提高效率的方式是: 把日常要”复制-粘贴-修改”的动作做成”命令+配置”的形式.</p><p>接下来看看脚手架的具体工作.</p><h2 id="脚手架的进化"><a href="#脚手架的进化" class="headerlink" title="脚手架的进化"></a>脚手架的进化</h2><p>与任何软件一样, <strong>一个复杂的东西都是由一个简单的核心功能开始的.</strong></p><h3 id="封装一下cv操作"><a href="#封装一下cv操作" class="headerlink" title="封装一下cv操作"></a>封装一下cv操作</h3><p>如果每次新项目都要找老项目复制, 那么我们就写一个固定的初始模板, 然后封装一个node命令来一键复制指定模板粘贴到新项目里.</p><p>我认为<strong>复制&#x2F;粘贴的脚本是脚手架最核心的功能</strong>, 之后花来呼哨的进化都是为了<strong>功能更多, 更灵活</strong>.</p><h3 id="模板的灵活性"><a href="#模板的灵活性" class="headerlink" title="模板的灵活性"></a>模板的灵活性</h3><p>比如vue的项目是否用vuex, 是否用router, 是否用ts等, 一个固定的模板就不行了. 除了设置多个模板外, 有(可能是)yoeman发明的generator写模板的方法, 也可以是js模板字符串, ejs, 或是任何js来灵活生成模板的方法.</p><h3 id="模板来源的灵活性"><a href="#模板来源的灵活性" class="headerlink" title="模板来源的灵活性"></a>模板来源的灵活性</h3><p>模板接受更多的来源, 就可以有更大的社区拓展性, 除了在npm包内部写好模板, 还可以从git, http, 文件, 其他npm包等方式读取. 只要遵守一些规定, 很多地方的模板都可以被加载.</p><h3 id="scripts与template分离与配置读取"><a href="#scripts与template分离与配置读取" class="headerlink" title="scripts与template分离与配置读取"></a>scripts与template分离与配置读取</h3><p>模板除了一些html文件, 还会有dev, build, test等scripts.</p><p>这些scripts需要和很多配置文件(比如webpack配置&#x2F;babel配置等)配合使用. 而这些配置文件在一些脚手架会被封装起来.</p><p>封装起来以后, 用户看不到, 也不能操作配置文件. 那有一些简单的自定义配置就需要封装后的scripts去读取用户目录下的配置文件. cra还提供了eject方法不可逆的把配置吐出来.</p><blockquote><p>​不知道scripts与template的分离的主要作用是不是看起来更高端, 配置文件露在外面真的有多少影响用户使用吗?</p></blockquote><h3 id="更多的业务集成-插件系统"><a href="#更多的业务集成-插件系统" class="headerlink" title="更多的业务集成, 插件系统"></a>更多的业务集成, 插件系统</h3><p>而脚手架有更高阶的形式(指umi). 把更多业务场景集成落地, 除了配置还能灵活使用插件来使更多的项目都可以使用他.</p><p>与<code>复杂的东西都是由简单的核心功能开始</code>一样, 前端组件系统, 也会从组件, 到高级组件, 到模板市场.</p><h2 id="写一个普通脚手架的步骤"><a href="#写一个普通脚手架的步骤" class="headerlink" title="写一个普通脚手架的步骤"></a>写一个普通脚手架的步骤</h2><p>看了一些别人脚手架, 其实核心部分不多, 很多是读取参数, 判断参数等提升用户体验的代码.</p><p>所以完成一个可用脚手架poc还是很简单的. </p><p>下面说说<a href="https://github.com/cwj0417/haha">我这个简单的脚手架</a>的完全开发流程. 效果是执行<code>npx create-haha-app &lt;项目名称&gt;</code>就可以产生一个可以dev, build的electron应用了.</p><p>我主要参考的是cra来写了这个脚手架. 主要流程是:</p><ol><li>在create-app包中: 读取参数, 确定template和script. template和script都是npm包. (template也可以是别的)</li><li>在create-app包中: 使用npm安装template和script. 并调用script中的init方法.</li><li>在script包中: init方法复制template(此时已经被安装)到项目文件夹中.</li><li>在script包中: 移除template.</li></ol><p>然后具体实施的流程如下:</p><ol><li>创建monorepo. create-app包和script包, template包是不用的npm包, 并且script和template还是可以多份的. <code>lerna init</code>来创建, <code>lerna create &lt;package&gt;</code>来新增一个包.</li><li>create-app包以<code>create-</code>开头, 除了npx可以执行, 便于<code>npm init</code> 和<code>yarn create</code>执行. 并在指定bin文件第一行声明执行语言.</li><li>在create-app包的入口里: 读取参数, 安装script和template. 安装后使用script的init方法初始化项目文件.</li></ol><p>(完)</p><p>是的, 一个create-app的脚手架就完成, 算上换行和日志不到100行. 之后要编写更多别的模板, 在monorepo里新增包就可以了!</p><p>而template和script的具体内容, 其实就属于工程化的另一个范畴了. (通常是dev, build和test)</p><h2 id="调试模板时的思考"><a href="#调试模板时的思考" class="headerlink" title="调试模板时的思考"></a>调试模板时的思考</h2><p>因为我的目的是做electron, chrome插件这样的脚手架, 意识到市面上的很多脚手架还是相当行业定制化的.</p><p><strong>template与script应当是1对1关系.</strong> electron的脚本一定运行不了chrome, 反之亦然.</p><p>而cra是同一个script可以运行2个template: 普通的和使用ts的. script也就是判断了是否是ts然后加一些配置. 在我看来这个灵活性还是有问题的. 看了一下别的cra-based脚手架, 也<strong>都没有明确指出template和script对应关系</strong>.</p><p>另外, 在调试模板时, 我选择了用monorepo特性在template文件夹里直接调试, 也不知道cra和其他脚手架是如何调试的.</p><p>最后, 看了下cra的测试用例, 非常明显是不能保证自己功能的, 只是写了几个js方法的测试. 看来脚手架的测试和模板的调试目前也算是个没明确解决方案的问题.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>脚手架是一段nodejs的脚本, 封装日常开发的重复事项, 发布到npm来方便使用.</li><li>脚手架的开发模式其实并没有固定的, 根据作用粒度和针对的业务来创造代码结构.</li><li>脚手架本身的开发流程和测试用例还处于继续探索阶段.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何排出自己的八字</title>
      <link href="/2021/08/23/how-to-get-your-four-pillars/"/>
      <url>/2021/08/23/how-to-get-your-four-pillars/</url>
      
        <content type="html"><![CDATA[<p>因为八字衍生的东西实在多, 百度上的不全, 只好自己写一个, 也好操作.</p><p>而在过程中收获了一些常识, 也对八字算命了解了更多.</p><span id="more"></span><h2 id="求在我者-x2F-求在他者"><a href="#求在我者-x2F-求在他者" class="headerlink" title="求在我者&#x2F;求在他者"></a>求在我者&#x2F;求在他者</h2><p>世上有两种求, 一种是自己可控制的, 另一种是自己不可控制的, 举几个很普通的例子.</p><ul><li><strong>下雨天.</strong> 希望撑伞是求在我者, 我想撑就撑, 不撑就淋雨. 希望雨停是求在外者, 我想不想都不影响结果.</li><li><strong>他人做不顺我心的事.</strong> 我决定不理他还是与他争论, 是求在我者. 他会不会按照我的意愿做事, 是求在他者.</li><li><strong>健康的身体</strong>. 我的生活方式是求在我者. 身体是不是健康, 是求在他者.</li><li><strong>高考, 工作.</strong> 是否努力学习和工作, 是求在我者. 成绩好不好工作能不晋级, 是求在他者.</li></ul><p>遇到这类的事情还有很多, 有的”求在他者”, 我们认为自己是可以掌握的, 比如晋级可以跟领导多走动. 那这其实还是求在我者.</p><p>在身体健康上, 我们就必须承认, 有运气成分了. (不承认的人运气比较好而已)</p><p>比如天生某些脏器不好, 不是锻炼可以改变的, 已经是”之前的原因”导致的结果了. 那些””求在外者””, 已经是结果了. 原因已经发生完毕, 而结果还在未知状态. </p><h2 id="业"><a href="#业" class="headerlink" title="业"></a>业</h2><p>世间充斥着因与果, 有因必有果.</p><p>一个因可以导致一系列的果, 我们把一段因果设想成一根线的话, 那么世界就是纷纷扰扰许多线纠缠而成的.</p><p>我们的人生, 是由无数个果形成的. 很明显地, <strong>造成这些果的因, 并不都是我们自己做的.</strong></p><p>每个缘起都之前因的果, 也是之后果的因. 假设我们的人生被一定数量的果影响着, 那<strong>这些结果是我们自己能控制成因的事, 一定不是全部.</strong> 其原因有三:</p><ul><li>一些结果已经是被确定的, 并一定会发生在我们身上的. 如出生和天赋.</li><li>一些能寻到原因并改变的事, 还会被别的事情影响, 千丝万缕, 很难缕清源头再去改变他.</li><li>导致结果的原因太多了, 做不到一个个去分析.</li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>但一件件小事, 如果背后有某个准则, 就会形成”系统”. (系统论我还没有读过)</p><p>我们认为, 每个事发生背后是有一个准则的. 即是”道”或者说”法”, 也或者”天理”. 这个也是物理科学家在做的事: 寻找一个一般公式来解释世界所有发生的事.</p><p>我们做不到一件件事去找原因, 于是希望<strong>去了解系统, 来用系统推出小事的发生, 来对”求在外者”进行控制</strong>, 那么我们就可以完全控制我们的人生了.</p><p>而阴阳五行八卦的规则, 就是建立一个系统, 然后在实践中总结规律.</p><p>其实这个与现代西方科学的方式是很像的: 猜公式, 然后去实践中验证, 如此循环.</p><p>写到这里, 终于尝试诡辩了五行八卦不一定是瞎吹. 至于什么是科学, 太难, 今后再思考.</p><h2 id="八字"><a href="#八字" class="headerlink" title="八字"></a>八字</h2><p>要知道啥是八字, 先得知道一些基本概念: (都是我的理解, 具体还得查看其他资料)</p><ul><li><strong>阴阳.</strong> 万物都有相对面, 把这两面称作是阴阳. 例子太多, 不多展开, 需要意会. 如男女, 山水, 蜡烛和火焰, 河中的水和鱼, 太阳和火焰.</li><li><strong>五行.</strong> 万物都有让人发生的感觉, 如”生长”, “繁茂”, “柔软”, “灵活”. 总结了五个字来代表某个事物的性质. 五行也要意会, 切不可着相.</li><li><strong>天干和地支.</strong> 天象和地球上发生事的规律总结, 就像是对季节, 时间的总结一样. 天干有十个, 地支有十二个. 每个天干有自己的阴阳五行. 每个地支包含着若干个天干, 也就藏气. “气”又是个不可言传不可着相的东西.</li></ul><p>天干地支有许多用处, 比如地支代表十二生肖, 天干可以用来当比划, (甲乙丙丁)来代替张三李四…</p><p>当然有一个重要的用处: <strong>干支厉</strong>. 用天干地支来记时. 而**八字的意思就是, 在干支厉中我们出生的年月日时. ** 四个要素都有天干和地支两个元素, 故一共八个字. 也叫四柱, 即日柱&#x2F;月柱&#x2F;年柱&#x2F;时柱. </p><p>下面来说说干支厉是怎么记时的.</p><h2 id="六十甲子"><a href="#六十甲子" class="headerlink" title="六十甲子"></a>六十甲子</h2><p>十个天干和十二个地支, 来回匹配, 一共有几个组合呢? 答案是小学二年级学的最小公约数: 60.</p><p>每个元素都有一个天干和一个地支组成, 这六十轮回的第一个组合是甲子, 所以也叫六十甲子.</p><p><strong>干支厉的记时方法就是用六十甲子轮回来记录年月日时.</strong></p><p>那接下来就出现了2个问题: 1. 轮回的起点是哪里. 2. 轮回的周期是多少.</p><p>轮回的起点, 我选择忽视, 只要找到上一个甲子做对比就可以了.</p><p>那轮回的周期是啥? 是一个固定周期, 特别好算: 地球绕太阳一周的时间. 也叫太阳回归年. 这个数字是365天5小时48分46秒<strong>左右</strong>. </p><p>为什么是左右? 因为是个平均值, 其实<strong>地球绕太阳运动并不是规律的</strong>. 而这样就显得八字看命特别科学, 因为八字的根本是太阳照射地球的关系, 而地球上的负熵现在认为也都是太阳带来的.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此, 我们的排盘公式可以写出来了. 排盘公式用得做多的方法就是”余”. (也是小学二年级学的)</p><ul><li>以某一年的所有月的具体时间, 来做锚点, 计算目标年月的干支.</li><li>年月以365天5小时48分46秒为周期, 估算目标年月.</li><li>年以每年第一个干支月(节气)为划分点. (立春)</li><li>每天划分成12个时辰. 日就以第一个时辰为划分点. (子时)</li><li>时的地支是时辰, 天干用”日上起时法”来映射. (计算的时还是用”余”就行, 表的来源还是观察天象和发生的事来总结规律)</li></ul><p><a href="https://github.com/cwj0417/unmei/tree/main/src/service">排盘公式</a>才写完, 命理推算还得继续学习. 最后说说写排盘公式学到的历法知识(常识)和百度上软件问题可能出现的地方.</p><h2 id="阳历-x2F-阴历-x2F-干支厉的关系"><a href="#阳历-x2F-阴历-x2F-干支厉的关系" class="headerlink" title="阳历&#x2F;阴历&#x2F;干支厉的关系"></a>阳历&#x2F;阴历&#x2F;干支厉的关系</h2><p>阳历, 公历是太阳历. solar calendar. 根据太阳和地球的运动制定的历法.</p><p>阴历, 农历是月亮历. lunar calendar. 根据月球与地球的运动制定的历法.</p><p>这么看来, 干支厉是一种阳历. 干支厉的月份是节气, 所以我们会发现节气与公历的关系是很固定的. (对比农历和公历的月日差别很大)</p><p>接下来说说具体算法. <strong>地球和太阳交互一圈是365天6小时不到, 并且是不定的.</strong> 但会有一个大概的数. (即365.2422天).</p><p>农历其实不是按照”月球与地球”运动. 而是”月球绕地球公转相对于太阳”运动. 直白说就是, 月亮圆缺的周期. 周期大概是29.53天. 这个周期叫朔望月.</p><p>所谓的”天”是地球自转形成的, 这是人们对”日”的直观感受, 所以必须用自转作为基本单位. 下面就开始说不同历法的做法.</p><ul><li>公历: 以365天为一年. 然后用”闰年”来补, 闰年规则复杂是因为要尽量保证长期不多偏移.</li><li>农历: 以29天为一个月. 农历的月是来自圆缺, 所以农历十五月亮会比较圆. 而每个月差的半天会用”闰月”的算法来补. 所以有一些年会有13个月, 补上的月叫做”闰x月”.</li><li>干支厉: 以天文观察为周期. 每年不定, 平均是365.2422一年. 每15度一个节气, 每30度一个干支月.</li></ul><p>所以干支厉是最能反应地球受太阳恩宠的时间了. 一开始写公式我还去计算2个年之间间隔闰年的个数, 后来发现完全不需要.</p><p>而回归年的不稳定, 也导致了八字的不稳定, 这样到底是科学还是不科学, 我还说不清. 但这么看来, 八字一定是有一些误差的.</p><h2 id="百度里排盘软件的问题"><a href="#百度里排盘软件的问题" class="headerlink" title="百度里排盘软件的问题"></a>百度里排盘软件的问题</h2><p>百度上一众排盘软件, 质量不一.</p><p>我这里列举各个软件一下可能算错八字的情况. (从粗糙到细致排名)</p><ol><li>晚子时(23点到0点). 晚子时有的软件会算错干支日, 因为以阳历日子算干支日了.</li><li>立春前或节气前后. 以阳历年月来算干支年月的软件会在这里出错.</li><li>节气精确度. 这里分2点. 第一, 节气是精确到秒的, 没让你填出生秒数的肯定精确不到秒. 第二, 节气应该是枚举的 而不是推算的(我是推算的), 所以其实我们没法知道未来出生的人的八字.</li><li>时间跨度. 许多软件年都不给填, 具体原因不知, 在选了最早的年后还有bug.</li></ol><p>最后放一个<a href="https://www.china95.net/paipan/bazi/">还可以的排盘软件</a>链接和<a href="https://jieqi.911cha.com/2021.html">查询节气</a>的链接.</p><h2 id="关于时区"><a href="#关于时区" class="headerlink" title="关于时区"></a>关于时区</h2><p>写公式的时候遇到了时区的问题, 那么有一个问题是: 干支日是绝对的还是相对的?</p><p>同一时刻, 北京子时, 美国出生的那个人, 算出生在子时还是午时呢?</p><p>根据五行原理, 五行之力是流动的, 所以我认为, 五行是分时区的, 五行的流动就是太阳的流动.</p><p>得出以下3个结论:</p><ol><li>不跨时区的直接按当地的出生时间算就可以.</li><li>即使在中国, 其实得按严格时区来加上offset才能得到更准的八字.</li><li>我理解五行之力的流动是断层的, 所以八字也只是一个粗糙估计, 因为时区也只是规则, 时区其实是均匀流动的. 这可能是八字有误差的原因之一.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 五行八卦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用github action来给博客和electron应用做部署与自动更新</title>
      <link href="/2021/08/04/deliver-blog-and-electron-with-github-action/"/>
      <url>/2021/08/04/deliver-blog-and-electron-with-github-action/</url>
      
        <content type="html"><![CDATA[<p>travis-ci从21年6月15开始停止服务, 新版本需要迁移才能继续服务, 这意味我的博客和electron应用都要去进行迁移了.</p><span id="more"></span><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><p>在迁移过程中老的travis脚本一直报错, 在查询文档完全没头绪之后在stackoverflow上找到了答案, 要手动选择一个plan才能正常跑ci. 即使是选免费的, 所以我选了一下免费plan.</p><p>ci终于和以往一样跑成功了, 但发现免费plan的额度是不会再生的, 也就是真正意义上的”试用”, 原来travis-ci收费了.</p><p>于是我尝试去找了免费ci, 找到了circle-ci. 每个月都有1000分钟免费时间, 并且vue和facebook等都在用. 于是照着circle-ci的文档配了ci.</p><p>在配完ci运行以后发现, circle-ci有个概念叫”excutor”, macos和windows是要收钱的, 那这很明显不能符合我打包electron应用的需求了.</p><p>于是放弃, 最后找到了github action.</p><h2 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h2><p>github action是github搞的ci工具. 他说自己是workflow, 但我没能说出workflow和ci&#x2F;cd的区别.</p><p><a href="https://docs.github.com/en/actions">github action</a>有2大优点: 大公司靠谱, 免费用户没有功能限制. (travis以免费为名实为试用, circleci免费用户阉割功能)</p><p>github action配置形式是在repo的指定文件夹写yaml文件. 下面介绍下一些基本概念:</p><h2 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h2><p>文档里有个一句话概括, 我觉得很帅:</p><blockquote><p>An event automatically triggers the <em>workflow</em>, which contains a <em>job</em>. The job then uses <em>steps</em> to control the order in which <em>actions</em> are run. </p></blockquote><p>这几个概念的关系是:</p><p><strong>event</strong> &#x3D;&#x3D;(触发)&#x3D;&#x3D;&gt; <strong>workflow</strong> &#x3D;&#x3D;(包含多个)&#x3D;&#x3D;&gt; <strong>job</strong> &#x3D;&#x3D;(包含多个)&#x3D;&#x3D;&gt; <strong>step</strong> &#x3D;&#x3D;(包含多个)&#x3D;&#x3D;&gt; <strong>runner</strong></p><p>并且, <strong>step</strong> + <strong>runner</strong> 可以被抽成一个 <strong>action</strong>. 并发布到云上给其他人用.</p><p>下面说说我对各个概念关系的理解:</p><ul><li><strong>event</strong>和workflow. 每个<strong>workflow</strong>都是一个文件, 每个<strong>workflow</strong>都要指定一个event来触发这个<strong>workflow</strong>.</li><li><strong>workflow</strong>和<strong>job</strong>. 一个<strong>workflow</strong>可以包含一个或多个<strong>job</strong>. 不同<strong>job</strong>作为一个运行单位可以同步运行也可以异步运行.</li><li><strong>step</strong>, <strong>runner</strong>, <strong>action</strong>. 在我理解是同级的, 只是影响显示分组, 不影响实际执行.</li><li><strong>action</strong>其实是一个<strong>job</strong>. 但使用的时候是<strong>step</strong>的下级.</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我拿了3个项目来写不同复杂度和用处的github action. 这里分别介绍.</p><h3 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h3><p><a href="https://github.com/cwj0417/sxdm/blob/main/.github/workflows/test.yml">第一个例子</a>最简单, 分支被推送的时候运行测试用例. 简单介绍下步骤.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">unit-test:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14.x&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">yarn</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">yarn</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>因为很短, 所以逐行分析每行配置的作用:</p><ol><li>name: test     当前工作流的名字, 随便叫</li><li>on: [push]     在分支被推送的时候运行这个workflow</li><li>jobs:     job声明的键, 没什么意义</li><li>unit-test:     job的名字, 随便起</li><li>runs-on: ubuntu-latest     job运行环境. 这里可以设matrix来让job运行在多个环境里</li><li>steps:     step声明的键, 没什么意义</li><li>uses: actions&#x2F;checkout@v2     使用别人的action, 作用是拉代码.</li><li>uses: actions&#x2F;setup-node@v2     同样是别人写好的action, 作用是设置node环境.</li><li>with: node-version: ‘14.x’      给上面action传的参数, 意思是要用node版本14</li><li>run: yarn      执行命令<code>yarn</code>安装依赖</li><li>run: yarn test     执行命令<code>yarn test</code>运行测试脚本</li></ol><p>就是这么简单然后根据这个workflow的输出信号, 来判断这段ci的失败和成功, 还会在github的commit界面上显示一个小勾或者小叉.</p><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>之前在travis-ci上已经能做到, 推了代码后, 博客网站直接更新. 这次迁移比以前容易多了, hexo官网已经写好了github action的action插件, 直接用就行了. (顺便更新了hexo的node和pug版本)</p><p><a href="https://github.com/cwj0417/fjonas.github.io/blob/source/.github/workflows/build.yml">例子</a>中可以看到有<code>$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</code>来作为token的占位符. 这里还有2个巨大的便捷处: </p><ol><li>免配置, 我去github personal token看了, 没有一个token被使用的, 也就是配置token是不需要去新建一个token的. 文档没有特别仔细看, 我理解为这是个虚拟token.</li><li>没有额外的设置步骤. travis-ci除了在github生成token, 还要去travis的设置里设置token, 用github action省去了这2个麻烦的步骤.</li></ol><h3 id="部署electron应用"><a href="#部署electron应用" class="headerlink" title="部署electron应用"></a>部署electron应用</h3><p><a href="https://github.com/cwj0417/schedule-pro/blob/main/.github/workflows/build.yml">例子</a>中有许多注释, 我尝试了各种action, 创建release, 上传artifact, 把artifact上传至release等. 后还是发现直接用<code>electron-builder</code>提供的功能比较好.</p><p>他的部署功能集成在npm build命令里的, 我理解做了几件事:</p><ol><li>整理更新文件.</li><li>把应用的主进程和渲染进程打包, 根据配置, 把更新文件一起打入包内.</li><li>根据配置, 把应用包和更新文件一起传到指定的地方.</li></ol><p>这里注意要把<code>releaseType</code>设置为<code>release</code>, 默认是<code>draft</code>, 还要去手动发布.</p><p>这比自己写github action方便的地方有:</p><ol><li>支持auto-updater, auto-updater有约定schema的更新文件, 自己很难处理.</li><li>不需要配置麻烦的action.</li></ol><p>只要使用<code>electron-builder</code>的npm build命令, 再引用对应的npm包<code>electron-updater</code>在<a href="https://github.com/cwj0417/schedule-pro/blob/main/src/main/index.ts#L13">主进程里</a>, 自动更新就能完成了. 要注意的是. 如果应用没有签名, 是不能自动安装的, 但可以获取更新信息引导用户手动下载哦.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> ci </tag>
            
            <tag> github action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在electron中使用前端框架</title>
      <link href="/2021/08/04/electron-with-ui-framework/"/>
      <url>/2021/08/04/electron-with-ui-framework/</url>
      
        <content type="html"><![CDATA[<p>electron无疑是个很强的东西, vscode近年非常流行, 其他还有github客户端, twitch, figma等大公司有electron开发的软件.</p><p>但electron在前端开发中仍算冷门. 不分析原因, 但导致的结果是没有很稳定的脚手架.</p><p>目前官方只有一个react的模板, 剩下只有awesome-electron里民间的几个模板.</p><p>面对纷繁多样的需求, 这几个模板肯定是不够的, 而electron的流程又很简单. 所以这里总结一个大方向.</p><span id="more"></span><p>(接触electron已有一段时间, 感慨自己上个electron项目竟然已经4年多, 那是electron版本还是1, 现在已经13.1.7了).</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>electron的进程模型像是chrome浏览器: 浏览网站在tab中进行, chrome有一个主进程管理着所有tab.</p><p>electron分为<strong>主进程</strong>和<strong>渲染进程</strong>.</p><p>可以理解为:</p><ol><li>electron应用的打开, 是起了一个node服务.</li><li>这个node服务拥有很多api, 掌控着应用的各个活动.</li><li>用户看到的界面是一个或多个网页. 主进程的api可以打开或关闭他.</li></ol><p>现在主流的web开发会用一些前端框架, 也会用一些ts.</p><p>而electron还没支持直接启动ts文件, 也不会在启动electron的时候去做前端框架的开发流程. 所以这里需要自己简单地组装一下.</p><p>本文主要介绍思路, 也会提到一点实践, 在这个<a href="https://github.com/cwj0417/schedule-pro">仓库</a>里.</p><h2 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h2><p>electron天然是不支持启动ts的, 文档里说得也不明确, 但在官方模板里有用<code>electron -e ./babelconfig ./src/main.ts</code>来启动ts文件的语法.</p><p>但出于需要满足更多需求和灵活性, 还是自己来编译ts. 我们要做的是:</p><ol><li>开发阶段: 编译并监听<code>main.ts</code>的变化, 编译成功后重启electron. (electron没有热重载)</li><li>打包阶段: 把ts编译成js到指定的目录.</li></ol><p>因为electron启动文件的特殊性, 过程中是有2点要特殊处理的:</p><ol><li>窗口加载内容的地址: 在开发时, 地址会是localhost, 而打包时要取包内资源地址.</li><li>preload的加载: preload的加载语法上是一个地址, preload也用ts写的话就不是自然加载的.</li></ol><h2 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h2><p>preload是electron新版本的特性, 目的是提高electron应用的安全性. 在渲染进程里需要调用nodeapi时, 老版本可以直接通过<code>electron.remote</code>操作nodeapi. </p><p>preload可以理解为node端供前端调用的api, 方式是通过<code>electron.contextBridge.exposeInMainWorld</code>方法暴露全局变量.</p><p>对于preload的编译, 除了ts到js, 还多了如何加载到主进程入口的问题. 我这里使用了esbuild的不同的loader来处理开发时和打包时的行为.</p><h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><p>渲染进程就是我们最熟悉的网页. </p><p>应用里不同的页面可以加载不同的网页. 所以理论上我们是可以不同网页使用不同框架的.</p><p>但出于开发方便考虑, 不同网页我选择了用不同路由来开发.</p><p>不管使用vue还是react, 下面就是我们最熟悉的开发流程. dev起localhost的指定端口, build抛出dist的js, css等文件. 在electron的开发中也是如此, 我们要做的就是: </p><ol><li>开发阶段: 起了dev服务以后, 让主进程指定窗口地址的时候指向localhost.</li><li>打包阶段: 让主进程指定窗口地址的时候指向打包后的html&#x2F;js&#x2F;css资源.</li></ol><p>下一节来说说组装的主要流程和需要解决的问题.</p><h2 id="组装成型"><a href="#组装成型" class="headerlink" title="组装成型"></a>组装成型</h2><p>首先定一个基调, 因为需要一些进阶的操作, 在脚本里一定选用nodeapi, cliapi操作起来会比较麻烦. 把刚才说的思路连贯起来, 整个流程就明确了:</p><h3 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h3><p>参考代码<a href="https://github.com/cwj0417/schedule-pro/blob/main/scripts/run-dev.js">在这里</a>.</p><ol><li>探测空闲端口, 起渲染进程的dev服务器.</li><li>用watch模式编译主进程脚本, 监听输出并打印.</li><li>检测主进程和preload变化, 在编译成功后重启electron进程.</li><li>编译主进程时用插件拦截渲染进程的引入, 并把地址指向localhost的指定端口.</li><li>编译主进程时用插件拦截preload的引入, 把引入方式改成文件, 并编译ts作为文件内容.</li></ol><h3 id="打包时"><a href="#打包时" class="headerlink" title="打包时"></a>打包时</h3><p>参考代码<a href="https://github.com/cwj0417/schedule-pro/blob/main/scripts/run-build.js">在这里</a>. esbuild的插件细节在上篇文章中.</p><ol><li>打包渲染进程的页面.</li><li>打包主进程脚本.</li><li>编译主进程时用插件拦截渲染进程的引入, 并把地址指向打完包后的资源地址.</li><li>编译主进程时用插件拦截preload的引入, 手动编译ts并写到文件夹中, 再让引导主进程加载文件.</li><li>复制package.json.</li><li>electron打包.</li></ol><h2 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h2><p>这样下来, 整个流程就都通了, 但是离完整流程明显还差一些东西, 之后再完善.</p><ol><li>判断dev环境来进行不同的操作, 比如打开调试工具.</li><li>完善调试工具和日志.</li><li>编写ts定义, preload和renderer的引入都是自定义, 目前ts划红线.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron开发模式中替换url实践</title>
      <link href="/2021/05/12/the-practice-of-replacing-url-in-electron-development/"/>
      <url>/2021/05/12/the-practice-of-replacing-url-in-electron-development/</url>
      
        <content type="html"><![CDATA[<p>在开发流程中, 会遇到根据环境判断url的问题, 像这样的代码(真实代码):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winURL = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span></span><br><span class="line">    ? <span class="string">`http://localhost:9080`</span></span><br><span class="line">    : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br></pre></td></tr></table></figure><p>这次深入这个问题, 来发掘一些更好的实践.</p><span id="more"></span><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>这种写法的优点是不需要多思考, 节约工时. 那么一个东西有优点, 就有缺点, 列举一下:</p><ul><li>写起来麻烦和难看.</li><li>在浏览器环境会依赖打包工具处理<code>process</code>.</li><li>如果端口被占用, 会导致一系列意外的错误.</li><li>如果引入另一个url, 就需要再写一次一样的代码.</li></ul><p>我的问题发生在electron的主进程里, 在这个场景中, 起了主进程后不能像浏览器改个端口那么方便, 需要杀了重启, 也不存在host, 可以使用相对路径来避免问题.</p><p>所以解决这个问题就成了很必要的事, 并且从可能性来看, <strong>本质是引用了同一个url, 获得的内容也是相同的, 理论上业务代码引入同一个url就可以了.</strong> </p><p><strong>而这种写法的本质就是把工程化代码写到了业务代码里.</strong> </p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>目标是: 在业务代码里只需要普通引入, 达到dev和build无感. 类似于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mainHtml <span class="keyword">from</span> <span class="string">&#x27;@/renderer/index.html&#x27;</span></span><br><span class="line"><span class="comment">// mainHtml在dev和build环境里获取到对应期望的值:</span></span><br><span class="line"><span class="comment">// dev: http://localhost:端口/index.html</span></span><br><span class="line"><span class="comment">// build: file://路径/index.html</span></span><br></pre></td></tr></table></figure><p>所以方案是:</p><ol><li>build时拦截特定路径, 根据环境返回期望的资源.</li><li>在dev时先检测端口再设置拦截返回值.</li><li>在build时正确获取地址.</li></ol><p>在遇到问题的项目中用的是esbuild打包, 下面进入解决问题具体步骤.</p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h3><p>从几个方面介绍下esbuild.</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p> 快. 官网说打包three.js主流的打包工具分别耗时36秒~118秒, esbuild只要0.4秒.</p><p>用go写, 处理ts比tsc官方快, 处理es比babel快.</p><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>vite, snowpack都在使用esbuild. 但因为功能不完善, 生产环境没有使用, 在开发过程和压缩代码的时候替换现在的主流工具.</p><h4 id="api"><a href="#api" class="headerlink" title="api"></a>api</h4><p>api有三种方式, 命令行, js api, go.</p><p>api有2个, <code>transform</code>和<code>build</code>. </p><p><code>transform</code>处理字符串, 一般用于浏览器和作为别的工具的插件.</p><p><code>build</code>处理文件系统, 也允许把文件里的引入也bundle到一块.</p><p>那自然地, 我们这里就使用<code>build</code>的js api.</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>esbuild有许多和webpack, rollup类似的概念如: entry, out, format, target, loader, plugin 等.</p><p>这里就介绍几个用到的option.</p><ul><li>entryPoints: 入口. 这里直接指到我们需要处理的文件就行了.</li><li>outfile: 结果存放的文件.</li><li>bundle: 要设为true, 如果为false就会不去resolve引入的其他模块.</li><li>platform: 这里填node. 这个项目的打包结果是在node运行的, esbuild会把结果打成cjs.</li><li>external: 希望打包结果里直接require, 运行的时候node有能力去resolve的模块. 填写以后esbuild就不会去处理这些模块. 这里要填的内容是<strong>node可以resolve的模块</strong>, 那就有2个部分, 分别是项目的node_modules和全局的node_modules和node api. node api在platform设为node的时候会默认添加.</li><li>plugin与loader: 解决这个问题的主要功能.</li></ul><h3 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h3><p>再次明确目标:</p><p>我们要将输入<code>import mainHtml from &#39;@/renderer/index.html&#39;</code> 分别输出为<code>http://localhost:端口/index.html</code> 与 <code>file://路径/index.html</code>.</p><p>esbuild的loader和plugin概念与webpack不同. <strong>我的理解是: esbuild的plugin+loader功能等于webpack的loader. webpack的plugin是可以获取ast的, 而esbuild不提供这个功能</strong>.</p><ul><li>esbuild的plugin的resolve像webpack的test. 在解析新模块时正则匹配来决定命中哪个plugin.进入plugin以后, 可以获取正在操作的模块信息. 进行操作后返回内容和loader.</li><li>esbuild的loader是指esbuild如何解析当前的内容. 只有一系列内置的loader.</li></ul><p>在plugin的onLoad方法里返回了loader和loader去处理的内容就可以达到目的.</p><h3 id="处理开发环境"><a href="#处理开发环境" class="headerlink" title="处理开发环境"></a>处理开发环境</h3><p>开发环境的目标是: <code>http://localhost:端口/index.html</code>.</p><p>这里loader直接用<code>text</code>就可以, 2个变量. <code>index.html</code>直接读模块内容可以获取.</p><p>而端口需要用<code>detect-port</code>来探测未被占用的端口(这个lib是从cra里找到的, 被很多著名lib使用着), 再将这个未被占用的端口分别传入vite里和esbuild的build脚本里就行了.</p><h3 id="build环境处理"><a href="#build环境处理" class="headerlink" title="build环境处理"></a>build环境处理</h3><p>buidl环境的目标是: <code>file://路径/index.html</code>.</p><p>这里的难点是, 要获取到打成生产包以后的文件地址. 于是用了<code>pathToFileURL</code>这个node api.</p><p>注意是打成生产包以后的文件地址, 所以不能在build时运行. 所以选用了<code>js</code>loader. 把我们准备的变量拼接成cjs的字符串, 指定loader为<code>js</code>就搞定了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> esbuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识整理</title>
      <link href="/2021/02/24/fe-knowledge-listing/"/>
      <url>/2021/02/24/fe-knowledge-listing/</url>
      
        <content type="html"><![CDATA[<p>前端知识整理一波, 会则复习不会则补.</p><span id="more"></span><h2 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h2><p>这里打算整理狭义上的前端内容: 基于html, css, js的前端. 而在这三者间有交叉的技术和生态和衍生, 还有靠近的服务端相关的知识.</p><ul><li><p><strong>html</strong>指在浏览器上运行的页面. 所以知识点包含浏览器的相关行为:</p><ul><li>http相关, 请求的类型, 缓存, 跨域.</li><li>浏览器渲染html相关: 加载顺序, 绘制&#x2F;重绘机制.</li><li>dom, bom相关: 浏览器提供的api, event loop和渲染的关系.</li></ul></li><li><p><strong>css</strong>的知识我认为分2块, 第一是对css系统的认识, 不同的块流, 文本流, 布局等. 第二是零碎的情况的知识. 至于前沿的css语法我认为不属于基础也不那么重要. 预编译的css算是个类似语法, 预编译的过程其实属于工程化.</p></li><li><p><strong>类html,css</strong>第一个想到的是小程序. 是一系列其实不是html和css但模拟语法让干前端的人能做的事.</p></li><li><p>涉及到node服务端的常用点有开发时服务器, ssr, 前后端分离解决跨域的转发服务器.</p></li><li><p>语言<strong>javascript</strong>. 虽然ts是js的超集, 但我还是把它归类为js. 语言的范畴是数据类型, 作用域&#x2F;闭包, 原型链, 数据结构, 算法等. 不包含bom, dom相关的api和特性.</p></li><li><p><strong>工程化</strong>包含webpack, babel, 到部署运维. </p><ul><li>ts, jsx, es+, vue文件都是不能直接在浏览器上抛的, 就必须用到编译器.</li><li>代码的压缩, 复用代码的组织必须用打包工具. 开发的时候也需要用开发工具而不像以前保存刷新. </li><li>部署运维更偏向于每个公司内部的部落规则, 但也有一些微前端框架.</li></ul><p>以上各个工具化现在主流的webpack, rollup, vite的使用和区别. 还有零散和过时的工具grant, gulp, parcel, snowpack, yoemen(vscode在用)啥的. 工具的区别是基于不同的打包目标, js不同模块引入方式(amd, cmd, umd, esm).</p></li><li><p>框架我只用过vue2和react. 框架的了解分2个方向, api和源码. 其实在效用上两者重要程度说不清高地, 但现在一般的标准是: api是默认全懂, 源码才可聊.</p><p>当然也只有读了源码才知道框架的原理. 源码阅读也分2个方向, 主流程和细节. 我建议先流程后细节的. 而最佳方式是带问题读.</p></li><li><p><strong>优化</strong>, 无论是html, 首屏, webpack速度, 框架, 数据结构. 本质都是使行为更合理, 减少浪费. 所以优化本身不能作为一个知识点, 而是一个话题. 想优化就要去理解和深入各个知识点本身.</p></li></ul><p>另外**<a href="https://github.com/cwj0417/sxdm">手写代码合集</a>直接在github上**.</p><p>那么接下来就(不太全面地)分模块, 复习一些基础问题. </p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="作用域与this"><a href="#作用域与this" class="headerlink" title="作用域与this"></a>作用域与this</h3><p>函数的执行有执行栈, 栈底是全局作用域, 执行的时候创建作用域并入栈, 执行完毕出栈.</p><p>在创建作用域的时候:</p><ul><li><p>决定this的值: 谁调用this就是谁. (箭头函数找上一层)</p></li><li><p>决定环境中变量的实际地址. (非全局作用域多一个arguments, 全局的多一些原形函数)</p><p>变量提升的原因是: var被当做变量处理, let和const被当做词法处理.</p></li><li><p>决定外部引用环境. (作用域栈的下一个, 变量找不到会去这里找) 全局的外部环境是null</p></li></ul><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>执行栈是函数执行而来的, event loop是决定函数执行顺序的, 也决定了ui渲染和各个来源函数执行的顺序.</p><p>浏览器中除了promise是微任务, 其余全是宏任务, 包用户输入, setTimout, callback.</p><p>宏任务有多个队列, 微任务只有一个队列. 表现为无论在执行宏任务还是微任务, 执行完都会检查微任务队列.</p><p>所以如果有比较难分辨的情况, 我认为难点在于要理解: <strong>宏任务有多个队列</strong>. 要分清那几个任务是在同一个队列里的. 这里贴一个题目.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器开始啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;马上执行for循环啦&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行then函数啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><p>原型: <strong>__proto__</strong> 属性是个accessor属性, 实际是Object.getPropertyOf和Object.setPropertyOf.</p></li><li><p>隐式操作: 平时的字面量对象, <code>.</code>操作取值, 赋值. 实际都有隐式操作. 取值会往__proto__找, 赋值如果当前变量没就创建. </p><p>字面量创建的对象有默认__proto__, 并不是空对象. 用es6省略value会创建null为原型的对象.</p></li><li><p>构造函数: 所有函数都会被挂上prototype属性. 这个属性会在被new的时候作为实例的__proto__. 内容是: {constructor: 自己, <strong>__proto__</strong>: Object.prototype}, 在继承的时候__proto__是父对象的constructor, 构造函数的__proto__也是父对象的构造函数.</p></li><li><p>class的extends&#x2F;寄生组合式继承: 子类的__proto__的父类, 子类的prototype的__proto__是父类的prototype.</p></li><li><p>一些基本对象(Object, Array, Function等)的关系可以自己用__proto__和&#x3D;&#x3D;&#x3D;和instanceof去画关系.</p></li></ul><h3 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h3><p>ts这个标题太大, 而且特性&#x2F;配置都是跟版本的. 就列一些点.</p><ul><li>keyof: 对象的结果是键的联合类型, 数组是number|数组方法的联合类型, any是string|number|symbol</li><li>infer. extends一个泛型接口时需要临时定义的泛型名字.</li><li>工具类Partial, Record, Pick, Exclude, ReturnType的实现.</li><li>interface和type的区别: 语法&#x2F;implements&#x2F;联合类型&#x2F;extends.</li><li>ts特性: 只检查结构, narrow down, 类型之间有包含关系.</li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC是一个布局环境, 有一定的规律, BFC内部可以嵌套另外独立的BFC.</p><p>BFC里的盒子按照常规流从上到下排布, 可能出现margin重叠(这个问题可以用嵌套个新BFC解决).</p><p>跟元素就是个BFC, 创建独立BFC的条件是float, position, overflow, flex等.</p><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>标准盒子是content-box, IE盒子是border-box. IE盒模型的width多包含了padding和border.</p><p>其实设计图的尺寸一般是IE盒模型写起来比较方便.</p><h3 id="z轴顺序"><a href="#z轴顺序" class="headerlink" title="z轴顺序"></a>z轴顺序</h3><p>从下到上如下图, 注意的是层叠上下文也是上下文, 也BFC一样有嵌套.</p><ol><li>background&#x2F;border</li><li>z-index负值</li><li>块元素</li><li>浮动元素</li><li>行内元素</li><li>z-index: 0, auto</li><li>z-index正值</li></ol><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><ol><li>从配置文件和命令行参数读取并merge得到配置.</li><li>用loader读取资源, 然后收集依赖关系, 分析成ast.</li><li>组装成chunk, 输出.</li></ol><h3 id="loader和plugin"><a href="#loader和plugin" class="headerlink" title="loader和plugin"></a>loader和plugin</h3><p>loader用来读取不同文件, 是一个函数, 接受参数为文件字符串, 输出js或能被下个loader读取的格式. (估计是用compose来组合的, 所以是从右到左.)</p><p>plugin是通过tapable的发布&#x2F;订阅系统, 在编译执行的不同步骤会调用不同钩子, 主进程compile, 每个模块的进程compilation. 写法是一个class并含有指定的方法.</p><p>自定义loader和plugin的使用还是比较有意思, 比如可以loader给代码加全局catch并发送错误报告给后端.</p><h3 id="tree-shaking和scope-hoisting"><a href="#tree-shaking和scope-hoisting" class="headerlink" title="tree-shaking和scope-hoisting"></a>tree-shaking和scope-hoisting</h3><p>在webpack5(可能从4开始)后, production模式是直接开启的, 要求都是纯esm输入.</p><p>执行的时间是编译形成ast后, 分析并改变依赖树.</p><p>区别: tree-shaking是和”是否被引用到”有关, scope-hoisting是和”代码是否可以简化”有关.</p><h3 id="和rollup的区别"><a href="#和rollup的区别" class="headerlink" title="和rollup的区别"></a>和rollup的区别</h3><p>rollup功能少所以配置少, 适合打纯js.</p><p>webpack系统比较复杂, 可以打任何品种的文件(css, 图片, 字体, .vue, 任何), 因为loader.</p><p>但是webpack不能打出esm包, 所以打算发到npm上给别人用的尽量rollup打.</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>优化的本质是让事情更合理, 所以一般通过3个点.</p><ul><li>把工具(webpack)升级到更高版本, 让专业的人为自己做事.</li><li>用各种插件, 也是让专业的人为自己做事. (然后合理的插件会被加入默认配置)</li><li>自己代码写好点, 根据自己的需求减少不必要的配置. (这个是可以通过了解webpack来做到的事)</li></ul><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><p>babel的流程和webpack类似. 读取配置&#x2F;插件, 代码转ast, 根据配置输出.</p><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>其实优化包含的方面特别多, 而不是什么优化都去做的, 实际场景中优化其实出于2个场景: 第一有地方明显卡顿要求优化, 第二系统性优化. 但其实核心思路都是: 找出最卡的点. 找出的方式第一步是肉眼, 第二部是调试工具.</p><p>优化除了一些工具, 代码写得好也非常重要, 好的lib作者写代码还会考虑到是不是能被tree-shaking和单元测试覆盖. 以下说的是代码之外的一些东西.</p><h3 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h3><p>webpack优化包含prod和dev阶段. </p><p>prod阶段目标是减少包体积(tree-shaking和scope-hoisting)和code spliting(为首屏).</p><p>dev优化是目标是加快编译流程, 配置hmr.</p><p>还有一些根据项目通用的优化, webpack默认配置范围比较大, 而项目一般会narrow一些.</p><p>比如配置alias, 项目只有ts文件, 就配上对应的alias. 配置includes&#x2F;excludes, mainFields.</p><h3 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h3><p>首屏优化有2个角度, 网络级别, 代码级别.</p><p>我们先关注代码级别的, 代码级别优化的本质: <strong>先只加载用户一眼看到的东西.</strong></p><p>所以方法有: 用webpack的动态import(框架的router有做), 图片懒加载, 虚拟表格(有不可搜索这个缺点), 先加载skeleton.</p><p>动态垫片减少不必要的垫片.</p><p>首屏ssr也能提升性能和seo, 但是成本较高, 还要做slb和监控.</p><h2 id="web渲染流程"><a href="#web渲染流程" class="headerlink" title="web渲染流程"></a>web渲染流程</h2><h3 id="“输入url到页面展示”"><a href="#“输入url到页面展示”" class="headerlink" title="“输入url到页面展示”"></a>“输入url到页面展示”</h3><p>解析dns &#x3D;&gt; 通过tcp建立http连接 &#x3D;&gt; 发起请求 &#x3D;&gt; 接受数据 &#x3D;&gt; 断开http连接 &#x3D;&gt; 渲染页面</p><p>各个点都可以展开很多, 这里整理一下我认为和其他知识对应的深度.</p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>在网络模型中, http协议属于应用层(5或7), 下层的传输层(4)是tcp协议, 网络层(3)是ip协议.</p><p>建立连接和断开连接都用tcp进行, 就是传说中的三次握手四次挥手.(断开的过程第三次挥手是服务端发起的).</p><p>http1.1默认开启了keep-alive(默认头), 作用是减少建立和断开连接发送的tcp请求. 而是不是支持得看服务器, 协议两端的交互就像打电话的2个人.</p><h3 id="渲染网页"><a href="#渲染网页" class="headerlink" title="渲染网页"></a>渲染网页</h3><p>浏览器渲染网页总体有几步, 但不同浏览器实现其实不同.</p><ol><li>把html parse成dom树.</li><li>把css parse成样式树.</li><li>通过以上2树, 构造呈现树. dom树和呈现树结构并不相同, 有些标签(head, meta, display为none等)不显示, 而有些标签(select, title属性等)会产生多个呈现树.</li><li>通过呈现树计算, 布局. </li><li>绘制.</li></ol><p>然后在元素发生变化后分为部分渲染. 其实前端理解以后能做的优化就是: 减少渲染次数, 而这个事情框架里都做了.</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="什么情况会发生跨域"><a href="#什么情况会发生跨域" class="headerlink" title="什么情况会发生跨域"></a>什么情况会发生跨域</h4><p> 协议, 端口, host(任意级)只要有一个不同就<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">跨域</a>.</p><h4 id="什么请求会发生跨域"><a href="#什么请求会发生跨域" class="headerlink" title="什么请求会发生跨域"></a>什么请求会发生跨域</h4><ul><li>js发起的请求. (通过XMLHttpRequest和fetch)</li><li>字体.</li><li>WebGL texture.</li><li>canvas通过drawImage画的image或者video. (会把canvas变成被污染的状态, 不能toDataUri了)</li><li>css里的<code>url()</code>.</li></ul><h4 id="如何让跨域请求顺利"><a href="#如何让跨域请求顺利" class="headerlink" title="如何让跨域请求顺利"></a>如何让跨域请求顺利</h4><p>设头, 请求端和服务端都要设. 都是Access-Control-开头的.</p><p>如果要带上cookie, 加个头withCredentials: true.</p><h4 id="preflight请求和简单请求"><a href="#preflight请求和简单请求" class="headerlink" title="preflight请求和简单请求"></a>preflight请求和简单请求</h4><p>在发起非<code>简单请求</code>的跨域请求前, 浏览器会发起preflight请求, method是options, 来确认是否支持即将进行的请求.</p><p><code>简单请求</code>的条件比较复杂, 要同时满足: </p><ul><li>method是get, post, post之一</li><li>只能手动设某几个请求头: Accept, Accept-language, Content-language, Content-type.</li><li>Content-type只允许几个值: text&#x2F;plain, multipart&#x2F;form-data, application&#x2F;x-www-form-urlencoded.</li><li>XMLHttpRequest发起的请求不能监听upload事件.</li><li>请求中没有ReadableStream.</li></ul><p>这些要求正常人是背不出的, 所以只要基础<strong>简单请求是幂等请求</strong>, 非简单请求是会对服务器数据造成改动的.</p><h4 id="额外的解决方式"><a href="#额外的解决方式" class="headerlink" title="额外的解决方式"></a>额外的解决方式</h4><p>几个通常的非正常解决方案:</p><ul><li>jsonp. 通过非<code>会发生跨域的请求方式</code>(上面提到的)来发起跨域的请求, 比如append script.</li><li>前端服务器转发. 这个通常是下属地, 带配置host功能的转发服务器.</li><li>网关转发.</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存就是根据一些头信息, 来决定是否可以用本地缓存数据来替代发起一次新http请求. 浏览器http缓存分2种:</p><ul><li>强缓存: 通过expires, cache-control等头, 如命中, 直接用缓存, 状态码200, (from disk cache).</li><li>协商缓存: 通过last-modified, e-tag, if-none-match来判断, 请求会发出, 如命中, 服务器不传输内容, 返回状态码304来使用缓存.</li></ul><h3 id="事件流和事件委托"><a href="#事件流和事件委托" class="headerlink" title="事件流和事件委托"></a>事件流和事件委托</h3><p>事件流从document流向目标, 再流向document.</p><p>addEventListener最后一个参数可以调整从哪个角度获取事件.</p><p>stopProgration和preventDefault能组织捕捉&#x2F;冒泡.</p><p>事件委托指, 要给一系列子元素增加事件, 就给他的父元素增加事件, 然后通过event的字段来判断是哪个子元素.</p><p>事件委托的原理是利用事件冒泡, 优点是不用重复注册, 以及子节点变化的情况无须重新注册.</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>cross-site scripting, 通过给html输入脚本来攻击, 防止的思路是: 要放到html上的输入要小心. 处理方法就是转义. 一般容易攻击的输入有: url, cookie, 输入框. 总之不要相信用户输入.</p><h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>cross-site request forgery, 在被攻击网站登录状态下, 第三方网站向被攻击网站发起请求, 这样会带着身份信息. 通过不接受跨域请求来防范.</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>vue和react后续再看.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> immer </tag>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> react </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较vue2和vue3的响应式</title>
      <link href="/2021/02/01/difference-of-reactivity-between-vue2-and-vue3/"/>
      <url>/2021/02/01/difference-of-reactivity-between-vue2-and-vue3/</url>
      
        <content type="html"><![CDATA[<p>前一阵写了一个<a href="https://github.com/cwj0417/reactive-mini">最简单版本的vue响应式</a>, 比较了下vue2和vue3响应式系统, 并做一下总结.</p><span id="more"></span><h2 id="粗略总览"><a href="#粗略总览" class="headerlink" title="粗略总览"></a>粗略总览</h2><p>为什么要开发vue3, 尤总说了很多原因, vdom性能(重写算法), 响应式性能(proxy), 打包体积(treeshaking), 开发者体验(切换ts), 难解决的issue(独立实例).</p><p>为了更深刻理解开发vue3, 我尝试从最简单的模块深入, 分析下两个版本的区别.</p><h3 id="相似的点"><a href="#相似的点" class="headerlink" title="相似的点"></a>相似的点</h3><p>vue2和vue3的总体结构是不变的, 都是有三大模块组成: compiler, reactivity, renderer. compiler把各种输入编译成ast, 再由renderer把ast渲染到dom上. reactivity检测数据变化, 再去调用compiler和renderer更新视图.</p><p>react和vue的本质区别就在于vue有reactivity系统, 我猜想react和vue有对应的概念, 之后熟悉react以后再回来和vue的整体做一下对比.</p><p>本文关注的重点, reactivity模块, vue2和vue3的基本思路也是相同的: <strong>拦截数据的改变, 触发对应的操作.</strong> 更详细地说, 触发了什么操作? 触发的操作是在做初始化的时候按需注册的.</p><h3 id="调用响应式的入口"><a href="#调用响应式的入口" class="headerlink" title="调用响应式的入口"></a>调用响应式的入口</h3><p>vue2和vue3调用响应式系统的点也是相同的.</p><p>vue2reactivity的入口是<code>new Watcher()</code>, 在构造时注册编译渲染动作, 调用的地方一共有三处:</p><ol><li><p><code>mountComponent</code>, 调用<code>$mount()</code>的时候.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>()), noop, <span class="literal">null</span>, <span class="literal">true</span>))</span><br></pre></td></tr></table></figure></li><li><p>初始化computed的时候:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">  vm,</span><br><span class="line">  getter || noop,</span><br><span class="line">  noop,</span><br><span class="line">  computedWatcherOptions</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>$watch()</code> 中调用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, expOrFn, cb, options)</span><br></pre></td></tr></table></figure></li></ol><p>vue3reactivity的入口是<code>effect()</code>, <code>effect()</code>执行的时候会建立监察关系. 直接调用的地方也有3处:</p><ol><li><p><code>setupRenderEffect()</code>的时候调用, 同样用于触发渲染, 但调用<code>setupRenderEffect()</code>的地方就比vue2复杂多了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 此处省略180行代码, 为啥不抽方法也得以后继续深入才知道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册computed时的构造方法里, 我们还能看出<code>effect()</code>有很多options:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">effect</span> = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">  <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">trigger</span>(<span class="title function_">toRaw</span>(<span class="variable language_">this</span>), <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>watch api:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runner = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">  <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">  onTrack,</span><br><span class="line">  onTrigger,</span><br><span class="line">  scheduler</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="细看区别"><a href="#细看区别" class="headerlink" title="细看区别"></a>细看区别</h2><p>虽然有这么多相同的, 但是从api也看出来有许多不同点. 很容易第一反应想到的区别:</p><ol><li>api的名字不同了. 作者说只是换了语态.</li><li>class变成function, 使用了set, map. 作者说只是更新了语法, 也更贴近实际意义.</li><li>flow切换到ts. ts现在变成主流, 更多开发者使用ts环境(vscode), 用ts写可以让大部分开发者体验更好. (浅层次理解)</li><li>Object.defineProperty切换到Proxy. 减少了对浏览器的支持, 增加捕捉get set操作, 提升性能.</li></ol><p>这些都是第一层比较浅的区别. 下面我们深入一些, 看一下第二层的区别有哪些.</p><h3 id="没有callback的effect"><a href="#没有callback的effect" class="headerlink" title="没有callback的effect"></a>没有callback的effect</h3><p>上面的例子可以看出, (至少我认为)vue3的<code>effect</code>和vue2的<code>new Watcher()</code>是对应的. 但实际上vue3是有watch api, 并且<code>effect</code>没有callback, 而vue2的<code>Watcher</code>有.</p><p>故事要从vue2的mountComponent说起.</p><p>vue2是通过<code>observe()</code>处理数据, <code>new Watcher()</code>注册事件的, 而在注册”生成ast并渲染dom”事件的时候发现, 不需要callback, <strong>callback的参数本身就需要调用一次getter作为callback的参数, ballback也必须依赖getter才有实际意义</strong>, 所以也许尤总感觉到了, <strong>在这种拦截数据的情况下, 带有响应式数据的操作更像是一种side effect</strong>, 所以把这种行为命名为<code>effect</code>, 并且延伸出了其他的方法名.</p><p>我们把<code>effect</code>近似理解为没有callback的<code>new Watcher()</code>, 可以做以下比较:</p><table><thead><tr><th></th><th>创建时调用</th><th>触发时调用</th></tr></thead><tbody><tr><td>new Watcher()</td><td>expression</td><td>expression, callback</td></tr><tr><td>effect()</td><td>expression+callback</td><td>expression+callback</td></tr></tbody></table><p>我们来做2种尝试, 分别用一个模式的参数去实现另一个模式:</p><ol><li><code>new Watcher(expression, callback)</code>, 转换成<code>effect(() =&gt; callback(expression))</code>, 区别是effect第一次执行的时候也会触发一次callback.</li><li><code>effect(() =&gt; someEffect())</code>, 我们就会发现, 无法把expression从someEffect中剥离出来. 如果要举例, 那就是vue2中mountComponent的情况. (数据藏在<code>vm._render()</code>生成的ast里, 很难自动抽离出来, 也没必要)</li></ol><p><strong>小小的总结: vue3的effect概念, 可能是更接近”数据触发行为”这种模式的描述.</strong></p><p>那么vue3中的watch api的实现, 是通过<code>effect</code>的options<code>scheduler</code>来实现的. 这里先不再深入了.</p><h3 id="监察关系存放的位置"><a href="#监察关系存放的位置" class="headerlink" title="监察关系存放的位置"></a>监察关系存放的位置</h3><p>vue3很简单, 所有的effect都被存在一个全局weakMap里, <strong>不同的vue实例的effect也会被存在同一个weakMap里</strong>, 已验证. 以<code>&#123;target -&gt; key -&gt; dep&#125;</code>的格式存着, 在trigger的时候根据target, key去取到然后执行.</p><p>而vue2把需要运行的函数都放在Dep对象里, 存到闭包里了,  <strong>其实vue3可以这样优化是因为weakMap.</strong></p><p>而vue2更有问题的是, 每个也许touch不到的对象属性, 都会建立一个闭包, 比可见的<code>.__ob__</code>更多. vue3的优化是基于Proxy的.</p><h3 id="Proxy和Object-defineProperty"><a href="#Proxy和Object-defineProperty" class="headerlink" title="Proxy和Object.defineProperty"></a>Proxy和Object.defineProperty</h3><p>Proxy相对于Object.defineProperty的优点之一是, 他是”懒”的(暂时想不到更好的描述): Proxy的拦截是在对象发生操作时才对应执行的, 而Object.definProperty需要遍历对象, 改写getter&#x2F;setter, 把操作都存在闭包里.</p><p>之前介绍的immer也是同样的Proxy受益者, immer只在对象被修改的时候才创建新地址, 而深浅拷贝都会为其他根本不会改动的叶子节点创建新地址, <strong>Proxy的性能优势在对象树大的时候表现得更明显</strong>, 这个适用于vue3和immer.</p><p>我们来看一下vue2的响应式在哪些地方会存闭包:</p><ul><li>getter, setter. 对象的值改变后需要触发的. 闭包是<code>defineReactive</code>生成的</li><li>每个对象下挂着的<code>__ob__</code>对象. 这个是拦截数组方法后调用的handler. 闭包是<code>new Observer()</code>生成的</li></ul><p>(另外, set和delete是需要主动调用的.)</p><p>每个对象自带一个闭包, 一个键又加一个, 键的值是下一层的递归. <strong>每个闭包都存着当前值和注册要触发的事件.</strong> 并且不管有没有被touch到的机会, 所有对象都会被遍历加上这些东西. 所以vue2要注意, 不要把后端返回实体的所有东西都放到数据里.</p><p>而Proxy还产生一个问题, 开发过程中console打印的问题, immer提供了api, vue3也设了个key<code>__v_raw</code>来获取target.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>react不常用功能补漏</title>
      <link href="/2021/01/04/react-rarely-used-apis/"/>
      <url>/2021/01/04/react-rarely-used-apis/</url>
      
        <content type="html"><![CDATA[<p>前一阵过了一遍react文档, 记录看到的几个不太常用api.</p><span id="more"></span><h2 id="pure-component与should-component-update"><a href="#pure-component与should-component-update" class="headerlink" title="pure component与should component update"></a>pure component与should component update</h2><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent其实就对应着pure function. (是我这次才恍然大悟的)</p><p>也就是初中第一次学到函数的概念: y &#x3D; f(x), 一个x永远对应一个y.</p><p>这里PureComponent的输入是state和props, 输出是dom. 只要相同的state和props永远对应相同的dom, 就可以设置为PureComponent.</p><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>PureComponent在进一层的实现上是shouldComponentUpdate(scu)的封装, 在scu的时候对上次的state和props作了浅比较. 如果浅比较结果相同会阻止即将进行的渲染.</p><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">文档里的图表</a>很清晰地说明, props和state的变化会触发scu, 如果scu返回false就不走render了.</p><p>文档看到这里, 我问了同事, 是不是大多数组件都可以改成PureComponent. 同事扔给了我一个链接, 那个链接我没有记, 自己写了个<a href="https://github.com/cwj0417/react-side-effect-test/blob/main/src/stateCounter.jsx#L17">类似的demo</a>. 这个demo把Component改成PureComponent就会出现bug.</p><h2 id="mutate-state与pure-component"><a href="#mutate-state与pure-component" class="headerlink" title="mutate state与pure component"></a>mutate state与pure component</h2><p>因为demo中的setState是这样写的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">counter</span> += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>react的state是要求immutable的. 比较初级的程序员经常会犯的这个错误.</p><p>但被问到mutate state有何不可, 我一般说有2个问题, 第一不可测试. 第二导致的奇怪bug很难debug.</p><p>这里就发现了个mutate state导致的bug.</p><p>因为直接改动了原state的属性, 在scu的时候, 新state和原state中变化的那个值是指向同一个地址的, 就导致了scu误判返回了false阻止render.</p><p>还是得写成immutable的形式来避免这个bug:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: state.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="react-redux的connect与mutate-state"><a href="#react-redux的connect与mutate-state" class="headerlink" title="react-redux的connect与mutate state"></a>react-redux的connect与mutate state</h2><p>而我们大多项目是用redux的, 碰巧redux也是immutable的设计. 于是写了个<a href="https://github.com/cwj0417/react-side-effect-test/blob/main/src/counter.jsx">demo</a>来试一下<code>react-redux</code>的<code>connect()</code>方法有没有做类似的优化.</p><p>于是又巧了. <code>connect()</code>内部也用了浅比较来优化. 于是产生了和上一节一样的问题, 解决方案也相同, 就不赘述了.</p><p>再挖了一下<code>connect()</code>, 发现第四个参数可以传参数的, 在<a href="https://github.com/cwj0417/react-side-effect-test/blob/main/src/counter.jsx#L57">demo的第57行</a>这个属性设置为<code>===</code>就可以在mutate state的情况下得到期望的结果了. (默认值是浅比较)</p><h2 id="get-derrived-state-from-props与受控组件"><a href="#get-derrived-state-from-props与受控组件" class="headerlink" title="get derrived state from props与受控组件"></a>get derrived state from props与受控组件</h2><p>当组件实现了getDerrivedStateFromProps, state和props就有了一层绑定关系. 在不判断条件的情况下, 一个普通的组件就会从非受控组件变成受控组件.</p><p>在对受控&#x2F;非受控组件概念不请的时候, 就会在这里写不合适的代码, 而造成非期望的bug和不可测试.</p><p>在我不理解受控&#x2F;非受控组件前, 在看到一些ui库的表单组件和表格组件的selected相关api会觉得反人性设计.</p><p>(具体案例不提了太基础了)</p><h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>render props的定义是: 调用props的函数作为render返回的一部分.</p><p>所以render props的使用方会感觉: 使一个prop返回jsx元素, render props的构造组件会感受: render的返回值中包含了props的调用.</p><p>render props其实不一定要叫render, 也可以是其他的. 于是想到了一个奇妙的元素: children. children可以直接写在标签中, 就想到了之前使用的<code>AutoSizer</code>原来是用了render props.</p><h2 id="react的特点-与vue比较"><a href="#react的特点-与vue比较" class="headerlink" title="react的特点(与vue比较)"></a>react的特点(与vue比较)</h2><p>react三大抽组件方式, rp, hoc, hooks, 让人感觉最明显的是: react的组件就是一个函数(vue使用组件还需要注册, 很明显能感受到). react能更灵活的运用js的特性, rp, hoc, hooks其实都不是react特性, 而是js特性.</p><p>另外, <strong>react的使用者要自己做优化, 或者说是遵循一定规范.</strong> 不然会导致预期外的bug和性能损耗, 而vue帮用户做了优化. (但自动优化本身是耗性能的)</p><p>这里说一点经验中总结的规范, <strong>要把不同更新频率的页面部分分成不同的组件, 并用scu阻断渲染树.</strong> 这个在用redux connect的时候也要注意, 不要用点点点引入页面不相关的数据.</p><p>原因是: react的render方法只能整体执行. (vue的render方法只是生成ast, 下一步还会patch. 而react???). 下面举一个具体例子:</p><p>组件A 包含 组件B, 组件C. B, C分别依赖A的state.</p><p>当setState改变C依赖的state时, B也会被重新渲染.</p><p>所以方法是: 用pureComponent把B包起来, 这也是为什么ui组件库会尽量用pureComponent.</p><h2 id="插件互用"><a href="#插件互用" class="headerlink" title="插件互用"></a>插件互用</h2><p>react跨组件的状态管理有redux, mobx, hox, recoil等. 而如果只是传递一个事件, 其实并不需要状态管理.</p><p>拿redux说, 其实dispatch就是直接操作reducer的. 而redux和react有关系的地方就是connect, 要通过redux传递事件只能去改变状态, 再监听props. 这显得非常不合理.</p><p>所以用Vue的event bus就可以, event bus就是一个闭包, 把组件存在闭包里, 在触发事件的时候调用就行了. 当然也自己写个30行的event bus.</p><p>反过来也是的, vue也可以用redux. 之前在小程序里用的时候对vue和react的理解还比较局限. 希望以后对js和框架的理解能更深刻.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命的意义</title>
      <link href="/2020/12/02/what-life-should-mean-to-you/"/>
      <url>/2020/12/02/what-life-should-mean-to-you/</url>
      
        <content type="html"><![CDATA[<p>这是一篇与之前都不同的读后感, 不按照书的脉络, 甚至对其中的意见有不同或补充, 结合了自己其他的想法的世界观快照.</p><span id="more"></span><p><a href="/2020/11/15/talk-about-our-being/">一个月前目睹了外公的离开</a>使我真正仔细思考了生命的意义是什么.</p><h2 id="虚无主义"><a href="#虚无主义" class="headerlink" title="虚无主义"></a>虚无主义</h2><p>&lt;寻梦环游记&gt;所说的, <strong>每个人, 终究会被所有人遗忘, 就像没有存在过一样.</strong> 让我很难过, 可仔细一想, 这还是太浅, 太童话了.</p><p>“被所有人遗忘”, “所有人”是谁, 甚至到某个时刻以后, 都没有”人”来&lt;忘记&gt;谁了.</p><p>我不能确定每个认同主流现代物理和科学的人都是虚无主义, 但主流的科学思想的推测确实大概率会有热寂.</p><ul><li>**生命的产生只是一个偶然, 世上并不一定要有生命的. **我长大至今, 好多次思考到”为什么会有这个世界, 而不是别的什么”而觉得极其恐怖, 发现只有想到亲人才勉强把我拉回真实世界(也许是虚拟世界, 那个恐怖的才是真实世界).</li><li><strong>世上的熵在不可逆的增加, 世界最终将变为混沌.</strong> 小时候读过的书&lt;时间简史&gt;有个margin, 建议你立刻停止阅读本书, 你的阅读正在加速宇宙的熵增, 当时还不理解只是好玩.</li></ul><p>总结来讲, 世界的基调是毁灭, 生命这种低熵的东西只是一个过程, 一切生命新生的时候就注定了要毁灭, 做的一切事情也没任何意义.</p><p>理解了这个以后, **我反而对之前很多事情释怀了, 比如担心亲人的死亡, 担心自己的死亡. ** 现在想开的是: 所有人都会死亡. 同样地, 谁活得好一点, 谁活得差一点, 都无所谓. </p><p>我原创了一个比喻, <strong>就像是牛奶倒进咖啡, 有很小的可能形成了一朵漂亮的花, 有的花美丽还存在时间长, 有的花不美且一会就失去了形状, 但最后都会消失, 而稳定成一杯拿铁.</strong> 生命像牛奶在咖啡中形成短暂的花, 再漂亮, 发展再好, 也是没有意义的, 起码对花来说是没意义的, 因为花的意义的基础是花的存在.</p><h2 id="现实意义"><a href="#现实意义" class="headerlink" title="现实意义"></a>现实意义</h2><p>牛奶倒进咖啡形成短暂的花是没有意义的, 起码对花本身是没意义的, 因为花的意义的基础是花的存在.</p><p>对了! 虽然生命可能一定会消逝, 但<strong>对生命自己来说, 也许自己的意义就是活下去</strong>吧!</p><p>真理是客观存在的, 虽然有客观存在的”绝对真理”, 但这个真理也许对于人类来说是没有意义的, 我们人类要找寻的, 其实只要是对人类有意义的”相对真理”就可以了吧.</p><p>有个段子说凯恩斯批评一些经济学专家理论说: 从长远来看, 我们都死了. 也证明了一点: <strong>我们人类本身是有很多限制的, 不忽略这些限制做的事才是有实际意义的</strong>. 在工作和学习中的实践看来也是如此, 能落地的理论才是有意义的. 设计网页要考虑设备性能和设备网速, 设计方案要考虑能不能落地.</p><p>所以对于我们的人生, 在自然毁灭前, 还是有意义的.</p><h2 id="活下去"><a href="#活下去" class="headerlink" title="活下去"></a>活下去</h2><p>现代科学研究的目的是类似的: 找到一个通用的公式来解释所有问题. 那么对于人类的有意义的意义的通用公式, 我们就猜想是: <strong>活下去</strong>. 猜测的原因是, 我们观察其他生命的深层目的也是活下去.</p><p>那活下去需要什么呢? </p><ol><li>呼吸, 吃喝, 住, 衣服.</li><li>繁衍.</li><li>探索环境, 获取真理, 以尝试获得永生.</li></ol><p>再深一步分析一下, 完成上面这些需求需要做什么事来落地.</p><p>在之前读<a href="/tags/%E8%B5%84%E6%9C%AC%E8%AE%BA/">资本论</a>的时候获得了一些结论: 物物交换到一定程度必然会出现货币, 货币的出现也伴随着社会分工. (另外货币交易到一定规模必然会出现资本.) 而社会分工是人类进步, 提高劳动效率的一个重要的成就.</p><p>所以在现在的社会里, 想要活下去, <strong>必须参与社会分工和货币交易</strong>, 说白话就是必须赚钱和花钱. 而参与社会分工的本质就是<strong>为社会做贡献</strong>, 贡献越大钱赚越多.</p><p>另外是繁衍, 分为两个点, 一是吸引异性, 二是与伴侣合作保证下一代的质量.</p><p>所以总结来说: <strong>人生的意义就是: 追求金钱, 权力, 美女, 真理.</strong> 这么看来最粗糙的也许是最真理的呢. 金钱&#x2F;权力保证生存(因为资源总是有限的, 让进化不好的得到淘汰是一种自然机制). 追求俊男美女获得后代的保障. 而在有钱有家势后, 就会追求永生和真理. (这一般在电影里和上个世纪的科学家)</p><h2 id="心理防御机制与人生意义的作用结果"><a href="#心理防御机制与人生意义的作用结果" class="headerlink" title="心理防御机制与人生意义的作用结果"></a>心理防御机制与人生意义的作用结果</h2><p>以前在了解<a href="/2017/10/15/freud-brief/">弗洛伊德</a>的时候知道: 随着人长大和成熟, 心理防御机制也会更高级.</p><p>在追求人生意义的路上一定有很多难点, 而有一部分人却一直保留着低级的机制来抵抗遇到难点的挫折感.</p><p>比如: 想命令他人; 想吸引别人注意力(以哭, 闹, 制造问题的手段);</p><p>而这些扭曲的目标, 就会成为社会问题. 大问题有犯罪, 小问题有让一部分人对社会无用.</p><p>那么正确的能实现人生意义的目标是什么呢? 是<strong>与人合作, 共同为人类进步作出贡献.</strong> 只有人类进步, 大家才能走向富裕, 才能进入共产主义, 而进步的方式一定是合作.</p><p>那么确定正确的目标有多重要, 这是书里另一个重要的观点.</p><h2 id="目标论"><a href="#目标论" class="headerlink" title="目标论"></a>目标论</h2><p>阿德勒认为<strong>指导人行为的是目标, 而不是过去.</strong></p><p>他认为 <strong>一个人的经历不能对他的行为造成影响, 造成影响的是他如何归因他的经历.</strong></p><p>就像从古至今, 治病的目的几乎都是消除病症. 而无论从医学来说还是教育来说, 这种做法都是不解决问题的. 我想举几个例子来说明这个观点.</p><p>经历过相同不幸的人, 有些人以不幸为戒, 尽力避免日后的生活陷入不幸. 有的人时时以不幸为借口, 说因为以前的不幸一蹶不振. 我身边有许多这样对比的例子.</p><p>如果我的目标是碰到高处, 于是拿梯子爬墙. 有人把我梯子拿走了, 我会去拿椅子, 如果都拿走, 我会自己跳, 踮脚. 拿走梯子是不解决问题的. </p><p>我有一个很熟悉的病: <strong>神经官能症.</strong> 疑病症, 觉得自己得了胃癌, 查证没有后, 又觉得肝疼, 可能是肝癌. 为啥查了一个没问题, 会马上另外地方不舒服? 因为病人的目的就是获取家人注意, 或是逃避生活压力, 连病人自己都不自知.</p><p>所以”一有压力就头疼”, 也许不是生理疾病, 而是心理疾病, 当鼓起勇气面对压力的时候, 也就不头疼了.</p><p>一些人老以”我不认真, 我不仔细”来掩饰, 他们害怕认真了也得不到好成绩.</p><p>说了目标对人的重要性, 那么错误的目标是如何获得的, 又如何能获取正确的目标呢?</p><h2 id="目标是如何获得的"><a href="#目标是如何获得的" class="headerlink" title="目标是如何获得的"></a>目标是如何获得的</h2><p>当然童年的环境和教育获得的.</p><p>而目标又极其重要, 不管对个人的发展, 还是社会的人才, 社会的犯罪率来说.</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>先说环境. 阿德勒思考了一套, “第几个孩子有什么性格”的结论, 也强调了有一种问题人–”被宠坏的孩子”.</p><p>家中的老大, 在老二出生后会”失宠”, 而这时老大还是需要被照顾的时期, 导致老大容易获得”想获得他人注意”的目标. 所以问题儿童中, 老大占的比例是最高的. 家中最小的小孩成就最大, 因为没有失去安全感, 又有竞争的目标(哥哥姐姐), 更容易获得”正确的目标”.</p><p>但最小的小孩因为被关心最多, 所以成为”被宠坏的孩子”概率也比较大, 需要克服这点. 另外对独生子女, 年龄间隔大的子女也各有特点.</p><h3 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h3><p>接下来谈谈教育. 在我看来, 父母对孩子的教育分为刻意和随意.</p><p>有父母会知道应该交给孩子什么价值观, 并刻意实行一些手段.</p><p>而很多父母不知道应该教育孩子什么, 就把自己的价值观顺势丢给孩子了. 当然这个情况通常是比较糟糕的, 我看到过很多父母教孩子要盯着钱.</p><p>但有一个好东西出现了: 学校. 我这一代很多这种模式的: 父母观念并不是特别正, 但知道读书有出路, 而学校确实给了一些好的世界观, 那么在孩子长大成人学会自我教育前, 他们又获得了一种晋级层次的方式.</p><h3 id="刻意教育"><a href="#刻意教育" class="headerlink" title="刻意教育"></a>刻意教育</h3><p>那么怎么刻意教育孩子的合作精神呢, 阿德勒提到了一些好的和坏的.</p><p>孩子做的很多游戏是互相竞争, 已超越对方为目的的. 这个不太有益.</p><p>营造两个孩子一起做功课, 一起读书, 一起学习是好的. 两人合作的舞蹈也是很好的游戏.</p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>粗粗看了一遍, 对其中很多点都认可.</p><p>让我意识到朋友间, 家人间, 同事间, <strong>正确的关系是共同进步, 而不是竞争.</strong> 爱是聪明的, 恨是愚蠢的.</p><p>与阿德勒这样三观正的作者相比, 想起一本三观扭曲的书&lt;穷爸爸与富爸爸&gt;, 又想起了马云说的&lt;中国的金融没有系统, 当铺思维&gt;的事. 意识到, 不是所有知识都是三观正的, 还是多读经典, 少追吸睛的东西吧.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 阿德勒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊生命</title>
      <link href="/2020/11/15/talk-about-our-being/"/>
      <url>/2020/11/15/talk-about-our-being/</url>
      
        <content type="html"><![CDATA[<p>七天前的现在, 11月8日, 外公因抢救无效离开了我们, 也许是信息密度的关系, 感觉这周过得特别长.</p><span id="more"></span><h2 id="戛然而止"><a href="#戛然而止" class="headerlink" title="戛然而止"></a>戛然而止</h2><p>事发前一天是我生日, 前一周我和外公聊了一下午天, 再前2周外公出席了我的婚宴.</p><p>这事对我的感受就是: 突然.</p><p>接到消息赶到医院, 得知外公已经走了, 走到外公身旁, 除了看到身上插了各种管子, 还发现肚子还在起伏, 于是赶紧找医生, 告诉医生还有呼吸. 医生解释, 这是呼吸机打出来的呼吸, 人已经没了.</p><p>事后得知, 外公是出去散步, 准备回家吃饭的时候身体不行的.</p><p>家里还有准备作为晚饭的食材, 可这本打算吃的饭, 是吃不到了.</p><p>于是, 我知道了. 外公的离开不仅对我来说很突然, 对他自己来说, 也很突然.</p><h2 id="生命有多脆弱"><a href="#生命有多脆弱" class="headerlink" title="生命有多脆弱"></a>生命有多脆弱</h2><p>就在今年4月1日, 我也有一次可能生命突然熄灭的经历. 这两天晚上想到外公, 回想到自己的经历, 会有濒死的感觉.</p><p>那天我胃出血去的医院, 挂上水, 我的心跳还110左右, 心跳突然上了170, 送进抢救室, 血压低到20, 病危通知书, 抢救, 深静脉插管, 胃管, 洗胃, 输血. 那几个小时, 我以为和我无关的东西, 都经历了.</p><p>总的来说, 我自认为是全程保持清醒的, 感觉是: 超级冷, 超级想睡觉. 只有一次: 有那种”惊醒”的感觉, 不知是身体本能的阻止我昏迷还是抢救时打入的肾上腺素起效的原因.</p><p>这两件事让我感觉到: 死亡真的是一件很容易的事情.</p><p>并且, 当事人可能根本没意识到自己会突然失去生命.</p><h2 id="什么使人难受"><a href="#什么使人难受" class="headerlink" title="什么使人难受"></a>什么使人难受</h2><p>在之后的几天, 某些时候, 我又会觉得, 这件事本身是正常的, 外公的年纪和离开的方式似乎也不算差. 于是会感觉还好.</p><p>但在回忆想象的时候, 一些场景会使我特别难受, 总结来说, 就是”感觉到他刚才还是个正常人”的时候, 最使人难受.</p><p>看到外公上医院时候的衣物, 口袋里的口罩, 钱, 包. 看到外公家里上周带给他吃的东西, 还没舍得吃, 上周一起吃饭的菜还没舍得吃完. </p><p>在房间的各处看到了藏着的东西, 充电器, 水杯, 能联想到一个正常生活的人的那些时刻, 心里又是很不好受的.</p><h2 id="生命的意义"><a href="#生命的意义" class="headerlink" title="生命的意义"></a>生命的意义</h2><p>我已经很熟悉流程的追悼会按部就班的进行着, 随着最后一个钉子敲了三下, 这一生, 不管好坏, 无论功过, 就此掩住. 并且由我们看着送入火化炉, 变成骨灰.</p><p>是的, 上周还能连续聊天3小时, 走的时候送我到门口的人, 就这样从世上消失了.</p><p>变成了, 变回了, 碳氢氧.</p><p>不由地想到&lt;寻梦环游记&gt;, 最终, 每个人, 会没有人记得他在这个世上存在过. 外公会, 我的爸妈会, 我也会. 毕竟, 我们也不会记得以前的哪个人的名字. 在一些纪念碑上, 可以看到一些名字, 但我想, 也许已经没有人留存着他的记忆了.</p><p>那每一个生命, 存在过的意义是什么呢? 我认为, 对个人来说, <strong>是没有意义</strong>.</p><p>从宏观来说, 生命为什么存在, 意义是什么, 人类尚未理解. 从人类的角度来说, 每个生命存在的意义是推进人类进步, 这也许现在最现实的意义了, 但对个人来说, 这绝对不是大多数人的人生目标.</p><p>也许大多数的每个人, 生命的意义就是: 克服自己某些时刻的本能, 来满足自己的另一些本能吧. 而本能, 可能是被”设计”出来满足设计者目的的. 就像员工接受老板给你的价值观, 产生的行为就会去满足老板的愿望, 并且”本能”这种被给的价值观, 是无法不接受的.</p><h2 id="自我中心的好处"><a href="#自我中心的好处" class="headerlink" title="自我中心的好处"></a>自我中心的好处</h2><p>每个人都有一个巨大的缺点: 认为自己是世界的中心, 自己是世界的主角.</p><p>我们看电视的时候, 都觉得主角一个杀几个很帅. 那是因为我们把自己代入了主角. 但毕竟1个强者要杀多个弱者, 所以大概率上我们是弱者, 但不自知.</p><p>那自我中心有啥问题吗? 有. 因为每个人都认为自己是主角, 那么势必会产生很多冲突. 说个最简单的: 出了问题, 大家都认为是对方的错.</p><p>我一直认为, 自我中心是个很大的问题, 并且无法剔除, 每个人的一生都在与之作斗争. 但现在感受到: <strong>原来任何事情都是有对立面的.</strong> 快乐的时候就失去了进步的机会; 经历痛苦的时候其实在快速成长; 做舒服的事的时候时间在快速流逝; 做不愿意做的事的时候信息密度大, 体验的时间更长. 甚至一些看起来的坏事是另一个更坏的事的最佳方案, 比如愤怒比悲伤好很多.</p><p>也许一直认为自己是主角, 一直没认为自己会离开这个世界, 所以直到最后也认为只是个小小意外, 马上会恢复正常生活, 这样痛苦就减轻许多了吧.</p><h2 id="仪式的意义"><a href="#仪式的意义" class="headerlink" title="仪式的意义"></a>仪式的意义</h2><p>我比较冷静地参加了这次追悼会, 反而看到了一些, 以前从未发现的情况.</p><p>有一些人在未开始的时候说说笑笑的, 在仪式进行到某个程度的时候突然哭泣, 还说那些”等等我, 我们不能没你”这些奇奇怪怪的话. </p><p>经过一些了解, 原来: “哭”是一种规范. 于是又联想到了一些事.</p><p>linux的自传&lt;just for fun&gt;说事物的发展分三步: 需求, 规则, 娱乐. 书里的调侃是性, 确实好多事物可以对号入座, 甚至是生孩子, 上班, 买车.</p><p>那如果葬礼一开始是需求(真心地难受, 需要宗教来抵御情绪), 到了现在的”社会规则”, 并且可能不会到达”娱乐”的程度. 于是关于”社会规则”这个程度, 我又更坚定了我以前的一些看法:</p><p><strong>大部分事物, 到了”社会规矩”的程度, 也许已经没有一开始的需求了, 那么也不需要去遵守”规矩”了.</strong> 这个在我行为里的体现, 周围朋友都会感受到的可能是骑摩托车与结婚没有办婚礼. 在我看来, 我在这2件事情上是产生了很多收益与便利的, 并且只是在结婚有一些冲突, 细想原因, 也许因为涉及到非自己圈子的人.</p><p>那为啥自己圈子的人都能不对我的”没按社会规矩”提出意见呢? 因为时代. 所以我认为<strong>这是个很棒的时代.</strong></p><p>现在的时代与以前的时代相比, 有啥变化?</p><ul><li><strong>社交圈子小</strong>: 一辈子能碰到的就这几个人, 所以要”不能被别人看不起”.</li><li><strong>能做的有意义的事少, 人更容易虚荣, 因为难得有真荣</strong>: 生产生态差, 经济条件差, 劳动参与度低, 大家只能做平乏枯燥的事情. 现在有太多的机会可以做有趣的事情并为社会作出贡献, 为他人提供服务.</li></ul><p>现在的科技先进, <strong>能做的又令人兴奋, 又能为别人服务的事很多</strong>, 所以社会的价值观也变得更好, 以贡献为荣, 而不是摆阔. 上学时候觉得校服丑, 上班的时候有好多同事(有高层, 有底层)都会穿公司的校服来上班.</p><h2 id="感情的原因和目的"><a href="#感情的原因和目的" class="headerlink" title="感情的原因和目的"></a>感情的原因和目的</h2><p>想到仪式时, 有些大人可以操纵自己从笑变成哭, 那演员是那么容易的吗? 操纵自己的感情真的那么容易吗? 经过一些思考, 我有了一些猜想, 人的感情分为2种:</p><ul><li>假感情, 虽然当事人以为是真感情, 但是自己可以操纵的. 目的控制他人. (用哭获取谈判的优势, 用恐惧获取关注, 用愤怒压制别人).</li><li>真感情, 不能自控的感情, 目的是减轻心理压力, 最典型的是笑. 并且真感情的哭和愤怒, 一般会让自己头晕眼花, 因为无法控制停止.</li></ul><p>真假感情虽然当事人自己可能难以辨别, 但有一个很容易区分的点: 有没有他人在场.(或者说, 需不需要他人在场)</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack一些基本概念补课</title>
      <link href="/2020/10/22/webpack-basic-concept/"/>
      <url>/2020/10/22/webpack-basic-concept/</url>
      
        <content type="html"><![CDATA[<p>一直对webpack的一些功能概念比较模糊, 所以过一次文档的guide来看看这些功能: code spliting, tree shaking, hot module replacement, require.context.</p><span id="more"></span><h2 id="code-splitting和懒加载"><a href="#code-splitting和懒加载" class="headerlink" title="code splitting和懒加载"></a>code splitting和懒加载</h2><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>先理解下为什么要做<a href="https://webpack.js.org/guides/code-splitting/">code splitting</a>.(下文简称cs)</p><p>在不配置的情况下, 一个入口只会打出一个bundle文件. 一个普通的spa, 普遍就一个入口, 这个入口来引入整个app及css, 也就是<strong>整个应用都在一个js文件里</strong>, 加载的时候也会加载整个应用, 如果项目大, 白屏时间就长了.</p><p>那一般做cs通常的场景有:</p><ul><li>多个入口文件. 比如chrome插件就有多个独立页面.</li><li>首屏不需要的组件, 或者通过点击才加载的组件, 分到不同的bundle里按需加载.</li><li>不同的组件都需要的lib, 独立出来打包, 避免在各处引用的时候重复打包.</li></ul><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>那文档里说cs的方法有3个:</p><ul><li>手动设置多个入口.</li><li>使用插件SplitChunksPlugin</li><li>动态import.</li></ul><p>下面简单介绍一下这三种情况.</p><p>手动设置多入口: 就是entry里多配一个键就多一个入口, 但可能存在一个情况: a文件依赖c, b文件也依赖c. 这样打包结果就是: 一个bundle含有<code>a+c</code>, 另一个bundle含有<code>b+c</code>, <code>c</code>被重复打了, 这种情况可以通过entry的一些简单配置来解决. (具体配置不说了).</p><p>插件: 第一种case可以直接用SplitChunksPlugin来解决, css可以用mini-css-extract-plugin来解决.</p><p>动态import: 通过<code>import().then</code>的语法, 把import理解成我们经常做的http请求就可以了. 这个功能可能是webpack先做的, 现在已经被列入了es规范, 在浏览器里也可以直接<code>import()</code>了.</p><p>动态import以后, webpack编译的结果是: 通过用户操作触发了<code>import()</code>函数以后, <strong>通过<code>document.createElement(&#39;script&#39;);</code>来动态加载js的.</strong> 并且直接使用了Promise, 所以低版本浏览器使用这个功能要自加shim. vue, react, angular的组件&#x2F;路由懒加载, 都是通过webpack的这个功能实现的.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>code splitting的意义是一个入口不止打出一个bundle文件, 而是根据依赖树和业务合理地打出多个文件来提高用户体验. (为什么说合理地, 因为分成多个bundle是增加请求消耗的)</li><li>常用的方法是: 使用webpack插件和使用vue&#x2F;react&#x2F;angular的懒加载插件.</li><li>手动配多入口和手动动态import不常用, 是根据具体业务来的. (因为需要这样做的业务不常见)</li></ul><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><h3 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h3><p>tree shaking(下文简称ts)的故事是: 有用的代码就像树上绿色的叶子, 没用的像灰色的, 摇一下树, 就把灰色的叶子(没用的代码)去除出bundle了, 这个名词是rollup先发明的.</p><p>那么为什么会写没用的代码呢? 所以ts的基本场景是: 第三方lib提供了很多功能, 但是使用的时候未使用全部, 打包的时候不需要把未使用的功能都打进来.</p><h3 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h3><p>既然是<strong>打包的时候</strong>去除代码死区, 那么ts就是webpack完成的. 但因为webpack的功能还没有登峰造极, 所以<strong>使用者也需要配合webpack, 才能让ts完成得更合理</strong>.</p><p>在webpack现在(5.3.2)文档里, 提了3个必须条件:</p><ul><li>使用es module导出模块. (import 和 export)</li><li>在<code>package.json</code>中添加<code>sideEffects</code>字段. 或者在代码里添加<code>/*#__PURE__*/</code>注释.</li><li>webpack配置<code>mode: &#39;production&#39;</code>.</li></ul><p>那么接下来的疑问就是: 为什么需要esm和设置标识, webpack才能进行treeshaking呢?</p><p>答: 因为esm是静态的, 所以只有esm是可分析的, 才能进行DCE(dead code elimination). 因为js语言的特性(如object引用地址, prototype引起的sideeffect), 一些地方还无法确定是可以判定成死区的.</p><p>而ts的本质是优化, 所以不改变代码执行效果是根本原则. <em>虽然我们这些初级程序员经常把feature优化掉:(</em></p><p>下面来说说相关的内容.</p><h3 id="amd-cmd-umd-cjs-esm-动态-静态"><a href="#amd-cmd-umd-cjs-esm-动态-静态" class="headerlink" title="amd? cmd? umd? cjs? esm? 动态? 静态?"></a>amd? cmd? umd? cjs? esm? 动态? 静态?</h3><p>众所周知, 以前js是没模块的, 不同lib之间要通过把变量挂在window上交互, 还涉及到加载顺序问题, 也就10年前的情况.</p><p>于是, 为了解决模块问题, 这些东西就出现了.</p><p>amd, cmd 是运行在浏览器上的.</p><p>cjs是运行在node.js上的.</p><p>umd是以上一切的结合, 方式是判断是否有一些关键字, 然后用对应的方法导出模块.</p><p>esm是es6的module规范, 特点是静态的, 但尴尬的是, 浏览器不支持, 还是需要编译成umd.</p><p>所以现在的lib库一般打包出三个版本: umd (for 浏览器), cjs(for node.js, 但如果是web库目标还是编译成umd), esm(让认识esm的编译工具使用).</p><p>终于回到了正题: 为啥只有esm可以进行tree shaking?  答: 因为esm是静态的.</p><p>什么是静态? 在编译的时候, 已经加载完了需要的依赖. 动态是运行的时候还可以加载依赖.</p><p>esm是静态的, 在进行编译的时候, 这个项目的依赖树已经确定了. 编译器就可以把代码整理成ast进行分析了.</p><p>(为啥esm是静态的, 因为es6规范规定他是静态的, 就是想到了会有这些好处, 所以import必须全部写在代码之前)</p><h3 id="side-effect"><a href="#side-effect" class="headerlink" title="side effect?"></a>side effect?</h3><p>大概在16年的时候当时同事都在说函数式编程(fp). 于是学了一波还翻译了一篇教程写在博客里.</p><p>tree shaking的side effect和fp的是不同的.</p><p>比如<code>function go(url) &#123; location.href = url &#125;</code>. 这个在fp里肯定是算side effect, 但是在做tree shaking的情况里, 不算side effect. 因为没有这个方法, 完全不会影响其他函数.</p><p>另外, 对于各种编程范式来说, 面向过程的(imperative program), 面向对象的(object oriented program), 还是函数式(functional program). 甚至代码是否要简洁. 他们的根本都是为了好维护, 易debug, 脱离实际, 硬追求一个范式都是幼稚的行为, 不知道自己目的是什么的行为而已.</p><h3 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h3><p>tree shaking本质是编译软件做的事, webpack5的更新日志也表示已经能自动分析更多的”side effect”而不需要自己配置了.</p><p>上一小节的总结, side effect的case其实不多, 大部分场景就是polyfill, 如果穷举场景, 编译器是可以做得更多的. 并且就算是代码要做处理, 也是第三方库作者要了解的东西. 所以对业务编码者的影响几乎是没有.</p><p>也希望编译器会越来越强, 或者ts这样的结构化系统推行得更好, 让tree shaking也零配置, 无感知.</p><h2 id="hmr"><a href="#hmr" class="headerlink" title="hmr"></a>hmr</h2><p>hmr是webpack可以探测文件改变, 不刷新页面更新部分页面. </p><p>好处是可以保留页面状态, 和快.</p><p>因为上一份工作用vue, 一直以为hmr是自动的, 写了一年react项目, 每次保存后都会刷新页面, 也一直没仔细思考. 于是看了下hmr文档.</p><p>大概流程是:</p><ul><li>webpack的dev-server起一个http服务, 并把编译结果放在内存里吐给页面.</li><li>页面与服务端建立websocket准备通信.</li><li>服务端监听文件改变, 把改变通过ws告诉页面.</li><li>页面接到信息, 执行预制的行为.</li></ul><p>那页面接到信息, 执行啥行为呢? 是需要去写的.</p><p>那为什么vue和css会自动hmr呢? 因为<code>style-loader</code>和<code>vue-loader</code>里集成了hmr的api. 而react有第三方插件, 使用了就可以成功hmr了.</p><p>另外, hmr是根据<code>module</code>来的, 如果一个module没有编写指定的行为, hmr引擎就会向他的父级module找, 直至顶层, 如果都没有, 就刷新页面了.</p><p>所以: hmr是需要写代码的, 写得越多, 越细节, 热加载效果就越好(到最小的module). 写得越少, 越靠近根组件, 热加载效果越差, 所需时间也越少.</p><h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h2><p>批量引入功能, 第一次看到是几年前的electron-vue的脚手架里, 当时没在意, 以为是node语法.</p><p>这个功能常用语中心化的状态管理系统, vuex和redux, 一般项目都会有个文件, 引入类似文件结构的文件, 然后一起输出, 如果使用了<code>require.context</code>, 就可以避免”新增一个模块, 要去这个文件里复制粘贴修改”的问题.</p><p>当然缺点是, 这个项目只能用webpack了. 但这个缺点几乎不存在, 因为其实打包工具和项目是整体, 迁移成本极大的.</p><h2 id="build性能"><a href="#build性能" class="headerlink" title="build性能"></a>build性能</h2><p>build性能其实和tree shaking非常相像, 因为核心思想都是: <strong>使开发和打包更合理.</strong></p><p>开发的时候要debug方便, 修改以后反应快.</p><p>打包的时候要包小.</p><p>所以其实都可以猜出要做几点:</p><ul><li>尽量使用新版本的webpack, 因为内部在优化, 更多的东西会更自动和快. 其实就是更好的算法.</li><li>更合理的在不同情况(dev和prod)下加载loader和插件.</li><li>代码质量更好.</li><li>其他零零碎碎插件的具体用法.</li></ul><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这次对webpack浏览非常浅. 下次尝试深入: loader和plugin, webpack打包后各个module在浏览器里是大致如何通信的.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个简单的vscode插件</title>
      <link href="/2020/09/30/build-a-vscode-extension/"/>
      <url>/2020/09/30/build-a-vscode-extension/</url>
      
        <content type="html"><![CDATA[<p>工作中新写一个页面经常会遇到: 根据想好的布局写完了html片段, 然后要把对应的类名写个sass树.</p><p>于是产生了写个vscode来简化这个步骤的想法. 回头来分享这个<a href="https://github.com/cwj0417/vscode-get-sass-structure-from-html">简单的demo</a>, 发布到<a href="https://marketplace.visualstudio.com/items?itemName=cwj0417.get-sass-structure-from-html&ssr=false#overview">vscode商店</a>也是免费的.</p><span id="more"></span><h2 id="vscode插件结构"><a href="#vscode插件结构" class="headerlink" title="vscode插件结构"></a>vscode插件结构</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>vscode的脚手架是在yeoman的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">npm install -g yo generator-code</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用脚手架创建文件夹和目录结构</span></span><br><span class="line">yo code</span><br></pre></td></tr></table></figure><p>然后根据想使用的语言, 项目名称配置一下就行了.</p><p>进入文件夹, 会有很多文件, 都是为我们配置好的, 我们只需要关注2个文件: <code>src/extension.ts</code>和<code>package.json</code>.(需要发布的话需要写readme)</p><p>想完成一些插件功能, 入口都是从这2个文件. 所以在深入之前, 需要了解一下vscode插件概念.</p><h3 id="vscode插件能力和基本概念"><a href="#vscode插件能力和基本概念" class="headerlink" title="vscode插件能力和基本概念"></a>vscode插件能力和基本概念</h3><p>vscode插件提供的能力有:</p><ul><li>存储数据</li><li>发出通知</li><li>绑定快捷键</li><li>控制右键菜单</li><li>选择文件&#x2F;文件夹</li></ul><p>和一些我不关心的插件能力:</p><ul><li>控制颜色主题</li><li>翻译语言</li><li>语言(计算机语言)高亮</li><li>扩展debugger</li></ul><p>另外可以扩展一些工作区:</p><ul><li>菜单栏</li><li>侧边栏</li><li>状态栏</li><li>新建tab插入webview</li></ul><p>这些功能, 基本都通过2种入口来获取, <code>package.json</code>的配置字段<code>contributes</code>, 和引入node api的命名空间<code>vscode</code>. 现在可以开始介绍具体一些的实现了.</p><h3 id="command与激活状态"><a href="#command与激活状态" class="headerlink" title="command与激活状态"></a>command与激活状态</h3><p>command是vscode插件的一个基本概念, 在<code>src/extension.ts</code>注册, 然后在<code>package.json</code>中设置就会触发对应的动作.</p><p><code>extension.ts</code>中export2个方法, 分别是<code>activate</code>和<code>deactivate</code>. 一般注册方法会写在<code>active</code>里, 所以要通过<code>package.json</code>中<code>activationEvents</code>来激活才可以注册command的行为.</p><h2 id="完成插件功能"><a href="#完成插件功能" class="headerlink" title="完成插件功能"></a>完成插件功能</h2><p>我希望创建一个命令, 通过右击菜单获取当前选中的html, 分析并产生一个sass树字符串, 并复制到剪切板中.</p><h3 id="插件实现"><a href="#插件实现" class="headerlink" title="插件实现"></a>插件实现</h3><p><code>package.json</code>中这样配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get-sass-structure-from-html.generate-structure&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;生成css节点树&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;keybindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get-sass-structure-from-html.generate-structure&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+i&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd+i&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;menus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;editor/context&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get-sass-structure-from-html.generate-structure&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><ul><li>commands注册一个command</li><li>keybindings注册一个快捷键, 当使用<kbd>ctrl + i</kbd>时就触发这个command</li><li>在右击菜单添加一个菜单, 作为触发命令的入口.</li></ul><p>在<code>src/extension.ts</code>的<code>active</code>方法里注册这个command:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generateStructure = vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&quot;get-sass-structure-from-html.generate-structure&quot;</span>, <span class="function">(<span class="params">fileUri: vscode.Uri</span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> editor = vscode.<span class="property">window</span>.<span class="property">activeTextEditor</span>;</span><br><span class="line"><span class="keyword">const</span> tplstring = editor?.<span class="property">document</span>.<span class="title function_">getText</span>(editor.<span class="property">selection</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">parser</span>(tplstring ?? <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                       </span><br><span class="line">vscode.<span class="property">env</span>.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(res);</span><br><span class="line">vscode.<span class="property">window</span>.<span class="title function_">showInformationMessage</span>(<span class="string">&#x27;已复制&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(generateStructure);</span><br></pre></td></tr></table></figure><p>首先通过<code>vscode.window.activeTextEditor</code>获取到选区文本.</p><p>然后通过<code>parse</code>方法来获取转换后的sass树字符串.</p><p>最后通过<code>vscode.env.clipboard.writeText</code>写入剪切板, 并用<code>vscode.window.showInformationMessage</code>发出通知.</p><p>剩下的就是parse实现来简单解释一下.</p><h3 id="parse实现"><a href="#parse实现" class="headerlink" title="parse实现"></a>parse实现</h3><p>要分析一段html代码, 于是我从vue编译template的代码中<a href="https://github.com/vuejs/vue/blob/dev/src/compiler/parser/html-parser.js">解析html的方法</a>里找到了他<a href="http://erik.eae.net/simplehtmlparser/simplehtmlparser.js">参考的lib</a>, 并<a href="https://github.com/cwj0417/vscode-get-sass-structure-from-html/blob/master/src/parser/htmlparser.ts">简写</a>了一下.</p><p>最下层的做法是:</p><ol><li>逐段读取domString.</li><li>用预先写好的一系列正则, 逐段匹配. 匹配目标是: 标签开始, 标签结束. (还有注释, 被我去掉了)</li><li>把匹配成功的段落, 根据匹配的类型, 扔到预先写好的回调里去执行.</li><li>若没有一段正则匹配成功, 则认为匹配到了”直到下个<code>&lt;</code>符号”的字符串, 并扔到字符串回调里去执行.</li><li>从这次匹配结果的下一个字符开始下一轮匹配.</li></ol><p>执行以后, 处理标签开始, 结束, 字符串的回调分别会依次执行, vue会在回调里建立自己的ast, 我直接在回调里拼接字符串, 我的parse函数就写好了.</p><p>当然, 最好的方式还是建立一个ast, 会更容易测试和开发后续功能和修复问题.</p><h3 id="todos"><a href="#todos" class="headerlink" title="todos"></a>todos</h3><p>demo级别的完成了, 但是还剩下好多东西没做.</p><ol><li>对输出sass树字符串的格式化.</li><li>对属性”类”检测的和兼容.</li><li>对同级多个类的输出写法.</li><li>对错误输入的兼容.</li><li>对错误情况的处理.</li></ol><h2 id="发布到应用市场"><a href="#发布到应用市场" class="headerlink" title="发布到应用市场"></a>发布到应用市场</h2><p>发布流程非常简单, 并且是免费的. <a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">教程</a>说得非常清楚, 并且有截图.</p><p>总的来说分为2步:</p><ul><li>去<a href="https://azure.microsoft.com/en-us/services/devops/">azure devops</a>注册一个账号, 并生成一个应用市场专用的token.</li><li>用工具<code>vsce</code>发布.</li></ul><p>安装<code>vsce</code>(vsce的全称是: vscode插件)的方法: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vsce</span><br></pre></td></tr></table></figure><p>然后登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce login</span><br></pre></td></tr></table></figure><p>然后发布</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce publish</span><br></pre></td></tr></table></figure><p>完事, 提示什么错误解决什么错误就可以了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> vue源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析immer</title>
      <link href="/2020/09/16/brief-read-immer/"/>
      <url>/2020/09/16/brief-read-immer/</url>
      
        <content type="html"><![CDATA[<p>immer是对js对象immutable的一种解决方案, 从rtk接触到的. 因为api非常简单, 所以来看一下是如何实现的.</p><p>因为对object内存分配, immutablejs都没深入看, 所以无从比较.</p><span id="more"></span><h2 id="背景和目标"><a href="#背景和目标" class="headerlink" title="背景和目标"></a>背景和目标</h2><p>首先immer是一个看起来很帅的lib, 先硬解释一下为什么要使用他:</p><ul><li>immutable的必要性是增加程序的可控性, 避免出现debug难度高的bug.</li><li>从api的设计和性能来说, 都比较优秀.</li></ul><p>api的设计来说: 比较容易继承到别的lib里(指redux, [狗头]), 并且非常优雅, 进行一些封装(指rtk)后可以无感使用.</p><p>从性能来说: 在对象层次比较深的时候, 是比深拷贝和<code>JSON.parse(JSON.stringify(xxx))</code>性能好的, 越复杂越好.</p><p>从兼容性来说: 一个lib是会比<code>JSON</code>兼容性好的, 现在我看的版本7.0beta是已经支持map, set的.</p><p>于是来说一下这次<code>浅析</code>的目标: 模拟部分(核心)功能, 目标是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = &#123;<span class="attr">propA</span>: <span class="number">1</span>, <span class="attr">propB</span>: &#123; <span class="attr">propC</span>: <span class="string">&#x27;deep&#x27;</span> &#125;&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="title function_">produce</span>(origin, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">  draft.<span class="property">propB</span>.<span class="property">propC</span> = <span class="string">&#x27;mutated&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实现一个produce传2个参数, 实现plain object, 给一个比较深的属性赋值, 的immutable对象的产生.</p><h2 id="准备思路"><a href="#准备思路" class="headerlink" title="准备思路"></a>准备思路</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>immer产生immutable对象的原理是<strong>递归浅拷贝</strong>.</p><p>proxy只能算一个工具, 而这个工具达成了另一个特性, <strong>懒处理</strong>: 只对被touch的属性进行处理, 未被影响属性不会创建新的内存区.</p><p>immutable性能比较好的原因就在这里, 深拷贝与<code>JSON</code>处理都会在内存区里产生一个和原对象一样大的占用, immer只在原对象被touch的属性才创建新的内存区.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大方向看: </p><ol><li>immer创建一个draft对象, 来供recipe函数操作.</li><li>recipe函数执行完成后, immer再对被recipe操作过的draft对象进行整理, 产生返回值.</li></ol><p>创建draft的思路是: </p><ol><li><p>创建一个对象作为proxy的源, 把原对象放入, 并产生一些列辅助属性.</p></li><li><p>对draft的set拦截: 如果有set操作就产生一个浅拷贝, 对浅拷贝结果进行修改, 并保存在copy属性里.</p></li><li><p>对draft的get拦截: 如果有get操作, 就说明打算mutate更深一层进行set, 就产生一个递归draft放到copy的对应key里并返回.</p><p>题外话: immer做了如果是一个不可以创建proxy的值(约等于基本类型)就直接返回, 所以: 打印draft的一个值会得到对应的值, 而打印一个draftable的值会得到draft.</p><ol start="4"><li>   拦截其他的一些操作, 使draft有合理的行为. 核心还是get和set.</li></ol></li></ol><h2 id="编写一produce"><a href="#编写一produce" class="headerlink" title="编写一produce"></a>编写一produce</h2><h3 id="api结构"><a href="#api结构" class="headerlink" title="api结构"></a>api结构</h3><p>produce函数有2个入参和一个返回值. <code>produce: &lt;T = any&gt;(originObj: T, recipe: (draft: T) =&gt; any) =&gt; T</code></p><ul><li>originObj: 第一个入参, immutable的目标对象.</li><li>recipe: 第二个入参, 是函数, 唯一参数是目标对象的副本draft, 对副本draft进行任何改变会决定produce的返回值.</li><li>返回值: immutable对象. 经过draft改变以后的结果值.</li></ul><p>所以我们的produce是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">produce</span> = (<span class="params">originObj, recipe</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="title function_">createProxy</span>(originObj);</span><br><span class="line">    <span class="title function_">recipe</span>(proxy);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readresult</span>(proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为3部: 根据originObj产生draft, 用recipe处理draft, 分析draft取出期望的返回值.</p><h3 id="产生一个proxy"><a href="#产生一个proxy" class="headerlink" title="产生一个proxy"></a>产生一个proxy</h3><p>proxy有2个点, target和handler. handler的关键在于getter和setter.</p><h4 id="构造target"><a href="#构造target" class="headerlink" title="构造target"></a>构造target</h4><p>因为元数据必须被保存, 又需要一份浅拷贝, 所以把这2个放在<code>base</code>和<code>copy</code>属性里. (immer里把这个target叫做state).</p><p>在初始化的时候, base赋值为originObj, copy暂时不赋值, 如果没有被touch, 连浅拷贝都不需要, 在finalize的时候直接取base就行了, 提高性能.</p><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>因为setter的目标已经是被包装过的, 所以setter要把新的key, value. 设置到copy属性上.</p><p>当然, 如果copy不存在, 就要浅拷贝base, 生成一份copy.</p><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>暂不考虑需要读取值的场景, 因为recipe函数的功能是mutate draft.</p><p>所以触发getter的原因, 是想触发更深级别的setter, 所以必须保证这个getter拿到的是一个proxy, getter是递归入口.</p><p>另外, 在finalize的时候必须获得真正值, 于是约定了一个symbol, 只要尝试获取这个symbol, 就把state返回给他.</p><p>createProxy整体是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyForState = <span class="title class_">Symbol</span>(<span class="string">&#x27;key-for-state&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createProxy</span> = (<span class="params">value: any</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">state</span>: state = &#123;</span><br><span class="line">        <span class="attr">base</span>: value,</span><br><span class="line">        <span class="attr">copy</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> handler = &#123;</span><br><span class="line">        set (<span class="attr">state</span>: state, <span class="attr">prop</span>: string, <span class="attr">v</span>: any) &#123;</span><br><span class="line">            state.<span class="property">copy</span> = state.<span class="property">copy</span> ?? &#123;...state.<span class="property">base</span>&#125;;</span><br><span class="line">            state.<span class="property">copy</span>[prop] = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        get (<span class="attr">state</span>: state, <span class="attr">prop</span>: string | symbol) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop === keyForState) <span class="keyword">return</span> state;</span><br><span class="line">            state.<span class="property">copy</span> = state.<span class="property">copy</span> ?? &#123;...state.<span class="property">base</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> (state.<span class="property">copy</span>[prop] = <span class="title function_">createProxy</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(state, handler);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(immer中用了<code>Proxy.revocable</code>来产生proxy, 这个简单的demo无处安放revoke handler, 就简单地<code>new Proxy</code>了.)</p><h3 id="整理返回值"><a href="#整理返回值" class="headerlink" title="整理返回值"></a>整理返回值</h3><p>生成draft以后, 会把draft作为参数, 让recipe函数调用. <code>recipe(proxy)</code></p><p>被recipe处理以后的draft对象, 已经根据recipe被触发了对应的getter setter, draft对象的数据结构有以下特点:</p><ul><li>draft的target是一个被包装过的对象, 目前有base和copy属性. (immer中为了性能和case有更多属性)</li><li>原数据储存在base中, 引用方式是引用地址的.</li><li>经过修改的值存在copy中, 引用方式是浅拷贝. </li><li>如果copy对象更深层次的值被改变, copy对象的值会是一个(递归的)proxy.</li></ul><p><strong>所以我们要做的事也很简单</strong>, 根据上面整理的draft的特点, 来获取期望的immutable数据:</p><ol><li><p>使用symbol读取draft对象. (如果不用symbol只能走getter, 无限获取proxy对象)</p></li><li><p>读取draft对象的copy属性.</p></li><li><p>遍历copy对象的键值, 如果值非draft, 则直接取, 如果值为draft, 则递归取.</p><p>(“非draft”是递归出口, 判断draft的办法是判断是否有symbol属性)</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">readresult</span> = (<span class="params">draft: any</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> state = draft[keyForState];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> state.<span class="property">copy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDraft</span>(state.<span class="property">copy</span>[key])) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="title function_">readresult</span>(state.<span class="property">copy</span>[key]);</span><br><span class="line">            state.<span class="property">copy</span>[key] = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">copy</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里, <a href="https://github.com/cwj0417/produce/blob/master/produce.ts">所有”简化的produce”代码</a>已经全部贴出了, 直接执行就可以获取到immutable对象了.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>其实immer实现immutable的基础原理是和深拷贝一样的: 浅拷贝.</p><p>特殊点是: 利用了proxy来实现懒处理, 没有被touch的对象不会创建新的浅拷贝, 依旧使用原对象的内存地址, 节省内存, 提高性能.</p><p>并且produce的api设计, 更容易的嵌入到其他lib里整合. (虽然在我看来是proxy的语法特性导致只能这么写)</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><ol><li><p>虽然immer是个非常简单的库, 但是在阅读源码的时候还是百度了immer源码解析, 发现很多解析都停留在语法级别. 即: 逐行分析语法, 最后直接说结论, 其实作者自己也不知道发生了什么, 只是码字累了草草收尾. 停留在了”看得懂字, 看不懂意思”的级别.</p><p>我之前看vue源码的时候也是如此, 之后有2件事让我重新思考了学习方式:</p><p>第一, 工作的时候看见很多不太好的代码, 都是因为没先思考, 直接ifelse导致的; 第二, 在学习redux的时候看到了一句话”不去写一遍就不会理解他”.</p><p>所以现在都会尝试去实现一个最基本的功能. 其实lib作者开始也是如此的, 再根据各种边边角角来调整构架插入功能的.</p></li><li><p>从可用到完整lib的差距非常大.</p><p>一个可用的功能的lib只要40行, 而功能完整, 考虑各种用户输入, 边缘case, 可拓展性的代码量和需要花的时间都.</p><p>其实在日常工作中也是一样, 领导和qa看任务是否完成, 和代码质量真的好, 的距离, 和需要花的功夫, 是差很多的.</p></li></ol><h2 id="尝试-写一个自动产生不存在属性的proxy"><a href="#尝试-写一个自动产生不存在属性的proxy" class="headerlink" title="尝试: 写一个自动产生不存在属性的proxy"></a>尝试: 写一个自动产生不存在属性的proxy</h2><p>之前尝试写一个方法, 可以让我们在写一些代码的时候不白屏. 如: <code>target.key1.key2.value = &#39;test&#39;</code>, 如果尝试读取undefined的属性, 浏览器就会白屏.</p><p>然后尝试失败了, 现在学到了immer, 就可以尝试用这个模式来实现啦.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> immer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux实践思考</title>
      <link href="/2020/08/16/redux-practice/"/>
      <url>/2020/08/16/redux-practice/</url>
      
        <content type="html"><![CDATA[<p>在工作中持续使用react, redux. 并且对相关生态走马观花, 发现之前对redux的定位不太准确.</p><span id="more"></span><h2 id="一些令人不适的地方"><a href="#一些令人不适的地方" class="headerlink" title="一些令人不适的地方"></a>一些令人不适的地方</h2><p>众所周知, 在有了第一个项目以后, 之后的项目基本是<code>cv模式</code>. 然后在此之上修修补补, 也不会对祖传代码提出质疑, 毕竟p7p8都没说啥. 但总也有些小地方让人觉得有些疑问的.</p><h3 id="关于action-types"><a href="#关于action-types" class="headerlink" title="关于action types"></a>关于action types</h3><p> 关于action type, 是我一直不太满意的. 其原因有二:</p><ol><li>每次新增一个reducer, 就需要在1个地方定义type, 2个地方引入type. 这样就要<strong>定位3个文件, 并打开</strong>, 找文件真的是我的噩梦.</li><li>const要大写, 我滴妈呀, 本来英语就垃圾的我, 看到大写英语根本就不知道是什么意思. 但是type要用大写来表示这是一个type.</li></ol><p>这些问题我从来不问p7p8, 我讨厌听到<strong>我已经知道, 但是并不能说服我</strong>的一本正经理由. 这些”有的没的”的问题, 我偶尔会和关系很好的同事随口提起, 得到的结果和我经历的差不多: <strong>觉得不爽, 但是感觉是一种规则, 需要遵守.</strong></p><p>(顺带一提无关的东西, 还有一个类似的问题, 为什么一些我觉得不需要redux的地方也用了redux, 我倒得到了我能接受的观念, 这个本文先不提.)</p><h3 id="关于combineReducers产生的模块"><a href="#关于combineReducers产生的模块" class="headerlink" title="关于combineReducers产生的模块"></a>关于combineReducers产生的模块</h3><p>我在上篇分析redux代码的时候已经对<code>combineReducers</code>有了比较明确的理解, 于是在实践中思考和证实了:</p><blockquote><p>​dispatch一个action, 所有模块的所有reducer都会调用一遍.</p></blockquote><p>这样就产生了2个不爽的地方:</p><ol><li><p>根本不在页面上的reducer都要去跑一遍. 根据redux的三大原则之一: 一个应用只能有一个store. 所有的reducer必须都注册在一个store下.</p><p>所以假设我在首页触发了一个”设置用户名”的reducer, 这个action会去碰撞所有其他页面(可以是订单&#x2F;列表&#x2F;详情&#x2F;分页等所有reducer)</p></li><li><p>所有<code>action type</code>必须从同一个文件里引入, 不然const来避免type重名导致难以检测的bug就毫无意义.</p></li></ol><p>而我公司现在使用的”实践模式”是: 在”模块文件夹”下有一个自己的状态管理文件夹, 每个模块有自己的actiontype文件. 那也就是说: 这个模式是明显有问题的, 在这种级别的问题下, action type也变得毫无意义, 只有增加工作量和恶心人的用处.</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我很确定, 以上的”问题”, 并不是redux导致的, 而是<code>combineReducers</code>导致的, 但这个辅助函数也是redux官方提供的, (曾经有大佬说过, 向官方挑战结果基本是: 体会到自己的渺小) 那么为什么官方的辅助函数会产生这样的问题呢, 是没有考虑多层结构吗? (不, 本来就是为多层结构设计的)</p><p>我看了一下<code>combineReducers</code>的实现, 发现他实际做的比文档里多了2点:</p><ol><li>   尝试调用每个reducer, 并判断一些输入结构与预期不符的情况.</li><li>   用<code>hasChanged</code>标志来判断state前后是否变化.</li></ol><p>这2点做法我都暂时体会不到意义, 也许这个函数本来就没打算做成”全”的, 而只是一个细胞, 只是我们不该直接把细胞直接用在项目里.</p><h2 id="与vuex比较一下"><a href="#与vuex比较一下" class="headerlink" title="与vuex比较一下"></a>与vuex比较一下</h2><p>之前我一直认为: redux对于react的意义, 是和 vuex对于vue的意义差不多的.</p><p>但这是错的.</p><p>我们来是比较一下概念. 首先vue和redux都是基于flux的, 所以基本概念是差不多的, 所以比较的行为是合理的.</p><table><thead><tr><th></th><th>数据储存对象</th><th>改变数据</th><th>异步操作</th><th>模块化</th></tr></thead><tbody><tr><td>vuex</td><td>state</td><td>commit 触发 mutation</td><td>dispatch 触发 action</td><td>module</td></tr><tr><td>redux</td><td>state</td><td>dispatch 触发 reducer</td><td>???</td><td>(combineReducer?)</td></tr></tbody></table><p>我们会发现:</p><ol><li><p>redux的action呢? dispatch一个action, 触发的是reducer. 也就是<strong>vuex里没有对应redux里action的概念</strong>, 如果硬说的话, 就是”mutation的type”. 或者说是mutation的键.</p></li><li><p>redux本身没有任何对应vuex的action的东西.</p></li><li><p>combineReducer只是用了js特性, 但勉强能和vuex的module比较.</p></li></ol><h3 id="redux的异步操作"><a href="#redux的异步操作" class="headerlink" title="redux的异步操作"></a>redux的异步操作</h3><p>redux似乎没有提供异步操作的概念, 那么如果<strong>希望不在业务层写接口url, 只有依靠外部lib了.</strong></p><p>那么市面上用得最多的lib就是redux-thunk和redux-saga了.</p><p>所以上面表格中的<code>???</code>可以写成: <code>dispatch触发thunk</code>或者<code>dispatch触发saga</code>.</p><p>那么让人不爽的东西又来了: <code>dispatch</code>? 又可以触发reducer, 又可以触发thunk和saga?</p><p>是的, 没错, 因为他们都是利用了redux的middleware机制来”改写”dispatch行为, 具体的去看上篇文章.</p><p><strong>thunk和saga的本质其实都是: 中断dispatch操作, 写自己的业务逻辑, 然后在合适的时机dispatch触发真正的reducer.</strong> 这也可以解释: 为什么logger和thunk不同顺序加载, 看到的log信息是不同的. 因为thunk中间件<strong>中断</strong>了dispatch操作.</p><p>换句话说: **thunk&#x2F;saga不单独写成方法供业务调用的原因只是: 他们需要从中间件中获取dispatch方法而已. **</p><p>redux的这个middleware机制, 让一开始<code>cv</code>写代码的redux新人, 会写出”在thunk里只dispatch一个action”的代码, 事实上这样的代码是不需要走thunk的, 直接return一个action, 而不是function.</p><h3 id="redux与vuex定位区别的总结"><a href="#redux与vuex定位区别的总结" class="headerlink" title="redux与vuex定位区别的总结"></a>redux与vuex定位区别的总结</h3><table><thead><tr><th>redux</th><th>vuex</th></tr></thead><tbody><tr><td>一个js写的数据结构库, 任何ui框架都可以使用, 虽然是为react打造的, vue和小程序等也有实践案例</td><td>一个vue专属的数据管理库</td></tr><tr><td>在react中使用需要用react-redux库来集成</td><td>内部实现直接利用vue实例的特性, 在一些地方还显式调用vue的api</td></tr><tr><td>只负责 mutate state, 其他功能要通过middleware让社区实现</td><td>state, mutation, action, module全包</td></tr><tr><td>灵活, 可有不同实践</td><td>可操作性少, 实践单一</td></tr></tbody></table><p>redux和vuex是典型的同质对立的库, 一个追求灵活和更大的可能性, 一个给用户更舒服顺畅的体验.</p><p>我们在实际使用中确实体会到了这样的感受: vuex使用顺畅, redux感觉需要些很多代码来初始化, 并且有很多不同的实践.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过了以上对redux的观察, 总结一下对react观念的更新:</p><h3 id="redux是一个纯js-提供一种数据流模式的库"><a href="#redux是一个纯js-提供一种数据流模式的库" class="headerlink" title="redux是一个纯js, 提供一种数据流模式的库."></a>redux是一个纯js, 提供一种数据流模式的库.</h3><p>优点是: 可以充分利用各种js特性来产生不同的实践, 第三方开源作者应该感到巨大的兴奋.</p><p>缺点是: 在项目中, 必须结合自己项目情况, 选择一种实践, 如果不思考实践方式, 就会导致”要写很多业务无关的代码”的问题.</p><h3 id="redux实践操作方式有3个方面"><a href="#redux实践操作方式有3个方面" class="headerlink" title="redux实践操作方式有3个方面"></a>redux实践操作方式有3个方面</h3><ol><li><p>reducer, action的组织, 编写辅助函数.</p><p>这个实践要根据项目目录结构, 来把所有项目的reducer和action组合到一起. (因为redux原则是1个根store)</p><p>在这个实践中可以解决”action type是否需要”, “action type是否可能重复导致难查的bug”问题.</p></li><li><p>改变store的增强器.</p><p>这个类型的改变是通过middleware进行的, 原因也很简单: 要获取dispatch来最终改变store.</p><p>比如异步操作, 事务, immutable原则等就是在这里操作的.</p></li><li><p>和ui框架的数据关联.</p><p>一般的redux实践库里都有个connect方法, 一般是个高阶函数, 来让ui框架和redux进行联动.</p></li></ol><p>之后去思考或者参考别人的实践, 应当也是从这3个方面分别去看.</p><p>当然也有把这些都整合起来的实践巨兽, 但本质还是从基本方面入手的.</p><h3 id="市面上流行的周边"><a href="#市面上流行的周边" class="headerlink" title="市面上流行的周边"></a>市面上流行的周边</h3><p>经过一些网上冲浪, 获得了一些周边的名字.</p><ul><li><p>redux官方提供的2个库: <code>react-redux</code>, <code>redux-toolkit</code>.</p><p><code>redux-toolkit</code>是一个很全的lib了. 虽然只有4个方法.</p></li><li><p>管理业务异步操作的: <code>redux-thunk</code>, <code>redux-saga</code>.</p></li><li><p>一整套大保健: <code>dva</code>.</p></li></ul><p>其实还找到了许多没名气的小实现, 以及同事推荐阿里新搞的基于hooks, 替代redux的<code>hox</code>.</p><p>这些库可能都会慢慢看, 一篇博客肯定下不下, 所以提个名字都不展开了.</p><p>最后, 还有3个同质的数据操作辅助函数库. <code>updeep</code>, <code>immutable.js</code>, <code>immer.js</code>. 粗看起来, <code>immer.js</code>是最强的. 体现方面是api和性能. 调研这些lib也作为todo了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将react项目迁移到hook和ts</title>
      <link href="/2020/06/28/migrate-to-hooks-and-ts/"/>
      <url>/2020/06/28/migrate-to-hooks-and-ts/</url>
      
        <content type="html"><![CDATA[<p>手里有一个没有历史包袱的react项目, 就成为了上hook和ts的好机会, 这里总结一下hook和ts最浅的实践.</p><span id="more"></span><p>首先做一个迁移后总结: hook和ts的初级使用非常简单, 而高级使用可能也没这么难, 总之比之前估计的难度要低很多.</p><p>本文做最简单的介绍和使用, 没有写的细节都在<a href="https://reactjs.org/docs/hooks-intro.html">hook</a>和<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">ts</a>的文档里.</p><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><h3 id="hook的形式"><a href="#hook的形式" class="headerlink" title="hook的形式"></a>hook的形式</h3><p>之前react有2种组件形式, 叫做class components, stateless components.</p><p>而现在改名成: class components, function components.</p><p>也就是: function components现在可以拥有state了, 就是hook给予的功能, 同时hook也给予了function components<strong>大多数</strong>class components可以实现的功能.</p><p>所以hook的基本形式就是基于FC, 增加了一些方法, 来丰富了FC可实现的功能.</p><h3 id="hook的优缺点"><a href="#hook的优缺点" class="headerlink" title="hook的优缺点"></a>hook的优缺点</h3><p>官方说的优点是:</p><ol><li>function比class更容易理解.</li><li>含有多个业务逻辑的大组件, 可以从分块整理, class components只能聚在一起.</li><li>比hoc, render props的集成方式更友好, 更灵活.</li></ol><p>后2条优点的思路是一样的: 都是利用了function的优势, 只要能提供实现一样功能的可能性, 那么FC就会更方便更灵活.</p><p>我认为的缺点是:</p><ol><li>并不能实现class components的所有功能.</li><li>一些行为和class components不一致.</li><li>react devtools的调试体验不习惯.</li></ol><h3 id="hook迁移经验"><a href="#hook迁移经验" class="headerlink" title="hook迁移经验"></a>hook迁移经验</h3><p>把class组件替换成function组件, 第一步就是把class改写成function, class中的this都去掉, class的方法写成内部function. 另外render函数的返回值, 直接作为function组件的返回值即可.</p><p>剩下的就是用hook来替代原先的一些功能:</p><ol><li><p><code>useState</code>用来替代state. </p><p>需要说的是, 这里可以根据具体需求来分成任意个state块. 然后在react devtools里看起来是和class的state不同的.</p></li><li><p><code>useEffect</code>用来替代3个生命周期函数. </p><p>第一个参数function会在初始化执行, 他的返回值函数(如果存在)会在销毁时执行. 第二个参数来判断是否需要在组件更新时执行第一个参数. </p><p>需要注意的是, 和<code>useState</code>一样, 他也可以被分块, 使复杂页面的代码看起来更清晰, 维护更方便.</p></li><li><p><code>useContext</code>, <code>useRef</code>也比较常用. 作用是class组件中的context和ref.</p></li><li><p><code>useLayoutEffect</code>的存在是因为<code>useEffect</code>和<code>componentDidMount</code>执行时间是有差异的, 一些要获取dom的方法需要用这个.</p></li></ol><p>另外, 有个<code>useReducer</code>, 这个和redux并不是一回事, react-redux提供了一些hook, 但也不是必用的, 直接用connect就可以了.</p><h3 id="更多场景"><a href="#更多场景" class="headerlink" title="更多场景"></a>更多场景</h3><p>迁移的过程都是用了hook的基本功能, 接下来要尝试的是用hook代替hoc和render props来抽取一些逻辑.</p><p>hook比hoc好的地方是, 使用方法是引入和调用, 而不是要嵌套dom.</p><p>那么自定义hook可以复用, 就涉及到了作用域问题, hook是如何控制作用域的, 内置的hook是如何编写的, 这个留给下次仔细深入.</p><h2 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h2><p>ts的作用是强制js类型, 是一种编译时工具.</p><h3 id="ts的形式"><a href="#ts的形式" class="headerlink" title="ts的形式"></a>ts的形式</h3><p>是现在使用的所有js的超集. 所以在形式上, 之前的js都兼容, 不用改语法, 只是增加一些内容.</p><p>在原有js上增加了哪些内容呢? 分为2个部分:</p><ol><li><p>在js变量后规定类型. </p><p>如: <code>let n = 1</code> &#x3D;&gt; <code>let n: number = 1</code>.</p></li><li><p>定义类型.</p><p>基本类型只有那几个, 那如果有一些项目特有的实体, 接口等. 就会自己定义一些, 使用<code>type</code>或者<code>interface</code>关键字.</p><p>如: </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> phoneSeries &#123;</span><br><span class="line"><span class="attr">series</span>: <span class="built_in">string</span></span><br><span class="line"><span class="attr">version</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">iphoneX</span>: phoneSeries = &#123; <span class="attr">serires</span>: <span class="string">&#x27;iphone&#x27;</span>, <span class="attr">version</span>: <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以ts比js就多了这2部分内容. 其他需要学习的就只是一些类型之间互相关系的概念.</p><p>接下来说我在用ts过程中思考过的2个问题.</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在尖括号出现的地方, 有2种可能, 一个是定义泛型, 一个是使用泛型.</p><p>使用泛型是一些预定义的泛型接口或者泛型类, 在学习概念的时候没理解这点, 以为所有尖括号都是定义泛型, 于是没理解.</p><h4 id="type和interface的区别"><a href="#type和interface的区别" class="headerlink" title="type和interface的区别"></a>type和interface的区别</h4><ol><li><p>定义直接的变量, 只能用type. 例如:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> age = <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> add = (<span class="attr">base</span>: <span class="built_in">number</span>, <span class="attr">increasement</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br></pre></td></tr></table></figure></li><li><p>联合类型只能type.</p></li><li><p>implements 只能interface.</p></li></ol><h3 id="ts的优缺点"><a href="#ts的优缺点" class="headerlink" title="ts的优缺点"></a>ts的优缺点</h3><p>几天以来使用ts的感受非常好, 缺点有2个: 需要学习, 需要配置工程化.</p><p>但工程化是一次性的, 或者可以用别人的. 就算没学好, 直接都any. 特别需要的地方定义类型就可以了.</p><p>所以在我看来上ts是好处远大于缺点的. 接下来说说<strong>实际使用中体会到的优点</strong>.</p><ol><li><p>相比eslint更能分析语法上的错误.</p><p>在迁移ts的过程中, 发现很多ts报错的地方, 确实代码有非常大的问题, 没出bug只是运气好.</p><p>即使不定义类型, ts有许多内置类型, 并有类型推导功能. 在一些操作<code>localStorage</code>等有副作用的代码, ts就能判断出没有写滤空.</p></li><li><p>使用组件时不用看文档了.</p><p>这点在开发上省去了很多时间. 有一个场景: 某个组件库的Api因为版本升级改变了, 于是ts直接报错, 并且按着cmd或者ctrl, 可以直接看到现在有哪些Api.</p></li><li><p>体验很好的生态.</p><p>上一条优点, 是基于那个组件库是用ts定义了类型的情况. 而当更多的引用都是基于ts的, 开发的时候感觉就会特别开心. (因此完全成为了vscode粉)</p></li></ol><h3 id="ts的迁移经验"><a href="#ts的迁移经验" class="headerlink" title="ts的迁移经验"></a>ts的迁移经验</h3><ol><li>在业务偏重的项目里, 我认为大多数地方用any就可以了. react预制的泛型类也都传any就可以.</li><li>在工具类和presentational组件尽量多地使用ts. 组件的react泛型类传入自定义的interface来替代proptypes.</li><li>很多lib都有ts使用手册, 有一些类, 了解后使用.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> hook </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端monorepo对依赖包的处理</title>
      <link href="/2020/06/03/monorepo-yarn-and-lerna/"/>
      <url>/2020/06/03/monorepo-yarn-and-lerna/</url>
      
        <content type="html"><![CDATA[<p>随着行业发展或者是公司发展, memorepo的概念走进了我的面前, 也许早就在行业里出现了. 不管memorepo会不会走下去, 先来了解一下.</p><span id="more"></span><h2 id="为什么会有monorepo"><a href="#为什么会有monorepo" class="headerlink" title="为什么会有monorepo"></a>为什么会有monorepo</h2><p>一个概念的出现一定是为了解决一些问题, 一个时代出现一个系列的工具是因为行业的生产工具发展到了一个阶段.</p><p>在前端, 关于多仓库的问题也分成不同场景, 所以相对的monorepo的使用也是不同的, 我们在不同场景的开发中可能遇到以下问题:</p><ul><li><strong>仓库多</strong>: 新人接手难, 维护项目的时候记住仓库名字难, 挑战电脑性能.</li><li><strong>重复安装npm依赖</strong>: 一个公司使用的基本框架大多是一样的. 有几个项目, react和antd或者vue和elementui就要装多少遍. 这些体积比较大的包重复装几十遍, 即使电脑硬盘够大, 让人心里也挺不舒服的.</li><li><strong>升级公共组件</strong>: 若一个公共组件进行了升级, 那么所有引用他的项目都要升级依赖.</li><li><strong>模块间的互相依赖</strong>: 在开发公共lib的时候需要调用其他模块, 要多次反复操作link, 还要记住各个包名.</li></ul><p>于是就出现了一个想法: 把多个仓库合成一个仓库, 每个仓库又可以独立运行, 有自己的<code>package.json</code>, 有自己的依赖和脚本, 复制出来是个可以独立运行的仓库.</p><p>把仓库合在一起, root仓库就可以对子仓库的信息进行处理, 来简化与管理子仓库的常规操作.</p><p>当然, 把仓库何在一起, 也会有一些显而易见的问题, 有的容易解决, 有的不容易解决, 有的可以通过工作流的上下游解决. 比如:</p><ul><li><strong>代码权限问题</strong>: 如果各个子仓库要控制代码权限, 那么git可能就不是monorepo契合的版本控制工具了.</li><li><strong>git分支问题</strong>: 虽然子仓库可以独立运行, 但版本控制还是在root仓库的, 一个仓库的分支要影响其他项目的, 这显然有问题. 这个问题可能可以通过工作流上下游的工具, 或者git-submodule来解决.</li></ul><p>权限问题和分支问题, 也可以通过合理组合仓库, 把功能, 关系密切的仓库合成一个仓库.</p><h2 id="yarn-workspace-vs-lerna"><a href="#yarn-workspace-vs-lerna" class="headerlink" title="yarn workspace vs lerna"></a>yarn workspace vs lerna</h2><p>前端的monorepo基本就靠这2个.</p><p>他们的模式都是在root仓库下建一个文件夹, 一般是<code>packages</code>, 然后里面的每个文件夹里都是一个子仓库. 他们也都提供了一些cli命令来处理上节所提到的问题. 他们有相似的功能点, 也有不同的功能点.</p><p>双方的官方都表示, 他们并不是同质竞争, 而是上下游合作关系, 在api体现了. 但就目前的情况看来, 还是有一些重复的api, 可能是lerna希望离开yarn也能活着.</p><p>具体来说, yarn的功能更接近于基层(当然了, 因为他是个npm client), 在依赖管理上做得更好. 而lerna的主战场并不在依赖管理, 而在npm版本和git, 脚本层面.</p><p>现在公司的使用场景里, 更需要的是对依赖包的管理, 所以用到lerna的地方比较少, 我尝试了下yarn的功能和效果, 进行了一些总结.</p><h2 id="实践细节"><a href="#实践细节" class="headerlink" title="实践细节"></a>实践细节</h2><p>把yarn和lerna进行对比, 基于yarn的功能对比, lerna还有很多其他的功能.</p><p>我的实验结果都基于yarn1.22.4版本.</p><h3 id="定义workspace"><a href="#定义workspace" class="headerlink" title="定义workspace"></a>定义workspace</h3><p><code>package.json</code>里有2个特点yarn就认为是有workspace的repo: </p><ol><li><code>private: true</code>.</li><li><code>workspaces: [&quot;packages/*&quot;]</code> 这是个快捷写法, 也可以在数组里写每个子workspace的name.</li></ol><p>在yarn0.x的版本里, workspace还要通过配置开启的. 1.x是默认开启的.</p><p>lerna的话, <code>lerna init</code>就行了, 在目录下会产生一个<code>lerna.json</code></p><h3 id="安装依赖的行为差异"><a href="#安装依赖的行为差异" class="headerlink" title="安装依赖的行为差异"></a>安装依赖的行为差异</h3><p>yarn安装<code>yarn</code>, lerna安装<code>lerna bootstrap</code>.</p><p>lerna的行为比较粗暴, 直接cd到每个子目录, 运行装包命令.</p><p>yarn就很智能, 分析每个<code>package.json</code>的内容, 智能安装, 后面细说.</p><h3 id="lerna与yarn一起使用"><a href="#lerna与yarn一起使用" class="headerlink" title="lerna与yarn一起使用"></a>lerna与yarn一起使用</h3><p>yarn提供了2个方法, 可以在一些行为上使用yarn的特点.</p><ol><li>执行cli时加 <code>--use-workspaces</code>.</li><li>lerna.json添加<code>&#123;“npmClient”: “yarn”, “useWorkspaces”: true&#125;</code>.</li></ol><h3 id="模块互相依赖"><a href="#模块互相依赖" class="headerlink" title="模块互相依赖"></a>模块互相依赖</h3><p>在这点上, yarn和lerna都做了处理, 只要定义了workspace或者lerna, 模块之间都可以通过软连接引用到, 并且优先内部引用.</p><h3 id="操作子模块"><a href="#操作子模块" class="headerlink" title="操作子模块"></a>操作子模块</h3><p>yarn和lerna操作子模块的思路是不同的.</p><p>yarn的思路: 指定一个模块, 然后执行命令; lerna的思路: 执行一个命令, 然后指定子模块.</p><ul><li><p>yarn: <code>yarn workspace (ws-name) add module</code>. </p><p>yarn也可以手动cd到子模块进行操作, 我尝试了<code>yarn</code>命令, 结果是不会忽视root模块, 执行结果是等同根目录执行的.</p><p>另外, <strong>yarn的workspace的子ws名字是根据<code>package.json</code>的name字段来的, 而不是文件夹名字.</strong> (别问我怎么知道的, 枯了)</p></li><li><p>lerna: <code>lerna add module --scope (ws-name)</code>. </p><p>lerna的<a href="https://github.com/lerna/lerna/tree/master/core/filter-options">filter-options</a>系统是支持glob的, 所以这点很明显强于yarn.</p></li></ul><p>yarn在2.x版本也尝试用lerna的思路, 增加了<code>yarn foreach --include/--exclude</code>的api. (但我切到了rc版本并没有实现, yarn为啥做文档有却没发布这这烂事儿)</p><h3 id="yarn是如何处理子模块依赖的"><a href="#yarn是如何处理子模块依赖的" class="headerlink" title="yarn是如何处理子模块依赖的"></a>yarn是如何处理子模块依赖的</h3><p>无论是在root层还是子ws层, 执行install和add的时候, yarn都会对模块依赖进行整理. 特点如下:</p><ul><li>依赖版本的记录只存在于root层的<code>yarn.lock</code>, 子ws不会有.</li><li>所有依赖优先安装在root下, 只有当子ws依赖于不同版本的相同包, 才会在子ws下产生node_modules.</li><li>如果有多个子ws, 拥有不同版本的相同包, 那么, 优先把相同版本多的安装到root下, 第二优先版本低的.</li><li>在每次add&#x2F;install操作后, yarn都会重新计算哪个版本的包应该在root, 并且进行文件移动操作. (也就是可能在一次add操作后, 某个子ws里的node_modules中的文件会减少)</li></ul><h3 id="yarn-add-W"><a href="#yarn-add-W" class="headerlink" title="yarn add -W"></a>yarn add -W</h3><p>最后, 有一些dev dependency, 需要在root里写在script里的, 可以通过这个命令硬装到最外层node_modules里.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux学习笔记</title>
      <link href="/2020/05/26/redux/"/>
      <url>/2020/05/26/redux/</url>
      
        <content type="html"><![CDATA[<p>因为redux特别简单, 所以学习一下.</p><p>记得用了vue半年的时候学了下vuex, 现在用了react半年, 同样学一下redux.</p><span id="more"></span><p>相比之下, redux比vuex简单多了. redux与react没有强关联, vuex在内部调用了vm; redux的api没有namespace概念.</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>首先, redux的作用是: 在内存中管理一组数据, 并使web应用的各处可以获取&#x2F;修改.</p><p>基于这个核心作用, 设计还增加一些额外的目的, 比如api简便, 拓展性好(本身拓展性和应用拓展性), 容易debug等.</p><p>redux只有3个核心概念: </p><ul><li>store: 储存数据的对象.</li><li>reducer: 描述如何改变store.</li><li>action: 描述调用哪个reducer.</li></ul><p>redux还有一个特点: <strong>no magic</strong>. 没有元编程, 没在对象上挂一些小东西. 因此redux也非常简单, 便于学习.</p><p><strong>除去订阅功能, redux所有功能的代码只有35行.</strong> 这里就用一整篇文章来讲讲这35行代码.</p><p>阅读redux代码能学到2点: ts语法, 闭包的应用(或者叫函数式编程?).</p><p>换个说法是, 对ts和函数式编程很熟悉的可以秒懂redux所有东西.</p><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createStore</span> = (<span class="params">reducer, initState</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> state = initState</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getState</span> = (<span class="params"></span>) =&gt; state</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dispatch</span> = action =&gt; state = <span class="title function_">reducer</span>(state, action)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用createStore, 获得了一个有2个方法的对象.</li><li>一个内部变量state储存在内存里没有被释放.</li><li>2个方法, 分别是用来获取和改变state.</li></ol><p>写到这里, 我们已经可以使用redux了. 当然需要一些对reducer的理解, 如果理解可以跳过.</p><blockquote><p>reducer是描述state如何变化的<strong>纯函数.</strong> (就是每个输入都对应唯一的输出, 数学中的函数)</p><p>reducer接受2个参数: 当前state, 和约定描述如何变更state的对象: action.</p><p>reducer的输出: 下一个state.</p></blockquote><p>这里写一个最简单的计数器. (action在redux中也有规范, 必须有type键)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increase&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> + (action.<span class="property">payload</span> || <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, initState)</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">getState</span>() <span class="comment">// &#123;count: 0&#125;</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;increase&#x27;</span>, <span class="attr">payload</span>: <span class="number">1</span>&#125;)</span><br><span class="line">store.<span class="title function_">getState</span>() <span class="comment">// &#123;count: 1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="可有可无的3个helperAPI"><a href="#可有可无的3个helperAPI" class="headerlink" title="可有可无的3个helperAPI"></a>可有可无的3个helperAPI</h2><p>接下来介绍3个只是为了使用方便的api. 甚至可以作为简单的3分钟内可以答出的面试题.</p><h3 id="改造action"><a href="#改造action" class="headerlink" title="改造action"></a>改造action</h3><p>每次<code>store.dispatch(&#123;type: &#39;increase&#39;, payload: 1&#125;)</code>感觉不合适, 我们期望可以<code>store.dispatch(increase(1))</code>这样调用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">increase</span> = num =&gt; (&#123;<span class="attr">type</span>: <span class="string">&#x27;increase&#x27;</span>, <span class="attr">payload</span>: num&#125;)</span><br></pre></td></tr></table></figure><p>这里的increase叫做<code>actionCreator</code>, 因为执行结果是一个action.</p><p>在实际项目里, 这样的actionCreator还会有好多, 比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">decrease</span> = num =&gt; (&#123;<span class="attr">type</span>: <span class="string">&#x27;decrease&#x27;</span>, <span class="attr">payload</span>: num&#125;)</span><br></pre></td></tr></table></figure><p>每次都要调用store.dispatch, 还有好多个方法, 好像也很麻烦.</p><p>不如把他们再包装一层, 把dispatch包进去, 并把方法挂到一个对象上, 我们期望调用方法是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = <span class="title function_">bindActionCreators</span>(&#123;increase, decrease&#125;, store.<span class="property">dispatch</span>)</span><br><span class="line">actions.<span class="title function_">increase</span>(<span class="number">1</span>) <span class="comment">// =&gt; store.dispatch(increase(1))</span></span><br><span class="line">actions.<span class="title function_">decrease</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>如果有兴趣可以自己写一下这个<code>bindActionCreators</code>方法.</p><h3 id="改造reducer"><a href="#改造reducer" class="headerlink" title="改造reducer"></a>改造reducer</h3><p>vuex有module的概念, redux的分模块的方法是: 把根模块的每个键作为子模块名字, 值作为子模块. 我们把state改造下, 计数器变成一个模块, 再造个新模块叫status记录一个布尔值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  <span class="attr">count</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">status</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">count</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increase&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: state.<span class="property">value</span> + (action.<span class="property">payload</span> || <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrease&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: state.<span class="property">value</span> - (action.<span class="property">payload</span> || <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">status</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;switch&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: !state.<span class="property">value</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state, action</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="title function_">count</span>(state.<span class="property">count</span>, action),</span><br><span class="line">  <span class="attr">status</span>: <span class="title function_">status</span>(state.<span class="property">status</span>, action),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很巧妙地, 在调用reducer的时候, reducer没有直接处理, 而是<strong>把对应的state交给对应的子模块处理, 并把处理结果赋值给对应子模块的在根state的键.</strong> 子reducer是一个可以脱离树而独立存在的reducer, 真是妙啊.</p><p>但是, 这个组合reducer的函数明显有可以优化的地方: 每个子模块的构成模式是一样的, state和action每次都要写.</p><p>所以我们希望可以写成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="title function_">combineReducers</span>(&#123;count, status&#125;)</span><br></pre></td></tr></table></figure><p>那么<code>combineReducers</code>就作为第二个思考题.</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>这个helper函数除了redux, 在lodash和ramda里也有用到. 作用是把<code>a(b(c(...args)))</code>写成<code>compose(c, b, a)(...args)</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...funcs</span>) =&gt; funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">a</span>(<span class="title function_">b</span>(...args)))</span><br></pre></td></tr></table></figure><p>这个方法是为后面的applyMiddleware准备的. 总结如下:</p><ul><li>从右到左一次执行方法, 把执行结果, 作为参数传给下个方法.</li><li>(由上条推出)最后边的方法可以接受多个参数, 而其他方法只能接受一个参数.</li><li>在后面的applyMiddleware的设计中, 会正好把调用中间件的顺序正过来.</li></ul><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>这是最后, 也是最复杂的redux的api.</p><p>但目的比较简单: **允许用户改写dispatch方法. ** 并且可以允许多个中间件同时加载.</p><p>加上一些阻止非法操作和增加api便利性, 就写成了最终的applyMiddleware方法.</p><p><a href="https://redux.js.org/advanced/middleware#attempt-1-logging-manually">文档</a>上有一系列推导, 比较精彩, 这里就直接说最后结论.</p><ol><li><p>利用<code>compose</code>的特点, 上个函数的<strong>执行结果</strong>作为下个函数的<strong>参数</strong>, 只要给第一个函数传入dispatch, 所有函数的返回值都是(经改写的)dispatch. 最后的直接结果是一个经过所有middleware改写的dispatch, 再把这个dispatch赋值到原来的dispatch.</p><p>因为必须执行一下自己的参数才能完成middleware的使命(只要有不执行, 原来的dispatch就不会执行, 后面会解释), 所以给了这个参数一个很好的名字<code>next</code>.</p></li><li><p>redux还希望在中间件里暴露store的dispatch和getState给用户, 所以规定中间件的写法再多加了一层闭包, 把store.dispatch和store.getState传给用户.</p></li></ol><p>下面来看2个常用的middleware, 并尝试用他们来改写store的dispatch方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果dispatch一个方法而不是action, 就调用这个方法, 并把一些参数给他使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">thunk</span> = store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">action</span>(store.<span class="property">dispatch</span>, store.<span class="property">getState</span>) : <span class="title function_">next</span>(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在dispatch的前后打印一些信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logger</span> = store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dispatching&#x27;</span>, action)</span><br><span class="line">  <span class="title function_">next</span>(action)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next state&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到好多箭头, 那么第一个箭头是store, 我们先调用一次把store保留到内存里.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thunkWithStore = <span class="title function_">thunk</span>(store)</span><br><span class="line"><span class="keyword">const</span> loggerWithStore = <span class="title function_">logger</span>(store)</span><br><span class="line"><span class="comment">// 此时这两个函数就是: (以下是不是代码, 为了高亮没有注释)</span></span><br><span class="line">thunkWithStore = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">action</span>(store.<span class="property">dispatch</span>, store.<span class="property">getState</span>) : <span class="title function_">next</span>(action)</span><br><span class="line">&#125;</span><br><span class="line">loggerWithStore = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dispatching&#x27;</span>, action)</span><br><span class="line">  <span class="title function_">next</span>(action)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next state&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的2个方法, 已经把<code>next</code>作为参数, 返回的是一个方法, 只要在方法里调用<code>next</code>就可以继承上一层, 不需要return(官方文档都return, 我认为没必要, 也造成了迷惑).</p><p>那么我们暂时不用compose, 把这些方法串起来, 会更容易理解:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">dispatch</span> = <span class="title function_">thunkWithStore</span>(<span class="title function_">loggerWithStore</span>(store.<span class="property">dispatch</span>))</span><br></pre></td></tr></table></figure><p>我们把这些变量代入, 看看得到了什么:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">dispatch</span> = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">action</span>(store.<span class="property">dispatch</span>, store.<span class="property">getState</span>) </span><br><span class="line">  : <span class="comment">// 下面这行开始是thunkWithStore的next(action), 因为next方法已经调用, 其实第四行和第八行可以去掉</span></span><br><span class="line">  (<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dispatching&#x27;</span>, action)</span><br><span class="line">    store.<span class="title function_">dispatch</span>(action) <span class="comment">// 这里是loggerWithStore的next(action)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next state&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">  &#125;)(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看出以下结论:</p><ul><li><p>只有每个middleware都调用next, 最后一个next就是最初的store.dispatch, 而每个middleware对dispatch的包装也都会依次执行.</p></li><li><p>compose说是从右到左组合方法, 但后组合的方法会被先执行, 所以直觉上, 传入compose的方法会被依次调用.</p></li><li><p>只要有一个middleware不调用next方法, 原来的dispatch将不会被触发.</p><p>(所以如果thunk里dispatch一个方法, 这次dispatch就断掉了, dispatch一个方法其实是一次假的dispatch, 只是可以做到把异步请求从业务代码里移到actionCreators里而已.)</p></li></ul><p>最难的地方已经结束, 如果已经看懂, 那么下面的推导也非常容易:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在是这样</span></span><br><span class="line">store.<span class="property">dispatch</span> = <span class="title function_">thunkWithStore</span>(<span class="title function_">loggerWithStore</span>(store.<span class="property">dispatch</span>))</span><br><span class="line"><span class="comment">// 使用compose以后:</span></span><br><span class="line">store.<span class="property">dispatch</span> = <span class="title function_">compose</span>(thunkWithStore, loggerWithStore)(store.<span class="property">dispatch</span>)</span><br></pre></td></tr></table></figure><p>applyMiddleware的核心部分已经说完, 最后再进行2个小改造就完事了:</p><ul><li>先用一个空方法代替真正的dispatch, 防止在middleware构造的过程中调用造成死循环.</li><li>因为每个middleware都会造成好几层闭包, 为了避免重复加载, 不让用户自己写<code>store.dispatch = xxx</code>, 把apply的动作和createStore绑在一起.</li></ul><p>这个改动会使applyMiddleware和createStore产生一些联动, applyMiddleware被传入createStore后, createStore会用applyMiddleware的返回值改写自己, 用改写后的自己重新调用剩余参数. 所以文档里的写法是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, initState, <span class="title function_">applyMiddleware</span>(mdw1, mdw2))</span><br></pre></td></tr></table></figure><p>我们也可以把它写成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">applyMiddleware</span>(mdw1, mdw2)(reducer, initState)</span><br></pre></td></tr></table></figure><p>(那好像文档的写法好看很多.)</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在过程中有个小插曲, 因为自己菜一直没看懂一个基础的东西:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">dispatch</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;empty function&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> middlewareApi = &#123;</span><br><span class="line">  <span class="attr">getState</span>: store.<span class="property">getState</span>,</span><br><span class="line">  <span class="attr">dispatch</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">dispatch</span>(...args), <span class="comment">// 为什么不是 dispatch: dispatch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> chain = middlewares.<span class="title function_">map</span>(<span class="function"><span class="params">middleware</span> =&gt;</span> <span class="title function_">middleware</span>(middlewareApi))</span><br><span class="line">dispatch = <span class="title function_">compose</span>(...chain)(store.<span class="property">dispatch</span>)</span><br></pre></td></tr></table></figure><p>如果改写成<code>dispatch: dispatch</code>, 最后一句的重新赋值就会无效.</p><p>在询问了大佬后知道了是引用方式不同. 那么怎么区别什么状况下是什么引用方式呢, 我发现了个比较好的办法: console.log.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">log</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 定义log方法, 通过不同引用, 之后改写尝试是否被改掉</span></span><br><span class="line"><span class="keyword">let</span> quoteValue = &#123;<span class="attr">log</span>: log&#125; <span class="comment">// 值传递</span></span><br><span class="line"><span class="keyword">let</span> quoteAddress = &#123;<span class="attr">log</span>: <span class="function">() =&gt;</span> <span class="title function_">log</span>()&#125; <span class="comment">// 地址传递</span></span><br><span class="line"></span><br><span class="line">quoteValue.<span class="property">log</span> <span class="comment">// () =&gt; console.log(1)</span></span><br><span class="line">quoteAddress.<span class="property">log</span> <span class="comment">// () =&gt; log()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面已经看得出, 如果log方法改变, quoteValue.log调用还是老的, 因为老的值已经被传给他了</span></span><br><span class="line"><span class="comment">// 而quoteAddress的行为是调用log, 所以log变成什么样, 他都会调用新的log.</span></span><br><span class="line"></span><br><span class="line">log = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">quoteValue.<span class="title function_">log</span>() <span class="comment">// 1</span></span><br><span class="line">quoteAddress.<span class="title function_">log</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>最后献上一段完整demo.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createStore</span> = (<span class="params">reducer, initState, enhancer</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (enhancer) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">enhancer</span>(createStore)(reducer, initState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> state = initState</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getState</span> = (<span class="params"></span>) =&gt; state</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dispatch</span> = action =&gt; state = <span class="title function_">reducer</span>(state, action)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helpers</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bindActionCreators</span> = (<span class="params">actionCreators, dispatch</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">keys</span>(actionCreators).<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, key</span>) =&gt;</span> &#123;</span><br><span class="line">  result[key] = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">dispatch</span>(actionCreators[key](...args))</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">combineReducers</span> = reducers =&gt; <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(reducers).<span class="title function_">reduce</span>(<span class="function">(<span class="params">reducer, key</span>) =&gt;</span> &#123;</span><br><span class="line">  reducer[key] = reducers[key](state[key], action)</span><br><span class="line">  <span class="keyword">return</span> reducer</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...funcs</span>) =&gt; funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">a</span>(<span class="title function_">b</span>(...args)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">applyMiddleware</span> = (<span class="params">...middlewares</span>) =&gt; <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> store = <span class="title function_">createStore</span>(...args)</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">dispatch</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;empty function&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> middlewareApi = &#123;</span><br><span class="line">    <span class="attr">getState</span>: store.<span class="property">getState</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">dispatch</span>(...args),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> chain = middlewares.<span class="title function_">map</span>(<span class="function"><span class="params">middleware</span> =&gt;</span> <span class="title function_">middleware</span>(middlewareApi))</span><br><span class="line">  dispatch = <span class="title function_">compose</span>(...chain)(store.<span class="property">dispatch</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...store,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sample</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  <span class="attr">count</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">status</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">count</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increase&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: state.<span class="property">value</span> + (action.<span class="property">payload</span> || <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrease&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: state.<span class="property">value</span> - (action.<span class="property">payload</span> || <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">status</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;switch&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: !state.<span class="property">value</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="title function_">combineReducers</span>(&#123; count, status &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// middleware</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">thunk</span> = store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">action</span>(store.<span class="property">dispatch</span>, store.<span class="property">getState</span>) : <span class="title function_">next</span>(action)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logger</span> = store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dispatching&#x27;</span>, action)</span><br><span class="line">  <span class="keyword">let</span> result = <span class="title function_">next</span>(action)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next state&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action creator</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">inc</span> = num =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increase&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: num,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">delayInc</span> = num =&gt; <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start dispatch&#x27;</span>)</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;increase&#x27;</span>, <span class="attr">payload</span>: num&#125;)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, initState, <span class="title function_">applyMiddleware</span>(logger, thunk))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = <span class="title function_">bindActionCreators</span>(&#123;inc, delayInc&#125;, store.<span class="property">dispatch</span>)</span><br><span class="line"></span><br><span class="line">actions.<span class="title function_">inc</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">actions.<span class="title function_">delayInc</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是让人幸福的美德</title>
      <link href="/2020/04/19/moral-and-sentiments-1/"/>
      <url>/2020/04/19/moral-and-sentiments-1/</url>
      
        <content type="html"><![CDATA[<p>在与人交往中会有快乐, 亦会有痛苦. </p><p>这个快乐与痛苦的本质是什么, 是出于人性的哪些本质?</p><p>如何更多获取快乐, 而避免痛苦, 我们应该如何做?</p><span id="more"></span><p>本文总结了道德情操论第一卷<code>论行为的合宜性</code>, 比较细腻地分析了日常中快乐与痛苦的源头.</p><h2 id="与人交往过程中产生快乐与痛苦的原因"><a href="#与人交往过程中产生快乐与痛苦的原因" class="headerlink" title="与人交往过程中产生快乐与痛苦的原因"></a>与人交往过程中产生快乐与痛苦的原因</h2><p>要了解社交过程中产生快乐与痛苦的原因, 先要理解一个基础概念:</p><h3 id="同情"><a href="#同情" class="headerlink" title="同情"></a>同情</h3><p>本文所有的同情都包含共情快乐的事与不快乐的事. </p><p>同情是一个存在于人性中的东西, 即使再恶劣的人内心也是存在同情的.</p><p>看到别人的快乐或悲伤, 我们也会感到快乐或悲伤, 就是同情. 而**同情的基础是自己的感官, 自己的感受. 因为我们无法真正体验他们的感受, 我们没有, 也不可能有其他的方式产生同情. **我们以自己的感官来猜测别人的感官, 以自己看见的猜测别人看见的, 以自己感受到的来猜测别人感受到的.</p><p>而正是因为同情的性质, 同情是会产生偏差的.</p><h3 id="同情的偏差"><a href="#同情的偏差" class="headerlink" title="同情的偏差"></a>同情的偏差</h3><p>因为同情基于自己的感官, 感受. 而理论上说, 大多数人的感官是相同的. 所以同情的偏差一般出现在两种情况下:</p><ul><li>没有触发相同的感官. 树是绿色的, a和b看到了, 于是他们的互相同情是没有偏差的. 而a撞到了膝盖, b没撞到. 此时b对a的同情是有限的, 有偏差的, 因为没有触发相同的感官.</li><li>思维模式的偏差. 在<a href="/2020/02/15/behavioral-biases-we-are-experiencing/#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E7%9F%A5">上篇博客</a>中也解释了什么是认知方式(也可以称作不同的人格). 发生同一件事情, 不同的人得到的结论是不同的, 这是基于当事人的成长&#x2F;教育环境的.</li></ul><p>这里说三个同情偏差的例子.</p><ul><li>一个还不会说话的小孩生病了, 哭. 大人非常心急, 因为猜测孩子非常痛苦才会哭. 其实可能孩子不是很痛苦, 没有很难受, 只是有一点点不适, 但不会说话, 只会哭. 大人高估了孩子的痛苦, 是因为以自己生病经历的痛苦来猜测孩子的痛苦.</li><li>我们认为什么是死亡? 再也不能与亲人见面, 不能与亲人说话, 再也不知道世上发生了什么事, 甚至身体也不再拥有了. 我们都非常恐惧死亡. 这也是一种同情偏差. 我们把活人的灵魂放到了死人的身体上. 事实上死亡的人就和睡觉一样, 没有痛苦.</li><li>最后个例子是我自己的感受. 我经常会有这样的感受: 这个年轻人胆子真大, 等和我一样的年纪了比我有出息多了. 细想后觉得这是一种同情偏差. 所谓”初生牛犊不怕虎”. 也许那个年轻人不是比我勇敢, 而是对失败以后的痛苦程度预期比我低.</li></ul><h3 id="互相同情的愉快"><a href="#互相同情的愉快" class="headerlink" title="互相同情的愉快"></a>互相同情的愉快</h3><p>这个章节的观点是本文的核心, 重点结论都写在了颜色块里.</p><p>上节介绍了每个人都有同情的能力, 那么当我们感受到别人与自己互相同情, 就会产生快乐了. </p><blockquote><p>​互相同情会产生愉快. (并不是所有的互相同情都会产生愉快)</p></blockquote><p>一个获得互相同情的例子: 我看到了美景, 开心地微笑, 看到身旁的朋友也在微笑, 感觉对方能体会自己的感受, 于是互相都产生了愉快的感觉. (但也不是所有的互相同情都会产生愉快, 下一章节会分析能够产生愉快的互相同情)</p><p>一个希望得到互相同情的例子: 读了一本书, 很快乐, 推荐朋友读, 希望他也学到知识的快乐. 或者是: 把自己喜欢的歌外放得很响(比自己单独听更响), 是希望别人也喜欢这首歌.</p><p>一个没有获得互相同情的例子: 我讲了一个笑话, 觉得很好笑, 大家都没怎么笑, 我觉得很尴尬.</p><p>根据没有获得同情的例子, 我们能感受到另外一个规律:</p><blockquote><p>​没有得到互相同情会令人不愉快.</p></blockquote><p>另外, 获得同情的情况也分为两种: 愉快心情的同情, 与不愉快心情的同情.</p><p>愉快的时候被同情, 会产生更多的愉快. 而不愉快时候被同情, 会减轻被同情方的痛苦.</p><p>愉快被同情产生的快乐程度, 与不愉快时被同情减轻的痛苦程度, 是不同的:</p><blockquote><p>人在不愉快的时候, 更希望得到同情, 不被同情也感到更难过. (都是与愉快情感被同情比较而言)</p></blockquote><p>在这基础上有一个推论: <strong>爱是愉快的, 恨是不愉快的. 所以我们希望朋友理解自己的恨的迫切, 甚于要求他们接受自己的友谊.</strong> 换个说法, 同甘不如共苦. 人类在苦的时候需要朋友, 而在快乐的时候不那么需要.</p><p>另外, 相反地, 我们也因为可以同情别人而感到快乐. 同样会因为不能完全同情别人而难过:</p><blockquote><p>感到自己不能同情对方也是不愉快的, 并且会尝试把自己的不愉快归咎到对方身上. </p></blockquote><p>如果一个朋友因为自己的苦痛而大哭, 我们会尝试理解他, 当对他的痛苦不能理解到需要大哭的程度, 我们就把他看作胆小和软弱. </p><p>同样地, 如果不能理解一个人的快乐产生的兴奋和激动的程度, 就会把他作为轻率和愚蠢.</p><p>如果同伴们听到一个笑话大声笑个不停, 超出了我们认为应有的分寸, 我们甚至会大发脾气.</p><h3 id="互相同情的表现"><a href="#互相同情的表现" class="headerlink" title="互相同情的表现"></a>互相同情的表现</h3><p>互相同情我认为就是<strong>互相理解.</strong> 理解当事人的情绪, 以及情绪的程度. 并且我们的理解<strong>是从情绪产生的原因出发思考的, 而不是去关心情绪会产出的结果.</strong> 所以人们<strong>经常会为不值得快乐的事而快乐, 为不值得难过的事而难过.</strong> (我认为这也是一个跳出情绪的技巧 – 发生不好情绪的时候, 可以思考当下的事件是不是不会导致很坏的结果.)</p><p>那么回头讨论: 什么样的互相理解, 会使人愉快. 如果可以理解当事人, 一般会表现为:</p><ul><li>与当事人表现出相同程度的情绪.</li><li>赞同, 接受当事人的建议.</li><li>在一些特殊情况下, 没有表示任何情绪和赞同, 但也可以是理解的. 例如在别的程度比较深的情绪中, 听了一个笑话, 觉得是好笑的, 但没能笑出来.</li></ul><h3 id="对客观事件的情况与对一方有特殊影响的情况"><a href="#对客观事件的情况与对一方有特殊影响的情况" class="headerlink" title="对客观事件的情况与对一方有特殊影响的情况"></a>对客观事件的情况与对一方有特殊影响的情况</h3><p>对客观事件的互相同情是很容易的. 比如: 树是绿的, 风景是美的. 因为所有人类的身体结构都是类似的, 对这些客观事物的感觉也是类似的.</p><p>但在这个情况下, 互相同情能引起的愉快不强烈. 只有在一些条件下, 这样的同情可以引起钦佩和称赞.</p><p>一个人断定美人比畸形者好看, 或是2 + 2 &#x3D; 4, 都会引起所有人的赞同, 但不会得到钦佩.</p><p>在有人说出比较复杂, 细腻地分析事情的本质, 这个本质又能引起其他人的同情(因为描述的虽然复杂, 但是事实). 就会引起其他人的钦佩.</p><p>另外一种是对当事者有特殊影响的情况: 当不幸落在当事人头上, 而旁观者又很难真正体会, 于是导致了双方无法站在同一角度来看到问题, 就会导致互相同情的难度大大增加. <strong>要使这种情况产生互相同情很困难, 又极为重要.</strong></p><p>但有一点: 旁观者会尽量去体会当事者的不幸, 以产生同情. 同样的, 当事者也知道对方同情自己是困难的, 所以也会尽量去降低自己因不幸而表现出的激情程度.</p><p>而当旁观者不是熟人, 而是一个泛泛之交的时候, 当事者会降低对旁观者的要求, 他并不期望一个从一个泛泛之交那里获得很多同情. 所以导致了<strong>一个点头之交比一个朋友更能使我们从不幸中平静下来.</strong> 所以在这种情况下的结论是: <strong>通过与不熟悉的人交际与谈话, 更容易在不幸中控制心情, 获得平静和愉快心情.</strong></p><h3 id="两种美德"><a href="#两种美德" class="headerlink" title="两种美德"></a>两种美德</h3><p>上面说的这两种努力, 即旁观者努力体谅当事人的感情和当事人努力把自己的情绪降低到旁观者能够体谅的程度, 这样两个基础上, 确立了两种不同的美德.</p><p>在前一种努力的基础上, 确立了温柔, 有礼, 和蔼可亲的美德, 确立了公正, 谦让和宽容仁慈的美德.</p><p>而后一种努力的基础上, 确立了崇高, 庄重, 令人尊敬的美德, 自我克制, 自我控制和控制各种激情, 它们使我们出乎本性的一切活动服从于自己的尊严, 荣誉和我们的行为所需的规矩的美德.</p><p>这两种美德的共同点是: 在不容易互相同情的情况中, 通过自己的努力像对方靠近, 使双方产生互相理解.</p><h2 id="容易与不容易产生互相同情的各种情况"><a href="#容易与不容易产生互相同情的各种情况" class="headerlink" title="容易与不容易产生互相同情的各种情况"></a>容易与不容易产生互相同情的各种情况</h2><p>美德产生于不容易互相理解的情况, 那么这个章节总结一下分别在哪些情况下, 互相同情容易或不容易产生.</p><h3 id="从肉体产生的激情VS-从想象产生的激情"><a href="#从肉体产生的激情VS-从想象产生的激情" class="headerlink" title="从肉体产生的激情VS.从想象产生的激情"></a>从肉体产生的激情VS.从想象产生的激情</h3><p>从肉体产生的激情难以被同情. 从想象产生的激情容易被同情.</p><p>肉体产生的激情典型的有: 想吃东西的欲望, 男女之间的欲望, 疼痛. 如果把由这些事情产生的激情表现得很激烈, 就会使别人难以同情, 而引起反感. 肉体产生的激情难以被同情的原因是: <strong>人都会很容易, 并且很快地忘记肉体的激情, 并且很难重新体会这些激情.</strong> 举几个很容易理解的例子:</p><ul><li>人吃好饭就会吩咐快点撤去餐盘, 并且认为做菜是开心的事, 洗碗是麻烦的事.</li><li>男女之间的激情以后就觉得索然无味.</li><li>痛是最容易被人忘掉的东西. “好了伤疤忘了疼”.</li></ul><p>相比之下, 由想象产生的激情就容易被同情. 试想一个故事, 一个倾家荡产的人, 他很健康没身体上的痛苦. 但他所感受到的尊严的丧失, 朋友的怠慢, 敌人的蔑视等等的惨境都会使我们可以完全同情他.</p><p>下面举2个例子来体会肉体产生的激情与想象产生的激情:</p><ul><li>失去腿和失去情人哪个更痛苦? 但成功的悲剧只有描写失去情人的.</li><li>和人打架了, 打完再回想也不会难过. 而和朋友吵架了, 回想还是会和当时程度相当地生气. (如果你认为回想打架是生气的, 那么生气的是事情还是疼痛?)</li></ul><h3 id="由于想象的特殊倾向或习惯而产生的激情"><a href="#由于想象的特殊倾向或习惯而产生的激情" class="headerlink" title="由于想象的特殊倾向或习惯而产生的激情"></a>由于想象的特殊倾向或习惯而产生的激情</h3><p>这个类别的激情是难以被同情的. 因为特殊倾向或习惯都是需要时间培养, 而同情是需要快速理解才能产生的(是直接的而不是间接的也是这个原因导致的).</p><p>比较通常的例子就是长期积累的知识和长期积累的亲人间的感情.</p><p>长期积累起来的知识和感情都是私人专属的, 别人能理解的部分非常小. 例如: 家长看到孩子成绩进步, 把情绪的高兴程度完全表现出来会获得别人的反感; 长期的情侣因为对方的摔伤而向朋友表示了自己的悲伤程度, 也会得到朋友的反感; 自己因为长期学习而获得的知识推出了结论而产生的情绪表达也会遭到别人的轻视.</p><p>这里要解释一下, 为什么一些爱情故事那么感人, 不是说男女之间的感情旁人是同情不了的吗? 是的, 仔细思考, 我们并不是因为男女主角的感情而同感, 而只是因为一些爱情之外附属的感情而快乐与伤悲, 比如: 人道, 宽容, 仁慈, 友谊, 尊敬, 或者是恐惧, 羞涩, 悔恨, 憎恶, 失望. 这些感情都是容易被同情的.</p><h3 id="不友好的激情"><a href="#不友好的激情" class="headerlink" title="不友好的激情"></a>不友好的激情</h3><p>不友好的激情是难以被同情的. 原因需要简单地分析一下.</p><p>不友好的激情是指憎恶和愤怒. 而憎恶和愤怒一定是有对象的.</p><p>人在尝试与别人互相同情的时候, 是没有指定对象的. 会尝试同情当事人, 也会尝试同情当事人愤怒的对象.</p><p>而比较明显的是: 对 被发怒对象 的同情越多, 就会对发怒者的同情减少, 反之亦然. 对立的情绪能受到的同情也是对立的, 旁观者就必须把一份同情分给双方, 也就几乎无法同情任何一个人. 除非有一方完全不被同情, 旁观者就可以同情另一方了.</p><p>那么引起另外一个问题: 如何与对立情绪的对象争夺有限的同情? 总结是: <strong>人的情绪是直接的, 而不是间接的.</strong></p><p>问2个问题: 1. 监狱与宫殿, 更喜欢哪个? 2. 有两组纪念品, 一组是泥制的乐器和农具, 另一组是手术器械, 解剖刀, 截肢刀, 更喜欢哪个?</p><p>来解析一下问题: 监狱管理犯人, 使社会更有序; 宫殿助长奢侈豪华, 不利于公众. 而监狱给人的直接感觉是控制人的自由, 宫殿给人的直接感觉是舒适的生活. 第二个例子也是类似, 手术器械可以恢复病人的健康, 但直接的感受是疼痛和受苦.</p><p>而在一般的情绪对立中, 从直接的角度: 笑容, 平静, 快乐是容易被同情的; 憎恶, 仇恨是不容易被同情的.</p><p>也就是说: 无论事实如何, 在对立的情绪中, 保持笑容和平静可以使你获得更多的同情; 表现愤怒和憎恨会让你的对立对象获得更多的同情. 无论事实是谁对谁错. 同样的, 占理不饶人也会使旁观者的同情倾向不占理者.</p><h3 id="友好的激情"><a href="#友好的激情" class="headerlink" title="友好的激情"></a>友好的激情</h3><p>友好的激情容易受到人的好感. 原因是与不友好的激情类似的. 友好的激情的目标对象会和发起激情的人情绪一致. 旁观者只要同情一个人, 就可以同情到另一个人, 那么可以获得2份互相同情带来的愉快. 所以友好的激情通常很容易获得别人的好感.</p><h3 id="自私的激情"><a href="#自私的激情" class="headerlink" title="自私的激情"></a>自私的激情</h3><p>自私的激情是指没有表示情绪的特定对象. 一般自私的激情希望被同情的表现为: 向别人说自己的经历.</p><p>我们先直接说关于自私的激情如何获得互相同情的结论:</p><blockquote><p>​我们通常极易同情轻度的高兴和沉重的悲哀.</p></blockquote><p>相对的, 程度高的高兴和程度轻的悲哀, 不容易被同情. 原因是人类还存在2种基本的感情, 我们一一来分析.</p><p>对于高兴的自私的激情, 我们要避免的是: 在获得比较大的幸运的时候, 不能表现出很高程度的开心, 因为<strong>人类有嫉妒的本能</strong>. 举一个简单的例子:</p><p>在几个平级的朋友中, 一个人突然获得了社会地位和财富的大幅度提高. 如果这个人有较高的美德, 他会穿的用的和平时一样, 对老朋友比平时更谦卑. 因为他知道他的朋友认为**他应该更加同情我们对他幸福的嫉妒和嫌恶之情，而不是我们应该对他的幸福表示同情. ** 这是非常难的, 这要放弃自己对获得别人认可的需求, 还要克制对这种拘束的厌倦. 所以最好的情况还是: 慢慢的进步, 大家都认为他该上一层的时候, 才上一层. 突然的幸运可能对一个人来说是灾难.</p><p>对于悲哀的自私的激情, 我们要避免的是: 因轻微的痛苦而去向别人请求同情. 因为<strong>人类存在一种恶念, 它不仅妨碍人们对轻微的不快表示同情, 而且在一定程度上拿它们消愁解闷.</strong> 一个人遇到程度较轻的悲痛, 如果他有较高的美德, 首先不会请求别人的同情, 甚至主动地把这种小事变成善意的嘲笑, 因为他知道同伴们会这样做.</p><h3 id="总结如何获得自尊的美德"><a href="#总结如何获得自尊的美德" class="headerlink" title="总结如何获得自尊的美德"></a>总结如何获得自尊的美德</h3><ul><li>忍住肉体产生的激情的表现程度(减少表达的夸张程度). 如饿, 男女, 疼等只有自己的身体才能体会的激情.</li><li>把一件事情以容易理解的方式叙述更容易获得别人的理解. (即使不是事实)</li><li>别人难以理解的激情(需要长时间锻炼或以某种习惯生活的激情), 就算是存在想象中的, 也不要分享.</li><li>与别人情绪对立的情绪不容易让旁观者同情.</li><li>愤怒不容易让人理解, 平静&#x2F;快乐容易让人理解. 在所有情况下适用, 因为人的情绪是直接的而不是间接的. (表面的)</li><li>在别人情绪对立的基础上, 表现出让人理解的情绪能让旁观者更同情自己, 表现出愤怒争吵能让旁观者更同情对方.</li><li>与别人达成一致的情绪容易被旁观者同情.</li><li>私人的快乐感情, 小的快乐要与别人分享, 大的快乐要忍住分享, 并做到比平时更谦虚.</li><li>私人的悲伤感情, 小的悲伤要转化为自嘲, 大的悲伤可以分享, 甚至请求帮助, 别人也是愿意帮忙的.</li></ul><p>总结来说, 就是<strong>在任何情况下都多站在其他人的角度思考, 去理解别人.</strong> 而人都是自我的, 所以美德是极难的. 这些总结的情形也要仔细理解并练习才能向美德靠近.</p><h2 id="社会地位与同情与美德"><a href="#社会地位与同情与美德" class="headerlink" title="社会地位与同情与美德"></a>社会地位与同情与美德</h2><h3 id="对快乐与悲伤同情的区别"><a href="#对快乐与悲伤同情的区别" class="headerlink" title="对快乐与悲伤同情的区别"></a>对快乐与悲伤同情的区别</h3><p>人感受痛苦比感受快乐的感受得多, 即使在我们不能体会悲伤(觉得对方软弱)的情况下, 我们还会认为悲伤是合理的并会安慰当事人, 而如果认为快乐是过分的, 我们就会对当事人表示轻视和不屑.</p><p>并且人会常常努力控制对别人悲伤的同情, 但又常常是不成功的, 这种屈从会使我们更注意别人的悲伤.</p><p>对于快乐, 人又有个本能是嫉妒, 但又会因为自己的嫉妒而羞愧, 这种羞愧使我们经常<strong>假装</strong>同情别人的快乐.(实际并不同情)</p><p>当我们不愿意对悲伤表示同情时, 我们会经常感到它; 而当我们乐于对快乐表示同情时, 我们却往往不能感到它. 因此, 按照我们的想法, 如下一点是理所当然的: <strong>对悲伤表示同情的倾向必定非常强烈, 对快乐表示同情的倾向必定极其微弱.</strong></p><p>另外有一点, 如果人类不存在嫉妒这种本能, 那么事情会是相反的: 人更倾向于同情别人的快乐. 因为人对快乐的同情程度天然地比悲伤高. (注意同情程度和同情倾向是2个维度).</p><p>为什么人对快乐的同情的程度会更与当事人一致呢? 这就要来分析什么是幸福与不幸.</p><p>人有个自然状态, 即什么都不做就可以获得的状态: <strong>身体健康, 没有债务, 问心无愧.</strong> 并且<strong>很多一部分人都处于这个状态.</strong> 而任何快乐, 都不会超过这个状态很多.</p><p>但是失去了自然状态的时候, 人就陷入了不幸, 任何不幸都离那个自然状态很远. 所以: <strong>自然状态和最大的幸福的举例是微不足道的, 但和最小的不幸的举例却大得惊人</strong>. 所以人的快乐其实不是很快乐, 而悲伤却是很悲伤.</p><p>由于人感受别人悲伤的程度会低很多, 就会导致一些同情时候的不同: 人在感受快乐的时候, 例如对朋友的祝贺, 婚礼的庆贺, 人们的快乐情绪是和当事人几乎一样的; 但对悲伤的同情就无法达到当事人的程度, 当当事人在倾诉的时候因自然发作的激情突然难受得说不出话, 倾听者此时内心滋长的倦怠情绪和当事人的悲伤是多么不协调.</p><h3 id="论野心的起源于社会阶层的区别"><a href="#论野心的起源于社会阶层的区别" class="headerlink" title="论野心的起源于社会阶层的区别"></a>论野心的起源于社会阶层的区别</h3><p>每个人的辛苦, 劳碌, 追求财富, 权力和地位的目的是什么? 是为了提供生活的必需品吗, 不是的, 因为不需要那么拼命的劳动就可以获得生活的必需品了.  <strong>我们日常行为的目的是追求虚荣, 而不是舒适或快乐.</strong> 有的追求财富, 有的追求地位; 有的通过劳动&#x2F;工作, 有的通过歪门邪道追求财富;</p><p>那追求虚荣的目的是什么, 因为大家都知道: **人都容易同情快乐, 又不容易同情悲伤. ** 所以我们都夸耀自己的财富而隐瞒自己的贫穷. </p><p>成为有钱有地位的人有什么好处? 有一句话: 没有人会怀疑成功者说的话. 成功者的任何行为都会引起其他人的共鸣, 其他人都会心甘情愿做舔狗, 因为成功者有光环, <strong>并且不想得到任何报答.</strong> 成功者的恩惠只能给予少数人, 但他们的幸运却吸引了几乎所有的人.</p><p>那我们会发现, 只要<strong>坐上了成功者的宝座, 只需要少量的美德就可以保持地位. 而没有成功的人拥有比成功者更多的美德也不会被其他人如此地同情</strong>. 所以成功者和正在努力向成功的人, 这两个社会阶级的立场是不同的. 总结为: 成功阶级的人要做的是不犯错, 希望局面平稳; 正在努力的人要做的是学习进步, 并希望局势混乱来得到发挥自己能力的机会. 这有点像大的成功团体和小的创业团体的特点.</p><p>最后, 作者提出了, 野心几乎不会被任何感情替代. 野心变大的人就很难回头, 并失去自由和快乐, 所以建议谨慎入坑, 调整好心态.</p><p>**人类的美德不会屈服于痛苦, 贫穷, 危险和死亡. 但会输给侮辱, 嘲笑和轻视. ** 似乎物质条件和精神条件总是此消彼长的, 也许平衡是最好的状态. (而现在的时代, 上海这个城市, 估计最低工资的物质条件也过于好了.)</p><h3 id="论由钦佩富人轻视穷人引起的道德情操的败坏"><a href="#论由钦佩富人轻视穷人引起的道德情操的败坏" class="headerlink" title="论由钦佩富人轻视穷人引起的道德情操的败坏"></a>论由钦佩富人轻视穷人引起的道德情操的败坏</h3><p>接上篇, 因为害怕被嘲笑和轻视, 我们都希望有美好的名声, 但是<strong>我们以来到这个世界, 就很快发现智慧和美德并不是唯一受到尊敬的对象, 罪恶与愚蠢也不是唯一受到轻视的对象</strong>. 拥有财富和地位的人, 可以天然地获得所有人的尊敬.</p><p>绝大部分人对成功者的傲慢和自负的钦佩甚于对穷人的真诚和可靠的钦佩, 虽然成功者败坏的道德会损坏他的地位, 但需要很大程度的败坏, 以及被暴露于公众. 相比之下, 穷人得到批评就容易得多, 小小的罪恶和愚蠢就可以.</p><p>所以: 我们可以通向得到美好名声的路就有了两条: 学习知识培养美德, 和, 取得财富和地位.</p><p>在中低层和高层, 情况还是不同的: 在中低层, 这两条路在大多数情况下是极其相近的; 而在高层, 这两条路往往截然相反.</p><p>中低层里, 人们基本都通过职业取得财富, 那么就需要知识和美德, 并且中低层的地位不会超越法律, 法律必然能吓住他们.</p><p>而在高层里, 成功不是依靠博学多才和见闻广博, 而是依靠阿谀奉承获得上级的重视. 并且, 上流社会的愚蠢浅薄的才能, 能比一个战士, 政治家, 哲学家真正的美德相比, 获得更多的赞扬.</p><p>于是我们钦佩大人物, 加以模仿, 他们的衣服成为了时髦的标志, 语言成了时髦的标志, 甚至罪恶和愚蠢也成了时髦的东西. 大部分人以 模仿这种品质和具有类似的品质为荣, 而正是这种品质玷污和贬低了他们自己.</p><p>除去模仿大人物的倾向外, 在高层中追求地位, 也会导致道德情操的败坏. 在高层里, 许多职位是凌驾于法律之上的, 于是为了获得这些地位, 就可以用卑鄙肮脏的手段, 只要成功获取了地位, 那么过程中的道德败坏, 也都会被合理化了.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 道德情操论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个例子让我们明白大脑的低级</title>
      <link href="/2020/02/15/behavioral-biases-we-are-experiencing/"/>
      <url>/2020/02/15/behavioral-biases-we-are-experiencing/</url>
      
        <content type="html"><![CDATA[<p>我了解了一些大脑的低级表现(也许是高级). 至少我们得去了解, 分析, 更深刻的认识一下自己.</p><span id="more"></span><p>这个post是打算总结一下看了&lt;行为金融学&gt;的前2章看到有意思的东西.</p><p>以及因为最近生活中一些细碎的痛苦后产生的一些感想.</p><p>所以由回忆这大半个月中生活中的痛苦开始本文.</p><h2 id="谦虚使人进步"><a href="#谦虚使人进步" class="headerlink" title="谦虚使人进步"></a>谦虚使人进步</h2><p>因为生病+春节+疫情, 所有人的生活模式都发生了一些改变, 所以平时能避免的问题也凸显出来.</p><p>对于我而言的话, 首先是与家人的矛盾, 其次是玩英雄联盟变多, 开始想赢游戏了, 于是也思考了如何能提高胜率.</p><ul><li><p>就人与人的矛盾来说, 我认为最大的问题在于, 几乎每个人都认为: “他如果xxx就好了, 他必须改正这个坏毛病.” 俺也一样. 我也认为”a的问题是这个, b的问题是那个, 我如何拯救你们”.</p><p>很明显各方都一直是这个心态, 所以下次还会爆发同样的矛盾. <strong>a行为导致了b结果, 还是坚持a行为, 那么b结果也会如期而至的.</strong></p></li><li><p>就游戏来说, 突然发现一个规律, 就是很多游戏刚脱离新手的时候游戏玩得状态最好. 而后水平慢慢变差.</p><p>原因也比较简单, 因为新手的时候有学习的心态, 思考害怕输更多, 而老手了思考怎么赢更多.</p></li></ul><p>以前曾听过最底层人的状态是”不知道自己不知道”, 因为对自己的问题认识比较少, 所以进步的机会也就比较少, 自然就落到了底层.</p><p>于是想到了谦虚使人进步, 原来我很小的时候就知道了能脱离底层的九阳神功秘籍却没有修炼. 下面我也想到了几个别的角度来思考这个观点.</p><h3 id="做个向内的人"><a href="#做个向内的人" class="headerlink" title="做个向内的人"></a>做个向内的人</h3><p>人的大脑有一个特点, 发生了事情一定要得到解释, 这就是所谓的归因.</p><p>而归因也有一个特点: 找到了一个原因后就停止.</p><p>举个例子就是生活中发生了纠葛, 每个人的大脑会去找原因, 当他发现对方身上的问题, 就把纠葛的原因归到对方. 这个就是归因到外部. 于是就不会归因到内部(自身问题).</p><p>很显然地, 我们都知道, 一个问题的发生只有单方有问题的可能性非常低, 几乎都是双方都有问题.</p><p>而一个人归因方式是有一个固定模式的, 如果一直是归因到外部的, 那么也就很难发现自己身上的问题了, 于是就成为了了”不知道自己不知道”的层次.</p><p>同样的也能推到游戏, 玩游戏输了经常怪别人的人, 自己水平也就无法进步.</p><p>所以: **人进步的瓶颈是自己的骄傲, 而骄傲(自满)正是对自己上一阶段努力成果的肯定. ** 骄傲是需要的, 因为我们努力的目标就是获得成就感. 而如何面对自己阶段性的成就感, 也就决定了他以多快速度进入下一个阶段的进步, 也决定了他能走多远.</p><h3 id="给自己一个提醒"><a href="#给自己一个提醒" class="headerlink" title="给自己一个提醒"></a>给自己一个提醒</h3><p>虽说每个人有固定的归因模式, 但就算一个偏向傲慢的人(傲慢与谦虚是线性的, 而不是端点)也会有学习的机会. 比如: 声望很高的人的教学, 被现实打脸而很难再找借口了.</p><p>所以人生还是会在谦虚和膨胀的周期里进行的, 只不过每个人的周期和阶段持续时间不同.</p><p>但在大多数情况下, 大家是不自知自己骄傲了的.</p><p>借鉴”盗梦空间”, 我想了几个trigger, 可以把这些行为和傲慢联系在一起, 而即时提醒自己, 可以进行一些心态的调整了.</p><ul><li><p>认为别人xxx做比较好&#x2F;教别人如何做比较好. 甚至因为别人”不要好”而生气.</p><p>清醒点吧, 人性决定没有人会真心为别人好. “人之患在好为人师”. 发现自己有此心态请回头是岸.</p></li><li><p>说话声音响, 特别想表达.</p></li><li><p>因为自己的”朋友”而骄傲, 并向别人表达.</p></li><li><p>看不起, 歧视.</p><p>地域歧视也好, 游戏歧视也好, 车子歧视也好, 行为歧视也好, ide歧视也好, 语言(各种意义上的)也好.</p></li></ul><h3 id="以人为镜"><a href="#以人为镜" class="headerlink" title="以人为镜"></a>以人为镜</h3><p>不得不提的是, 如果有了”xxx如果xxx做就好了”的感觉怎么办?</p><p>答案是: 不告诉他, 不建议他, 就算是很亲近的人(孩子). </p><p>原因有两个:</p><ul><li>给一个人提建议是非常难的, 提了可能造成纯不好的效果.</li><li>人性是接近的. 其实平时生活很难有人给自己提建议的. 那么就把别人的错误看自己有没有. 这是一个绝好的机会.</li></ul><p>把”我是对你好”的心态, 改成”我要看看自己有没有一样的问题”.</p><p>救世之前还是先救救自己吧, 大多数人都陷入在如此泥潭中不得脱身吧.</p><h2 id="认知偏差"><a href="#认知偏差" class="headerlink" title="认知偏差"></a>认知偏差</h2><p>关于自大, 傲慢, 其中一个我们都会经历的情况就是: <strong>高估自己</strong>. 也就是高估了自己的大脑. </p><p>比如打算做某些事情, 但最后没有做. 想好要对谁说什么话, 但是到时间就怂了. 所谓初生牛犊不怕虎, 是因为对世界没有正确的认识. 而高估自己的大脑, 是因为对自己的大脑没有足够的认识.</p><p>大脑非常高级与精密, 但有时候也会犯错, 比如:</p><ul><li>大脑认为下顿饭不一定有得吃, 所以这顿饭要多吃点, 于是肥胖成了很普遍的现象.</li><li>在要求估计工时的时候, 大脑评估了一下任务和自己对技能掌握程度估了个时间. 结果为了自己的承诺天天加班到深夜.</li></ul><p>这里就来讨论一下认知偏差.</p><h3 id="什么是认知"><a href="#什么是认知" class="headerlink" title="什么是认知"></a>什么是认知</h3><blockquote><p> 认知是指个体通过感觉, 知觉, 表象, 想象, 记忆, 思维等形式, 把握客观事物的性质和规律的认识活动.</p></blockquote><p>我的理解, 认知就是通过各种感官来获取信息, 并理解信息, 形成自己的世界观.</p><p>那每个人认知与世界观的不同是由什么造成的呢?</p><ul><li>认知风格. 是个体对信息加工的方式. 比如归因有外部和内部, 认识事物有从整体或细节, 有人善于倾听有人拒绝新信息.</li><li>认知策略. 因为信息数量远大于我们大脑可以处理的能力, 所以如何进行认知活动, 每个人也是不同的. “如何解决问题”, “如何保持注意力”, “如何记忆”都是认知策略.</li></ul><h3 id="认知过程的不完美之处"><a href="#认知过程的不完美之处" class="headerlink" title="认知过程的不完美之处"></a>认知过程的不完美之处</h3><p>因为信息的数量远大于我们大脑可以处理的能力, 并且信息有对有错, 有重要有不重要. 所以我们稀缺的是注意力, 并且选择吸收什么信息对我们来说也很重要.</p><p>认知偏差就是注意力有限造成的.</p><p>大脑会视图把复杂的问题简化, 通常会用一下一些方式:</p><ul><li>通过忽略一部分信息以减少认知负担.</li><li>过度使用某些信息以避免寻找更多的信息.</li><li>接受一个不尽完美的选择, 并认为这已经足够好了.</li></ul><p>这些方式本意是帮大脑减负, 当然在大多情况下是利大于弊的, 当然一个东西的好坏是对立的, 有时候会导致个体认识世界有偏差.</p><p>所以<strong>认知偏差是大脑处理信息的捷径的副作用.</strong> 这种大脑处理信息的快捷方式是牺牲了信息的深度而追求信息的广度.</p><p>本身这种策略一定是利大于弊的, 但这种认知偏差被商业的人研究并尝试利用的时候, 防备心差的人或许就会有些吃亏了.</p><p>后面的部分会先说一下认知偏差的类型, 再说一些认知偏差导致的普遍的投资者心理和实际场景.</p><h3 id="启发式思维"><a href="#启发式思维" class="headerlink" title="启发式思维"></a>启发式思维</h3><p>人做决定的思考过程分为2种: 计算与凭感觉.</p><p>计算是指把各个情况出现的概率和获利或损失的情况进行加权作出决定.</p><p>凭感觉就是我感觉这事划算就去做, 不划算就不做. 凭感觉就是启发式思维.</p><p>启发式思维的一些特点被商家利用得淋漓尽致, 很简单的表现就是: 我感觉我赚了, 冷静以后发现我亏了. 这就因为商家利用你启发式思维的特点, 营造了一些场景让你”凭感觉”踩坑.</p><p>启发性思维大致分2大类, 下面分别解释并分析在什么情况下会发生认知偏差.</p><h4 id="代表性启发"><a href="#代表性启发" class="headerlink" title="代表性启发"></a>代表性启发</h4><p>先看下面的题目:</p><blockquote><p>盒子里有70个白球, 30个红球. 随机取10个球.</p><p>取到7个白球, 3个红球的概率. 与取到3个白球, 7个红球的概率. 那个高?</p></blockquote><p>盒子里大部分是白球, 所以经过分析, 取到7个白球, 3个红球的概率比较高.</p><p>这个就是”代表性启发”的思维了. 代表性启发是指人们倾向于根据样本是否代表总体来判断其出现的概率, 即代表性越高, 人们判断其出现概率也越高.</p><p>很明显地, “取到7个白球, 3个红球概率更高”这个答案是正确的.</p><p>而如果通过”计算”的思维方式来替代”启发式”, 就要用到一些高中数学知识了, 排列组合算出每个情况出现的次数, 再用贝叶斯公司计算各自概率. 可能得花个15分钟来解决这道题目. 可见启发式思维是一种思维的捷径, 并且大多数情况是正确的.</p><p>那么下面来看看, 在什么情况下启发式思维会出现较大的偏差.</p><h5 id="忽视结果的先验概率"><a href="#忽视结果的先验概率" class="headerlink" title="忽视结果的先验概率"></a>忽视结果的先验概率</h5><p>先看一个实验</p><blockquote><p>约翰, 男, 45岁, 平时开着汽车上下班. 被试分为两组.</p><p>第一组被告知, 约翰来自于一个30%月薪1万以下, 70%月薪1万以上的公司.</p><p>第二组被告知, 约翰来自于一个70%月薪1万以下, 30%月薪1万以上的公司.</p><p>问被试约翰属于哪个收入范围的. 大多数被试都忽视了被告知的条件, 认为约翰是收入1万以上的范围.</p></blockquote><p>开汽车上班有一种代表性, 因为拥有汽车是富有的代表.</p><p>但实际上拥有汽车并不是收入的证明和根据. 而大多数被试根据代表性启发, 来判断了约翰属于高收入范围.</p><h5 id="对样本规模不敏感与对偶然性的误解"><a href="#对样本规模不敏感与对偶然性的误解" class="headerlink" title="对样本规模不敏感与对偶然性的误解"></a>对样本规模不敏感与对偶然性的误解</h5><p>这是代表性会导致的另一个偏差, 即忽略样本大小. </p><p>例如认为”扔10次硬币出现5次头像”与”扔1000次硬币出现500次头像”一样具有代表性.</p><p>如果扔10次硬币出现了1次头像, 那么就推断扔1000次硬币会出现100次头像.</p><h5 id="对均值回归的误解"><a href="#对均值回归的误解" class="headerlink" title="对均值回归的误解"></a>对均值回归的误解</h5><p>代表性启发式对事情的判断会是线性的. 比如股票短期上涨了, 代表性启发就会推断股票长期也是上涨的.</p><p>这样就忽略了均值回归的现象. 短期上涨可能使股价偏离实际值, 所以长期来看会因为均值回归而下跌到实际股价.</p><h5 id="有效性幻觉与关联效应"><a href="#有效性幻觉与关联效应" class="headerlink" title="有效性幻觉与关联效应"></a>有效性幻觉与关联效应</h5><p>人们会在多个输入信息有良好吻合的基础上产生毫无根据的自信, 被称为有效性幻觉.</p><p>举个书中在先验概率中的例子:</p><blockquote><p>琳达, 女, 31岁, 在学校期间关心歧视和社会公正问题, 参加过反核武器抗议示威活动.</p><p>试问下面描述哪个正确性更高?</p><ol><li>琳达是银行出纳员.</li><li>琳达是银行出纳员并热衷于女权运动.</li></ol></blockquote><p>实验中不同文化程度的人都认为描述2的可能性高于描述1.</p><p>就是因为: 有关联的, 良好吻合的输入信息, 使描述更具有代表性. 而使人产生代表性更强的启发思维, 从而更确信描述2是真实的可能性高.</p><p>但仔细思考就能知道. 描述2的概率是低于描述1的. 因为P(AB) &lt;&#x3D; P(A), P(AB) &lt;&#x3D; P(B).</p><h4 id="可得性启发"><a href="#可得性启发" class="headerlink" title="可得性启发"></a>可得性启发</h4><p>可得性启发是指人倾向于根据课题或时间在知觉或记忆中的可得性程度来评估其出现的相对概率, 容易被察觉到的或回想起的课题或事件被判定为更常出现. 简单地说就是<strong>人会高估容易想到的事情的概率, 而低估不容易想到的事情的概率, 所以思想就与真相产生了偏差.</strong></p><p>并且有几个类型的事情的”可得性”比较高: 时间的近, 时间的新异性, 表现的生动性, 情绪的一致性. 这些事情更容易进入我们的思维, 更容易在思考是获得更大的出现概率.</p><p>可得性启发主要体现为以下四种:</p><ul><li><p>事件的可获取性.</p><p>最经典的就是飞机比火车危险. 因为火车事故更常见, 常见的事情不容易被报道. 而我们获取飞机与火车的信息比较多的是通过报道, 所以会觉得飞机更危险.</p></li><li><p>搜索方式的有效性.</p><p>书里的例子是: 以r开头的单词与第三个字母是r的单词哪个多? 大多人会判断以r开头的多. 因为在脑子里好搜索, 而事实是与这个判断相反的.</p></li><li><p>思考的难易程度.</p><p>题目是: 从81人中选出2人, 和从81人中选出79人的方式各有几种? 大部分人估算选出2人的方式比选出79人的多很多.</p><p>因为选2人比较容易想象, 而选79人不那么容易想象. 其实这2个情况方式数量是一样的.</p></li><li><p>虚幻的相互作用.</p><p>人在日常判断中, 总是会运用于实践有联系的虚幻现象来对事件进行判断, 从而可能产生偏差.</p><p>有一个实验是一个人的照片给2组人看, 特征是”眼睛深凹, 下巴外翘”. 然后分别向2组人介绍, “此人是个罪犯”与”此人是位著名学者”, 然后两组人对照片的评价是: “眼睛深凹说明他凶狠狡猾, 下巴外翘反应顽固不化”, 另外一组是”眼睛深凹说明思想深邃, 下巴外翘反应他具有探索真理的精神”.</p></li></ul><h4 id="锚定效应与调整式启发"><a href="#锚定效应与调整式启发" class="headerlink" title="锚定效应与调整式启发"></a>锚定效应与调整式启发</h4><p>锚定效应的原理比较简单, 但是理解比较难. 原理就是思维如果被接受了一个锚定的起始点, 那么这个起始点的值会对之后的思维产生更强的影响.</p><p>说个最常见的例子就是餐厅菜单的最贵的菜和星巴克20块的依云水. 是用来提高对餐厅价格的定价起始点, 然后就会认为”其他菜这么便宜”.</p><p><strong>锚定效应引起的偏差都是因为调整不足引起的.</strong> 因为起始点的权重在思维中占了过大的比例, 所以调整到接近真实的数据就会引起偏差. 关于价格的锚定效应还是比较明显的, 下面说两个需要仔细理解的锚定效应.</p><ul><li><p>货币幻觉. </p><p>货币幻觉指: 人对货币的数量在意程度超过了其真实购买力. 给你2个选择: 所有物品半价, 你的工资翻倍. 大多数人会选择: 工资翻倍.</p><p>或者有另外2个情况: 物价减半&amp;工资减半. 或者物价翻倍&amp;工资翻倍. 在大家都减半的情况下, 人会偏向于难过, 而都翻倍的情况下, 人会偏向于开心.</p><p>其原理就是: 初始的工资数量是一个锚定初始点, 真正的购买力的变化在人的感觉上会调整不足, 也就是会有错误的对价格判断.</p></li><li><p>对联合事件和分离事件的认知偏差.</p><p>说3个事件:</p><p>简单事件p1: 从一个装有50%红球和50%白球的箱抽到一个红球.</p><p>联合事件p2: 从一个装有90%红球和10%白球的箱中连续7次抽到红球.</p><p>分离事件p3: 从一个由10%红球和90%白球的箱中连续7次抽球且至少有一次抽到红球.</p><p>判断这3个事件的概率高低, 尽量认真思考&amp;不让自己受标题影响.</p><p>大多人判断是: p2&gt;p1&gt;p3. 实际是: p3&gt;p1&gt;p2.</p><p>总结是: <strong>人们会高估联合事件, 并且低估分离事件.</strong> 例子举2个: 工作中即使每个单独事件的成功概率都很高, 但是事情多了以后我们会高估总体成功概率. 上海汽车牌照中标率7.5%左右, 但连续拍一年失败概率只有30%不到. 人的感觉上低估了总体成功率, 所以产生了汽车代拍牌照的业务.</p><p>分析下原因: 锚定初始值为90%. 而我们对”分离”和”联合”事件的感觉不同, 导致不同的调整不足(和调整过剩).</p></li></ul><h4 id="情感式启发"><a href="#情感式启发" class="headerlink" title="情感式启发"></a>情感式启发</h4><p>情感是最容易理解的, 就是: “我希望事情是如何进行的, 我就判断这个可能性比较大.”的自我安慰型的启发式思维.</p><h3 id="框定依赖偏差"><a href="#框定依赖偏差" class="headerlink" title="框定依赖偏差"></a>框定依赖偏差</h3><p>框定依赖是人们解释外在客观世界的心理模式. 具体就是: 人认识一件事情的第一步, 是先把时间放进一个框架内, 再进行思考. 我举一个书里的例子一个自己想的例子.</p><p>假设有一种流行疾病侵袭, 将有600人死亡, 试在一下两种方案中作出选择:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 将有200人获救.</span><br><span class="line">B: 600人全部获救的可能性为1/3, 而全部死亡的可能为2/3.</span><br></pre></td></tr></table></figure><p>在这个情况下, 72%的人选择了A.</p><p>而再给出两个方案, 试作出选择:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C: 将会有400人死亡.</span><br><span class="line">D: 无人死亡的概率为1/3, 全部死亡的概率为2/3.</span><br></pre></td></tr></table></figure><p>这个方案, 78%的人选择了D.</p><p>其实是一样的选项, 而测试者用语言给了被试”生存框架”与”死亡框架”. 因为人对生存和死亡存有的不同态度, 而选择有了很大的变化.</p><p>另外一个例子: </p><p>买2斤青菜, 情况1: 称了2斤不到一点, 取下称加一点菜. 情况2: 称了2斤多一点, 取下称拿走一颗菜.</p><p>这样让买菜者进入了不同的框架, 一个是”赚这点能不能接受” 另一个是”亏这点能不能接受”.</p><p>面馆把”面很多, 客人都吃不掉”, 改革为: “面少, 但是可以免费续面”, 也是利用了这个技巧.</p><p>所以框定依赖偏差的特点是: <strong>人会根据描述不同, 而进入不同的框架, 并作出不一样的行为.</strong> 那一样的情况, 不同的行为, 假设有一个正确的决定, 那就一定有一方或双方都存在偏差了. 所以框定依赖会产生认知偏差.</p><p>下面说一下框定依赖会产生的主要偏差类型:</p><h4 id="对比效应"><a href="#对比效应" class="headerlink" title="对比效应"></a>对比效应</h4><p>两个碗, 一个热水一个冰水, 分别把手放入.</p><p>再拿出, 一起放到温水中.</p><p>于是一个手感受这盆温水是热水, 而另一个手感受是冷水.</p><h4 id="首因效应与近因效应"><a href="#首因效应与近因效应" class="headerlink" title="首因效应与近因效应"></a>首因效应与近因效应</h4><p>首因和近因分别是指, 第一次听到的消息, 或者有时候是更近听到的消息, 会在思考中有更重的权.</p><p>那么问题是什么情况会触发第一印象重要, 什么情况会触发最近听到消息重要呢.</p><p>总结来说: </p><p><strong>若信息是连续呈现出来的, 但判断是在一段时间后作出, 首因效应是主要的.</strong> 也就是第一印象对长期来说是重要的.</p><p><strong>若信息的呈现之间有时间间隔, 但判断是紧接着作出的, 近因效应是主要的.</strong> 如果要紧急的作出判断, 那么人更容易想起靠近的信息, 这个原理可能是”可得性启发式”.</p><h4 id="晕轮效应"><a href="#晕轮效应" class="headerlink" title="晕轮效应"></a>晕轮效应</h4><p>也叫做光环效应. 即: 一个人某方面是优秀的, 就容易认为他其他方面的对或错都是他优秀的表现.</p><h4 id="稀释效应"><a href="#稀释效应" class="headerlink" title="稀释效应"></a>稀释效应</h4><p>有两个描述:</p><p>A: 提姆平均每个星期要花31小时的课外时间学习.</p><p>B: 汤姆有个调皮可爱的弟弟和两个妹妹, 他们相处融洽, 他每隔一周去看望一次爷爷奶奶, 每隔两个月打一次台球, 他花在课外学习的时间是31小时.</p><p>看了描述, 大多人会认为: A中的提姆学习更认真.</p><p>但其实A和B的时间都是31小时, 因为额外的信息, 稀释了重要信息的判断有效性.</p><p>这里有个延伸的技巧, 关于”如何公布好消息和坏消息”的结论, 是我们可以学习的:</p><ol><li>如果有几个好消息, 要分开发布. (增加快乐次数)</li><li>如果有几个坏消息, 要一起发布. (减少难过次数)</li><li>如果有大好消息和小坏消息, 要一起发布. (稀释坏消息)</li><li>如果有大坏消息和小好消息, 要分开发布. (不让坏消息稀释好消息)</li></ol><p>这几个技巧是让受众对消息更满意的技巧.</p><h2 id="投资者心理与行为偏差"><a href="#投资者心理与行为偏差" class="headerlink" title="投资者心理与行为偏差"></a>投资者心理与行为偏差</h2><p>这个章节介绍几个行为偏差的形式, 以<strong>在自己发现自己产生了某种偏差的时候, 警示自己, 并提醒自己最好使用一下”计算”的方式来进行思考判断.</strong></p><h3 id="心理账户"><a href="#心理账户" class="headerlink" title="心理账户"></a>心理账户</h3><p>有两个例子:</p><p>打算去剧院去看演出, 票价是10美元.</p><p>第一种情况: 你没买票, 到剧院门口发现丢了10美元. 你还会买票看演出吗? (88%的人选择了会)</p><p>第二种情况: 买好票了, 到剧院门口发现票子丢了, 你还会买票看演出吗? (46%的人选择了会)</p><p>其实是一样的情况, 为什么选择相差了百分之40.</p><p>第二个例子:</p><p>第一种情况: 商场里夹克15美元, 在2公里外的另一个商场10美元. 68%的人选择了买便宜的.</p><p>第二种情况: 商场里计算机是125美元, 在2公里外的另一个商场这个计算机120美元, 29%的人选择了买便宜的.</p><p>一样是2公里, 一样是5美元差价. 为什么选择情况相差了百分之40.</p><p>心理账户是某些决策偏差的汇总, 而并不是出于同一个心理因素. 总结来说, 人们会把”不同来源” 或者”不同使用目的” 或者 “参与不同的比较”的钱, 放到不同的”心理账户”中, 比如辛苦工作的钱不太愿意用, 而向别人伸手讨来的钱就会乱用.</p><p>在关于价格还有一个总结是: 对于低价物品, 百分比打折更吸引人. 对于高价物品, 数值打折更吸引人. 例子自己去想, 很容易体会.</p><p>另外, 有一个应用<strong>支付分离.</strong> 即电话费的包月, 健身房的包月, 美容美发店的充卡, 饭店的充卡. 把每次打电话的开销, 每次健身的消费等带来的痛苦, 和消费本身分开. 把痛苦一次性付清. 这已经是一个普遍使用的商业技巧了. 扪心问问自己, 是不是充在卡里的钱特别容易用掉. 因为不心疼了, 他已经被划到另一个心理账户去了.</p><h3 id="损失厌恶"><a href="#损失厌恶" class="headerlink" title="损失厌恶"></a>损失厌恶</h3><p>也说说2个例子, 第一个经典的:</p><p>问题1: 从两个情况作出选择</p><p>A: 100%获得100美元. B: 50%获得200美元, 50%获得0.</p><p>问题2: 从两个情况作出选择</p><p>A: 100%损失100美元. B: 50%损失200美元, 50%损失0.</p><p>在问题1的盈利情况下, 人们会风险厌恶.</p><p>在问题2的损失情况下, 人们会风险偏好, 因为人是损失厌恶的.</p><p><strong>实验发现, 损失给人带来的负效用是同量正效用的2.5倍.</strong> 也就是: 你掉了100块钱, 要捡到250块钱才能平复心情. 掉了100块, 捡到200块, 心里都是难过的.</p><p>第二个例子:</p><p>出租车司机需要交一个固定的费用才能获得12小时营运权. 所以司机会设定一个预期值来作为当天收入目标.</p><p>而不同的天气, 每小时的收入是有波动的.</p><p>在生意差的情况下, 司机为达到预期, <strong>避免损失</strong>, 就会工作更长的时间, 而在生意比较好的情况下早点下班.</p><p>这个行为与理性策略恰恰是相反的. 在生意好的情况下多工作, 生意不好早点休息, 才是性价比最高的方法.</p><p>从损失厌恶效应看, 我们明白了<strong>必须学会克服损失厌恶, 不是花更多精力去避免损失, 而是花更多精力去追求利润.</strong> 方法是: 停下来仔细分析一下, 思考一下, 不要光凭感觉做事, 就行了.</p><p>(当然在公司管理中, 负向激励来让员工避免损失而更努力工作或者不迟到, 但好坏还需多仔细思考)</p><h3 id="禀赋效应"><a href="#禀赋效应" class="headerlink" title="禀赋效应"></a>禀赋效应</h3><p>愿意接受的价格(willingness to accept, WTA), 与愿意支付的价格(willingness to pay, WTP)之间存在巨大的差异. 简单的说就是<strong>个体得到某物愿意支付的金额相比, 个体出让该物品所要求的得到的金额通常更高.</strong> 研究者做了实验, 得到的平均值是247美元和1044美元.</p><p>源头在于, 人对自己拥有的东西会比较高的估计价值.</p><p>这个本性导致了市场效率降低, 出现交易惰性(不愿交换, 不愿改变生活环境, 不愿跳槽).</p><p>而对于禀赋效应这个让商家销货难度提高的问题, 商业当然也有了解决方案:</p><ol><li>免费试用, 已经在用的产品就会觉得是自己的, 会提高对商品的估价.</li><li>设置”购物车”, 让消费者产生已经”拥有”商品的感觉.</li><li>打折的商品退货率低, 因为退了感觉亏了.</li></ol><h3 id="短视损失厌恶"><a href="#短视损失厌恶" class="headerlink" title="短视损失厌恶"></a>短视损失厌恶</h3><p>一个明知是好的股票, 有人会因为短期的下跌而抛出. 其源头还是因为人的损失厌恶.</p><h3 id="后悔厌恶与处置效应"><a href="#后悔厌恶与处置效应" class="headerlink" title="后悔厌恶与处置效应"></a>后悔厌恶与处置效应</h3><p>后悔是一种消极情绪, 并且: <strong>后悔比损失更让人痛苦, 因此人们会激励避免出现后悔的感觉, 甚至以损失为代价.</strong> 那在什么情况下, 人会用损失来弥补后悔呢.</p><p>以下是三个后悔厌恶的核心定理:</p><ol><li>胁迫情况下采取行动引起的后悔比非胁迫情况下引起的后悔要轻微.</li><li>没有做错的行为引起的后悔比做了错误的行为引起的后悔要轻微.</li><li>个体需要对行动的最终结果承担责任情形下引起的后悔比无须承担责任情形下的后悔要强烈. 有利的结果会使责任者感到自豪, 不利的结果会使责任者感到后悔.</li></ol><p><strong>因为后悔厌恶, 而以损失为代价的行为, 就是处置效应.</strong> 最最常见的就是”出赢保亏”. 投资人在处置股票时, 倾向于卖出赚钱的股票, 继续持有赔钱的股票. 就因为害怕赢的股票跌了后悔. 以及亏的股票立即抛出获得的立即后悔的感觉.</p><h3 id="模糊厌恶与本土偏差"><a href="#模糊厌恶与本土偏差" class="headerlink" title="模糊厌恶与本土偏差"></a>模糊厌恶与本土偏差</h3><p>模糊厌恶有个经典实验:</p><p>2个瓶子. 第一个瓶子红球蓝球各50个. 第二个瓶子不知道.</p><p>抽到红球得100美元, 蓝球不得.</p><p>于是人们普遍比较偏爱第一个瓶子, 而对不知道概率的瓶子兴趣较低.</p><p>模糊厌恶会导致人们比较喜欢投资认识多的东西, 于是偏向于投资本土企业, 国产企业, 这就是本土偏差.</p><p>记得之前也听过一位老板分析经验, 说要抛去故乡心态, 什么事情投资&#x2F;买房先往老家看. 然后会产生正反馈, 视野无法变大.</p><h3 id="跨期选择与实践折扣"><a href="#跨期选择与实践折扣" class="headerlink" title="跨期选择与实践折扣"></a>跨期选择与实践折扣</h3><p>这个效应在前阵刚看的<a href="/2019/10/12/how-to-control-yourself/#%E8%AF%B1%E6%83%91%E8%B6%8A%E8%BF%91%E8%B6%8A%E5%A4%A7">意志力</a>里称作双曲贴现. 指在跨期选择领域中, 与当前的奖赏或损失相比, 人们常常低估未来奖赏或损失. 并且研究者测量了一个人们意愿的贴现率, 是个类似双曲线.</p><p>简单来说, 就是人是短视的, 越近越短. 而每个人的”贴现率”是不同的, 越短视的人一般精神疾病越严重.</p><p>最后有个小故事:</p><p>美国政府给退伍军队补偿, 给军人选择: 立即得到2万美元, 或者在今后每年获得一定的补偿金(这些补偿金的贴现值大约是4万美元). 超过90%的士兵选择了一次性2万美元. 为美国政府节约了17亿美元.</p><p>事实上, 如果士兵的确现在就需要钱, 可以向银行贷款2.5万美元, 而且可以用每年获得的补偿金来偿还债务.(滑稽)</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年度忏悔</title>
      <link href="/2020/01/25/2019summary/"/>
      <url>/2020/01/25/2019summary/</url>
      
        <content type="html"><![CDATA[<p>2019是我浪费了的一年, 状态不好就要暂停和总结, 这个寒假是个很好的调整机会, 让自己歇一歇, 想一想.</p><span id="more"></span><p>然后发现了一篇<a href="/2018/07/24/how-to-face-work-related-anxiety">一年半前总结对生活的认识</a>, 觉得非常有道理, 那很明显地可以发现<strong>我已经至少一年半停滞不前了</strong>.</p><p>那么, 今年的忏悔从重温一年半前的总结开始.</p><h2 id="过去一年半的复盘"><a href="#过去一年半的复盘" class="headerlink" title="过去一年半的复盘"></a>过去一年半的复盘</h2><p>18年7月写完总结, 我进入了另一家公司工作了8个月. 然后又到现在的公司工作了半年多. 在这两家公司几乎浪费了所有时间. 有一部分原因是因为兴趣看了一些物理和经济的知识, 但大多数是因为心态的变化.</p><p>我总结了一下, 导致心态变化的原因有:</p><ul><li>工作强度变高, 自己的时间变少. 导致了思考时间变少, 学习时间变少, 情绪变差.</li><li>公司的kpi文化影响到了自己, 这是我第一家上班打卡的公司, 以及年末感受到强烈的kpi文化. 之前没有经过这种”外部”考验, 所以被带偏了.</li><li>对基础工作的懈怠和轻视. 这是我回顾前几年工作以后找到的自己的阶段性问题, 每个人每个阶段都有他的难处吧.</li></ul><p>所以打算总结自己的错误, 做一些回顾与展望.</p><h2 id="做好基础保持拓展"><a href="#做好基础保持拓展" class="headerlink" title="做好基础保持拓展"></a>做好基础保持拓展</h2><p>这是一个非常简单的道理, 但深入理解也花了不少痛苦.</p><p>回想14年到18年, 自己状态好的原因有2个.</p><ul><li>初学者心态, 再简单的东西也是不会的, 觉得自己不行, 一定要尽力完成任务.</li><li>公司有业务空闲期. 虽然自己比较懒, 但在空闲期还是拓展和深入了不少知识.</li></ul><p>而为什么最近一年半完全退步的原因上一节也分析了, 这是一个对人的阶段性的考验, 挑战变为了:</p><ul><li>持续归零, 保持对基础业务的热情&#x2F;好奇心&#x2F;敬畏心. 保持初学者心态是乔布斯走掉的时候听到的, 现在才知道多重要.</li><li>刻意拓展. 之前都是无聊空闲的时候拓展, 现在空闲的时间少了, 不能忘记拓展的必须性.</li></ul><p>那么在业务繁忙度不变的情况下, 要用原先在做什么事情的时间来拓展业务和思考人生呢, 就是要解决的下个问题.</p><h2 id="保持为自己的行动"><a href="#保持为自己的行动" class="headerlink" title="保持为自己的行动"></a>保持为自己的行动</h2><p>之前提到的心态不对, 那心态不对的后果是什么, 就是浪费时间. 比如:</p><ul><li>认为基础的东西对自己无益, 不愿意做, 又必须做, 时间在犹豫中度过.</li><li>因为公司方向的kpi, 考勤时间, 认为时间是公司的, 产生了磨洋工的想法, 降低自己的效率.</li><li>磨洋工也是消耗精力的, 所以回家要休息, 就在轻娱乐上浪费了时间.</li></ul><p>首先说一下公司kpi对个人的影响. 首先kpi是好的, 但要被正确引导.</p><blockquote><p> <strong>想要计分板上的数字提高, 就不能把注意力集中在计分板, 而是球场.</strong></p></blockquote><p>可以把kpi理解为相对短期的目标, 但自己个人应该注重更长期的目标. 然后根据实际情况去选择性的实施行为. 并且短期目标和长期目标并不是冲突的, 而是有交集的.</p><p>在公司的引导上我犯的另外一个错误就是, 没有充分意识到时间是自己的, 因为感受到对加班的不满, 会懈怠一部分时间, 这个也是短视的结果.</p><p>最后一个问题: 生活和减肥一样, 出问题的地方都在”忘记时间”, 与”关闭标尺”的时候. 每天打算吃2斤食物. 就算超过了, 吃了3斤, 其实也不是导致肥胖的原因. 导致肥胖的原因是: 吃了2.2斤而放弃计划, 放弃以后无节制忘记计量得吃, 吃了10斤以后自己的感觉还是”超过了一点”.</p><p>娱乐也是如此. 打开电脑玩游戏, 玩了2个小时也好, 4个小时也好. 自己还有罪恶感. 而躺着”准备”睡觉, 手机一看就是2小时, 3小时. 时间的流逝的无感造成了大量流失.</p><p>总结一下这章的观点, 有两个重点.</p><p>首先, <strong>明确自己要做什么, 明确什么行为是对自己长期有益的, 并尽量不受短期诱惑的影响.</strong> 不受诱惑这点很难, 因为诱惑之所以叫诱惑, 就是因为对当前状态的你是有足够大吸引力的, 比如领导的表扬, 比如同事的认可, 比如4个月年终奖.</p><p>在实施细节上要注意的是: <strong>不要扩大边缘时间.</strong> 记得我高中英语老师说过, 你们放学等人一起走是最浪费时间的. 想不到十多年后看来竟然那么有道理. 原理就是上面说的那么简单: 我以为是10分钟的时间, 但其实花了2小时, 在意识上放过的东西会巨大化. 进一步总结就是: <strong>非常想做的事情才去做, 不要为了无聊做一件事.</strong> 又和减肥是一个道理: 非常想吃才去吃, 不要为了好吃而吃. 也和买东西是一个道理: 非常需要才去买, 不要为了便宜而买. 看来世上的道理都是通用的.</p><p>这里就强烈推荐screen time. 哪些app花去了你大量时间, 而你不自知, 现在可以到手机的screen time上去看一下了. screen time使边缘时间定量方便了很多. 我的下部目标就是减少screen time.</p><h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>经历了一次比较痛苦的病, 前几小时活蹦乱跳的人, 可能现在就奄奄一息了. 被亲人通宵照顾了30多小时和之后的7天. 对生命有了更深的尊重, 每个人的生命都是有限的, 每个人都很难的. 希望以后我可以不忘痛苦, 尊重自己的身体, 尊重所有其他的人.</p><h2 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h2><p>这是今年新体会到一些的词语. 外交部的话就是”历史洪流”.</p><p>我爸爸在播放学习强国的东西, 偶然听到一耳马克思思想. 再想到之前资本论学到的概念: 商品交换发展到一定程度才会出现货币, 货币流通发展到一定程度才会出现资本.</p><p>再联系最近的身体突发情况与环境突发新冠状病毒, 确实同意历史洪流的说法. 一切东西的发展规律都是必然的, 切不可阻挡的. 一些情况的发生和某种形式的出现<strong>都不是选择, 而是只能这样</strong>. 包括经济的猛增&#x2F;泡沫&#x2F;衰退, 包括政党的建立&#x2F;腐败&#x2F;衰亡, 包括经济形式的产生&#x2F;金融结构变化, 包括城市发展&#x2F;自然发展. 都是宏观必然出现的.</p><p>在此, 我也找到了学习的目的, 所谓学习就是通过思考来更深刻的理解世界. 对世界的理解越深刻, 越接近正确, 就越能了解趋势, 也就更能为未来会出现的困境做一些准备. 我认为现在大多数人正在做的事, 或者说是<strong>人活着的意义, 就是为未来做准备.</strong> 比如存钱, 积累财富, 买房, 健身, 学习, (甚至)吃饱了还要吃, 囤货这些行为的本质都是为长期做准备. 正是因为为未来做了准备, 当前的我们才能不那么狼狈地面对这些突发的困难.</p><h2 id="2020目标"><a href="#2020目标" class="headerlink" title="2020目标"></a>2020目标</h2><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>一年半前对努力方向的总结已经非常正确了, 总结中也提到, 大脑比自己以为的更没用, 我们要在清醒的时候控制那个大脑边缘系统.</p><p>刚巧2019年看了本书叫意志力, 专注如何把思想付诸实践. 而”练习”书上&#x2F;脑子里的知识, 应该会成为我们以后要持续去做的事情. 改变自己的习惯. 比如听到不同的声音不立即反驳, 思考是否正确, 学会认错; 比如学会延后享乐, 并尝试在享乐前添加目标和条件.</p><p>要利用一些技巧比如”实施意向”来面对情绪温差, 所以2020的关键词必须是<strong>行动</strong>.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>尊重任何简单的工作, 持续归零, 保持良好的态度.</li><li>经常提醒自己: 时间很紧迫以及时间是自己的.</li><li>实施意向: 拒绝轻娱乐, 不发呆. 累就睡觉, 无聊就学习, 想玩游戏就玩游戏.</li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>提高工作时间的效率</li><li>保持每天工作外的学习</li><li>达成screen time一小时内</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资本论第四章 货币转化为资本</title>
      <link href="/2019/12/08/das-capital-4/"/>
      <url>/2019/12/08/das-capital-4/</url>
      
        <content type="html"><![CDATA[<p>在了解了商品, 货币, 流通等基本概念与特点后, 终于进入正题: 资本. </p><span id="more"></span><p>要讨论资本, 当然要先知道资本的概念, 什么是资本.</p><h2 id="资本的总公式"><a href="#资本的总公式" class="headerlink" title="资本的总公式"></a>资本的总公式</h2><p>商品流通是资本的起点, 并且商品流通的产物货币是资本的最初形式.</p><p>那么货币是如何变成资本的, 是因为资本开始有着不同于货币的流通形式.</p><h3 id="流通形式"><a href="#流通形式" class="headerlink" title="流通形式"></a>流通形式</h3><p>商品流通的直接形式是w - g - w(商品-货币-商品), 即”为买而卖”.</p><p>而有时候出现了另外一个形式: g - w - g, 即”为卖而卖”, 在这个形式里的货币, 此时已经是资本了.</p><p>举两个简单的例子: </p><p>w - g - w, 为买而卖: 我有一头羊, 需要一头牛(需要买牛), 所以卖了羊, 获得货币, 去买牛.</p><p>g - w - g, 为卖而买: 我有100元, 我为了获得110元(需要卖出商品获得货币), 所以卖了皮革, 然后卖出, 获得了110元.</p><p>这两个情况有很多区别: </p><p>首先流通的目的不同: w - g - w的目的是商品(w), 而获得商品是为了使用商品, 商品会进入消费领域而结束一个流通循环. g - w - g的目的是货币(w), 这种循环的承担者不需要使用商品, 是纯粹的为了获取价值. 并且这个循环的产物货币(g), 可以作为下个循环的开端.</p><p>还有一个明显的区别, w - g - w中有2个不同的商品(w), 在例子中就是羊和牛, 使用的是同一份货币(g), 货币是作为转瞬即逝的流通手段. 而g - w - g中, 商品(w)只有一份, 同样的商品, 买进再卖出, 而使货币(g)的数量发生了变化.</p><blockquote><p>这里要注意, 在w - g - w中, 两端w的价值也可能是不同的, 但这是偶然的, 因为目的是使用商品.</p><p>对应地, 在g - w - g中, 两端货币量也可能是相同的(100元买进, 只卖出了100元), 甚至萎缩了(卖出少于100元, 亏了).</p><p>这些偶然(g - w - g的两端价值不同, 和g - w - g的两端价值相同)并不能影响这两个流通形式的本质区别, 因为他们的根本目的是完全不同的.</p></blockquote><p>g - w - g这种流通形式的承担者的目的是获得价值, 而不是使用价值(w - g - w流通的目的是使用价值).</p><h3 id="剩余价值"><a href="#剩余价值" class="headerlink" title="剩余价值"></a>剩余价值</h3><p>既然g - w - g的两端货币(g)的价值是不同的, 所以其实是: g - w - g’. 流通的终端的价值与始端是不同的, 也就是: g’ &#x3D; g + δg. 这里的δg, 在上面的例子中, 买入100元皮革, 卖出了110元, 就是10元这个部分, 就称作剩余价值(surplus value).</p><h3 id="资本的特点"><a href="#资本的特点" class="headerlink" title="资本的特点"></a>资本的特点</h3><p>因为g - w - g的终点货币又可以作为下一个资本流通的起点, 所以<strong>资本的运动是没有限制的</strong>, 并且下次起点比这次的起点价值更大. 作为这个运动的有意识的承担者, 货币占有者变成了资本家.</p><p>资本家这种绝对的致富欲, 是货币贮藏者也拥有的, 只不过货币贮藏者比较笨, 而资本家比较理智. 货币贮藏者竭力把货币从流通中拯救出来, 而更为精明的资本家通过把货币重新投入流通实现了致富欲.</p><p>资本一定要通过变形为商品, 才能实现升值, 而不像货币贮藏者那样与商品势不两立. 商品成为了货币升值的奇妙手段.</p><p>通过商品, 使货币生出更多货币, 也就是g - w - g + δg. 既是资本的总公式.</p><h2 id="总公式的矛盾"><a href="#总公式的矛盾" class="headerlink" title="总公式的矛盾"></a>总公式的矛盾</h2><h3 id="与基本规律的矛盾"><a href="#与基本规律的矛盾" class="headerlink" title="与基本规律的矛盾"></a>与基本规律的矛盾</h3><p>按照之前关于商品, 价值, 货币, 和流通的规律, 商品之间都是等价交换的. 剩余价值是不会产生的, 所以新的问题是: 剩余价值是如何产生, 从而出现资本的.</p><p>假设资本家用100元从a买入商品, 又把商品以110元卖给b. 为什么a不能直接把商品卖给b, 这样b可以用同样的货币买到更多商品. 问题就变成了, 某个领域是否允许价值发生增值, 并产生剩余价值.</p><h3 id="矛盾原因的猜想"><a href="#矛盾原因的猜想" class="headerlink" title="矛盾原因的猜想"></a>矛盾原因的猜想</h3><p>有一种思路是: 商品的价值在于供需关系. 某个商品多一个人来说是多了, 对另一个人来说则是少了, 价格是根据需求的强烈程度决定的. 因此, 商品交换过程几乎不会按照等量价值来交换. 所以, 商品流通能使商品产生更大价值, 贸易应看做是一种生产活动.</p><p>这种理论的本质是: 交换商品的双方不是等价的. 那顺着这个思路做个假设, 假设卖者享有一种特权, 特权是把自己的商品提高10%的价格出售. 这样, 买入100元的东西就可以以110元卖出, 产生10元的剩余价值.</p><p>但卖者在卖出商品以后, 需要重新作为买者买入商品才能继续资本活动. 此时他的卖方也享有这种特权, 那么买入商品的时候就亏了10%. 如此循环, 结果是商品的价格上升, 大家的购买力没有发生变化.</p><p>另外一种观点: 有效需求在于: 消费者愿意通过付出更多的货币来交换商品.</p><p>这种观点, 或者类似的观点, 都只是给”特权”加以伪装罢了. 可以思考这样一个场景: 我通过”特权”, 以110元出售了价值100元的商品. 交换以后, 我持有110元货币, 对方持有100元商品, 总价还是210元, 只不过我把10元价值转移到了我身上, 社会总体财富并没有增加.</p><p>所以, <strong>无论是否等价交换, 流通或商品交换不创造价值</strong>.</p><h3 id="非基本形式的资本"><a href="#非基本形式的资本" class="headerlink" title="非基本形式的资本"></a>非基本形式的资本</h3><p>商业资本和高利贷资本不是我们讨论的基本形式的资本, 所以在我们讨论范围之外, 这些资本是以违反自然的形式获得利润的.</p><p>商业资本是拒绝等价物交换, “战争是掠夺, 商业是欺骗”, 商业资本用对生产者的欺骗来增值.</p><p>高利贷资本更甚, 他去除了g - w - g的中间环节, 直接g - g’. 直接把货币换成了更多的货币, 这从商品交换的角度是无法解释的. 这些资本的形式需要之后再深入.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在流通里不会产生剩余价值, 而在流通外, 商品只与商品占有者发生关系, 如果商品占有者倾注劳动在商品上, 例如把皮革做成衣服使商品增值, 但并没有添加剩余价值, 添加的只是更多的劳动价值.</p><p>因此, 资本不能从流通中产生, 又不能不从流通中产生. 所以他必须既在流通中又不在流通中产生. </p><p>那么商品价值的变化只能从这种商品的使用价值本身, 即从这种商品的消费中产生.</p><h2 id="劳动力"><a href="#劳动力" class="headerlink" title="劳动力"></a>劳动力</h2><p><strong>有一种商品, 他的使用价值本身具有成为价值源泉的独特属性, 因此, 他的实际消费本身就是劳动的对象化, 从而是价值的创造. 这个商品就是劳动力.</strong></p><p>货币占有者如果可以购买到这种商品(劳动力), 就有机会产生剩余价值, 从而成为资本家了. 但劳动力成为商品是有一定条件的.</p><h3 id="劳动力作为商品的条件"><a href="#劳动力作为商品的条件" class="headerlink" title="劳动力作为商品的条件"></a>劳动力作为商品的条件</h3><p>劳动力是一个人劳动的能力, 包含了体力, 智力, 精力, 时间等. 显而易见的是, 如果一个人把劳动力完全卖给了货币持有者, 那他便成了奴隶. 所以第一个条件, 劳动者只出卖自己在一定期限内的劳动力.</p><p>第二个条件也很容易得出, 劳动力占有者没有可能出卖自己的劳动对象化在其中的商品. 如果劳动力占有者可以直接出卖倾注自己劳动力的商品, 就不必出卖自己干活的身体了. 就像我接电话能赚钱就不会去当客服了. 一般原因就是劳动者没有占有劳动的生产资料, 比如劳动者没有皮革, 而资本家有.</p><p>劳动力作为产品出现的条件总结为: <strong>劳动力占有者是自由工人, 并且他没有别的商品可以卖, 自由得一无所有, 没有任何实现自己劳动力所必须的东西.</strong></p><p>劳动力作为商品的条件不是很简单的, 所以资本的出现并不是容易的事. </p><p>就像货币是以商品交换发展到一定高度为前提的, 资本的产生, 也是以生产资料和生活资料的占有者在市场上找到出卖自己劳动力的自由工人为前提的. 因此, 资本已出现, 就标志着社会生产过程的一个新时代.</p><h3 id="深入分析劳动力"><a href="#深入分析劳动力" class="headerlink" title="深入分析劳动力"></a>深入分析劳动力</h3><p>自有工人提供给资本家的是作为商品的劳动力, 那么我们从商品的角度来分析劳动力. 商品的价值分为使用价值和价值量. 我们通过对劳动力这个商品的分析来复习以及强化对商品的理解.</p><h4 id="使用价值"><a href="#使用价值" class="headerlink" title="使用价值"></a>使用价值</h4><p>首先来分析劳动力的使用价值, 劳动力的使用过程就是劳动, 劳动倾注在别的商品上就可以提升别的商品的价值. 所以当劳动力被消耗, 另一件商品就有了被提升价值的可能性.</p><p>商品的使用价值和价格是无关的, 就像空气的使用价值非常高, 但因为充足, 所以没有被交易, 就没有价格. (商品被交易才会体现价值量) 而正因为劳动力在消费过程中可能产生价值, 这就使剩余价值的产生有了可能.</p><h4 id="价值量"><a href="#价值量" class="headerlink" title="价值量"></a>价值量</h4><p>再来观察劳动力的价值量. 当商品被交换, 商品的价值量就会被体现. 而商品的价值量是由社会平均劳动力的消耗来决定的. 那我们仔细观察: 劳动力需要消耗什么劳动力?</p><p>劳动力是需要吃饭, 才能提供劳动力的, 所以, 做出饭菜的的劳动力, 是劳动力价值量的一部分组成.</p><p>劳动力也需要住宿, 穿衣服, 交通, 这些消耗也可以平均到每天, 或是每个月, 也是组成劳动力价值量的一部分.</p><p>劳动力是会死的, 资本需要的是远远不断的劳动力, 所以劳动力培养子女所消耗的劳动力也是一部分劳动力的价值量.</p><p>另外还有让劳动力可以劳动的教育, 培训等所消耗的劳动力等.</p><p>用通俗的话讲, 劳动力的价值量就是: 维持一个人可以去上班所需要的钱. 包含衣食住行等.</p><h4 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h4><p>很明显地, 每个劳动力的价值量是差不多的, 那为什么每个人的工资可以相差那么多? 因为价值量是个抽象的概念, 价格形式有一个质的矛盾: 价格虽然是商品的价值形式, 但价格可以完全不是价值的表现. (上一章的总结)价格可以因为欺骗, 信息不对称, 市场而和实际价值量相差很多.</p><p>而在劳动力价格低于价值量的时候, 会发生的事情是, 劳动力的劳动水平下降. 也就是吃不饱饭干活, 干不好.</p><p>最后, 一般劳动力都是先劳动, 再拿工资的. 那么资本家的货币是作为支付手段的. 也就是自由工人一直是资本家的债权人(债主).</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>看完了第四章, 对前几章, 特别是第一章的内容有了更深刻的理解, 读了第四章以后有了以下大方向的认识:</p><ol><li><p><strong>资本家的特点是: 自己不产生价值, 只依靠买入卖出就使货币增值</strong>.</p></li><li><p><strong>因为唯一产生价值的途径是劳动, 所以资本家的必要特点是购买劳动力.</strong></p></li><li><p><strong>剩余价值是由(被购买的)劳动力进行消耗(使用劳动力, 即劳动)产生的.</strong></p></li><li><p><strong>劳动力的价值量(成本), 价格(薪资), 和能产生的价值(如何使用劳动力)三者的具体数量是没有联系的.</strong></p><p>劳动力的价值量是差不多的, 有的人吃得多, 有的人吃得少, 或是住得好&#x2F;坏, 教育好&#x2F;坏, 差别不大.</p><p>劳动力的价格是薪资或者是私活价格. 这个价格我认为决定于2个: 资本家预估这个劳动力能为自己产生多大价值, 这个劳动力在当前市场的供需关系.</p><p>劳动力能生产的价值, 取决于资本家如何使用劳动力. 资本家可以让劳动力把铁块从城东搬到城西, 可以让劳动力把铁块做成摩托车. 资本家的使用决定了能为世界总财富增加多少, 也决定了自己可以获取多少剩余价值.(都可以是负的)</p></li><li><p><strong>资本家对世界是有贡献的.</strong></p><p>因为劳动力被购买的必要因素是: 劳动力自己不知道如何产生价值. 资本家就成了劳动力的大脑, 他们指挥这些肌肉来使世界财富增加, 并且自己也承担了做错决定的风险.</p></li><li><p><strong>另外一些资本的性质和职能有待继续学习.</strong></p><p>指以”欺骗”来增值的资本, 和”利息资本”, 这些不使世界总财富增加的特殊资本的职能和存在的意义. (存在一定是有意义和作用的)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资本论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资本论第三章 货币或商品流通</title>
      <link href="/2019/11/11/das-capital-3/"/>
      <url>/2019/11/11/das-capital-3/</url>
      
        <content type="html"><![CDATA[<p>在了解了什么是商品和货币之后, 开始尝试理解他们职能的流通.</p><span id="more"></span><p>第一, 第二章介绍了什么是商品, 商品的交换是如何引入货币的.</p><p>第三章会继续根据”商品交换”这一行为的各个情况来深入分析货币的各个职能, 以及多出发生商品与货币的交换后, 产生的流通是怎么样的.</p><h2 id="货币与价格"><a href="#货币与价格" class="headerlink" title="货币与价格"></a>货币与价格</h2><h3 id="价值尺度"><a href="#价值尺度" class="headerlink" title="价值尺度"></a>价值尺度</h3><p>因为一切商品作为价值都是对象化的人类劳动, 所以可以进行通约, 他们找到了个具有合适的性质的商品作为货币. 这是货币作为价值尺度的职能.</p><p>商品的2个基本属性是价值和价值量, 价值量必须是人工估算的, 也就是说多少就多少的(但必须得到市场认可).</p><p>商品的价格形式(有价物)或货币形式(货币)都是体现了商品的价值量, 所以是观念性的形式.</p><p>(这里有个矛盾: 价格形式是观念性的, 但价格却是取决于实在的货币材料的)</p><h3 id="价格标准"><a href="#价格标准" class="headerlink" title="价格标准"></a>价格标准</h3><p>把货币固定成一个单位, 是货币的价格标准职能. 有了价格标准的职能, 货币(如金)本身的价值变动就不会影响价格形式的商品了. 因为: 无论金的价值如何变化, 12盎司金的价值一直是1盎司金的12倍. 如果没有价值标准的职能, 商品每次都要重新估算可以交换的货币的数量.</p><h3 id="价格形式"><a href="#价格形式" class="headerlink" title="价格形式"></a>价格形式</h3><p>价格形式是一种观念性的形式(价格多少是主观的), 并纯粹是社会的形式(元, 刀是脱离商品本身的社会名字).</p><p>因为是观念性的, 所以价格形式不一定等价于商品价值. 只要交易双方认可, 价格就可以是高于或低于商品价值的. 刚过双十一, 就用它举例: 一瓶机油双十一卖80, 平时卖90, 都是有成功的交易的. 同样的商品可以以不同的价格成交, 而显然商品的价值是固定的, 所以价格并不能完全表现价值.</p><p>因此, 价格形式包含着一个质的矛盾: 货币虽然是商品的价值形式, 但价格可以完全不是价值的表现.</p><h2 id="流通手段"><a href="#流通手段" class="headerlink" title="流通手段"></a>流通手段</h2><h3 id="商品的形态变化"><a href="#商品的形态变化" class="headerlink" title="商品的形态变化"></a>商品的形态变化</h3><p>在金与商品交换的时候, 是有商品的形态变化的.</p><p>首先<strong>金本身是商品</strong>, 所以本质是商品与商品交换.</p><p>在交换过程中一方商品作为使用价值, 一方商品作为交换价值. (也就是商品在交换的时候分化功能, 表现出不同的性质) 金是通过其他商品的价格, 才表现出自己的货币形态.</p><h3 id="商品形态变化与社会分工"><a href="#商品形态变化与社会分工" class="headerlink" title="商品形态变化与社会分工"></a>商品形态变化与社会分工</h3><p>在”为买而卖”(w - g - w)的商品流通中, 商品形态变化分为卖和买两步.</p><ul><li><p>第一形态变化, 卖(w - g): 商品持有者把商品从特殊价值形式转化为一般价值形式(货币).</p></li><li><p>第二形态变化, 买(g - w): 货币持有者把没有臭味的货币去交换自己需要的商品.</p></li></ul><p><strong>社会分工是由商品流通而自然形成的生产有机体, 商品流通与商品交换有质的区别.</strong></p><p>因为货币是一般价值形式, 货币可以交换一切商品, 商品交换只能在2个指定的特殊价值形式内部交换, 商品流通形成了一系列不受当事人控制的天然社会联系.</p><p>因为有了货币, 卖了不一定要买, 所以流通可以打破商品交换的时间, 空间, 个人的限制. 把换进商品和换出商品的统一性, 分裂成了买和卖之间的对立性.</p><p>在第一形态变化中, 商品持有者能否用自己的商品吸引出货币, 吸引多少货币, 取决于自己的商品对社会的使用价值的多少, 也就是证明了<strong>自己的劳动是社会分工的一部分</strong>, 而不是无效劳动.</p><p>社会所需要的东西是会变化的, 所以当社会分工产生变化的时候, 也会通过”无法吸引货币”来提醒过时的商品持有者不继续做无效劳动了.</p><p>总的来说, <strong>货币促成社会分工, 社会分工提高了社会发展效率.</strong></p><h3 id="货币的流通"><a href="#货币的流通" class="headerlink" title="货币的流通"></a>货币的流通</h3><p>作为商品流通的中介, 货币就取得了<strong>流通手段</strong>的职能.</p><p>我们来分析商品的生命周期: 被生产&#x2F;作为交换价值 &#x3D;&gt; 被卖 &#x3D;&gt; 作为使用价值&#x2F;进入消费领域.</p><p>而货币却不会进入消费领域, 于是: <strong>商品流通直接赋予货币的运动形式, 就是货币不断地离开起点, 从一个商品占有者手里转到另一个商品占有者手里, 这就是货币流通.</strong></p><h3 id="流通手段量"><a href="#流通手段量" class="headerlink" title="流通手段量"></a>流通手段量</h3><p>商品流通导致了货币流通, 那么就会有一定量货币被流通领域吸收.</p><p>世界上所有商品的价格总额是决定的(即使是波动的), 这个数量就是流通手段量.</p><p><strong>商品的总额决定于3个因素, 价格的变动, 流通的商品量, 货币的流通速度.</strong></p><p>商品的价格变高, 商品量变大, 商品总额变大. 这两个因素是显而易见的.</p><p>对于流通速度, 需要仔细说明.</p><p>假设世界上有4件100元的商品, 那么就需要400元的流通手段量, 也就是400元把商品买完. (如果世上有500元, 那么剩下的100元将会买不到任何商品)</p><p>如果出现了一个情况: a用100元买了b的商品, b用100元买了c的商品, …</p><p>最后100元在各个商品占有者手上流通(就是货币流通形式), 剩下的300元没有动(这300也买不到任何商品了).</p><p>以上的例子就是: 货币流通速度变为了4倍, 商品流通所需要的货币减少了4倍. <strong>商品的流通次数增加, 流通的货币量就会减少.</strong></p><p>这也推出一个结论, <strong>每个货币都对另外一个货币承担责任</strong>, 一个货币加快流通速度, 另一个货币就会放慢流通速度, 甚至完全退出流通领域. (别人用钱还是不用钱, 影响到你口袋里钱还值不值钱)</p><p>如果货币的价值产生了变化, 这个变化不会一下子传播到所有的商品上, 而是根据流通慢慢传播, 当传播到所有商品上的时候, 表明这些价值变化后的货币已经流通到了所有商品领域.</p><p>以最近(2019&#x2F;11)的猪肉涨价为例, 近期流行一个笑话: 油条涨价了, 问老板为什么涨价, 老板答我想吃猪肉啊.</p><p>看似是笑话, 其实揭示了这个原理, 货币价值变化总是从一个入口进入流通的, 通过商品流通扩散到所有商品.</p><h3 id="关于流通手段量的直觉"><a href="#关于流通手段量的直觉" class="headerlink" title="关于流通手段量的直觉"></a>关于流通手段量的直觉</h3><p>基于刚才的结论: <strong>买下世上所有商品需要的钱, 决定于: 商品的总价(单价*数量), 商品流通的速度.</strong> 我们来分析两个错误的直觉.</p><h4 id="商品太贵是因为钱太少"><a href="#商品太贵是因为钱太少" class="headerlink" title="商品太贵是因为钱太少"></a>商品太贵是因为钱太少</h4><p>这是一个普遍的直觉, 主要逻辑是:</p><p>iphone11好贵 &#x3D;&gt; 我钱少, 如果我钱翻倍那么iphone11就不贵了 &#x3D;&gt; 社会上的钱少, 钱多, 我分到得多, iphone11就不贵了.</p><p>看似很有道理, 错在用结果推原因了. 其实是: **手段量决定于商品总价与流通速度2个因素. 而问题基本出在流通速度. **比如:</p><ul><li><p>市场效率低(一个市场的人都希望卖, 而另一个市场的人都希望买)</p></li><li><p>进出口停滞</p></li><li><p>消费缩减(一部分人的贫困导致不能使基本的生活费用流通起来)</p></li></ul><p>基于理论我也做个假设逻辑:</p><p>我忍一忍贵买下了iphone11 &#x3D;&gt; 手机店老板钱多了, 觉得鸡腿不那么贵, 决定午饭加个鸡腿 &#x3D;&gt; (假设我是饭店老板)客人平时只吃10块钱的饭, 现在再买个10块钱的鸡腿, 我收入翻倍了.</p><p>可以看出, 只要商品流通起来, 大家都会变得更有购买力. 即使我不是饭店老板, 这个购买力提升的循环也是会慢慢影响到我的.</p><h4 id="商品的价格决定于国家现有多少钱"><a href="#商品的价格决定于国家现有多少钱" class="headerlink" title="商品的价格决定于国家现有多少钱"></a>商品的价格决定于国家现有多少钱</h4><p>这个我一直认为是这样的, 我经常说”国家又发钱了, 所以东西又贵了”. 这是个非常肤浅的看法.</p><p>根据刚才的结论, 如果商品总价不变, 商品流通速度不变, 那么可以得出需要购买所有商品的钱是不变的. 如果价格变高, 代表的是钱本身不值钱了.</p><p>所以真正的情况我认为是:</p><ol><li><p>钱变得不值钱了, 但东西一涨价, 生意会不好, 所以商家忍着不涨价, 导致商家收入降低.</p></li><li><p>商家收入降低, 愿意购买的东西变少, 然后恶性循环, 经济变冷.</p></li><li><p>国家发现问题, 发钱, 来弥补贬值了的钱. (保持钱的价值*钱的数量 &#x3D; 商品总价 &#x2F; 流通速度) 因为价值下降, 所以要提高数量. 不然发生了1, 2的恶性循环, 流通速度下降, 所需要的(等式左边的值)更大, 会造成更大的危机.</p></li><li><p>货币数量变多, 从一部分人手里进入流通, 购买意愿上升, 价格上涨到合适的位置, 进入新的平衡.</p></li></ol><p>总结是: 国家发钱是在救市, 而不是导致钱贬值的原因. 至于钱贬值的原因, (我)目前的知识还不知道.</p><h3 id="铸币-价值符号"><a href="#铸币-价值符号" class="headerlink" title="铸币, 价值符号"></a>铸币, 价值符号</h3><p>金银离开造币厂进入流通, 金银会慢慢磨损, 但进行流通的时候却没有被拒绝换取对应价值的商品.</p><p>这个情况已经慢慢显示出<strong>货币在作为流通手段职能的时候是纯粹的象征性质.</strong> 所以才有了纸币. 纸币成为了价值符号.</p><p>之前提到货币的<code>价值尺度</code>和<code>价格标准</code>的职能, 因为金块在流通中执行的职能纯粹是流通手段, 所以纸币才能代替金块.</p><p><code>价值尺度</code>与<code>价格标准</code>的职能都体现在商品的价格上了, 这两个职能早在货币流通前就已执行了.</p><h2 id="货币的其他职能"><a href="#货币的其他职能" class="headerlink" title="货币的其他职能"></a>货币的其他职能</h2><p><strong>作为价值尺度并因而以自身或通过代表作为流通手段来执行职能的商品, 是货币.</strong></p><p>这是货币的定义, 货币有以下特点:</p><ul><li><p>是商品.</p></li><li><p>有价值尺度的职能.</p></li><li><p>有价格标准的职能.</p></li><li><p>有流通手段的职能, 并在纯粹作为流通手段时, 可以被代表.</p></li></ul><p>金是一种货币, 他作为货币执行职能, 有不同的场合:</p><ul><li>必须以金体出现, 作为<strong>货币商品</strong>, 他不像充当价值尺度的时候是观念的, 也不可以像作为流通手段时可以被纸代表.</li><li>不一定以金体出现, 作为唯一的价值形态, 与其他一切仅仅作为使用价值的商品相对立.</li></ul><p>在这些不同的场合, 金也衍生出了其他一些职能.</p><h3 id="货币贮藏"><a href="#货币贮藏" class="headerlink" title="货币贮藏"></a>货币贮藏</h3><p>因为货币是一般价值形式, 可以用来交换任何商品, 一切商品的差别在货币上消失了, 于是产生了求金欲, 并且求金欲是没有止境的. 这是货币贮藏产生的原因, 下面来分析一下货币贮藏的特点.</p><p>商品借助货币流通, 是”为买而卖”的, 货币只是一个中介.</p><p>当求金欲发展起来, 出售商品不是为了购买, 而是为了用货币形式代替商品形式. 货币本来是中介, 现在变成了目的.</p><p>商品流通是”为买而卖”(w - g - w)的, 商品在进行了第一形态变化(卖)以后, 第二形态变化(买)被打断了, 于是商品流通和货币流通都被打断了.</p><p>于是结果是: 货币硬化为贮藏货币, 商品出售者成为货币贮藏者.</p><p>贮藏货币在金属流通中执行着种种不同的职能. 其中一个职能就是: 因为商品的价格, 数量, 和流通速度是不断变化的, 也就是需要的流通手段量是不断变化的. 贮藏货币就提供了这个弹性, 来保持流通领域货币量的饱和程度. (我的简单理解就是商品少了钱可以藏着, 商品多了钱可以拿出来用, 所以必须有正被存着的钱.)</p><h3 id="支付手段"><a href="#支付手段" class="headerlink" title="支付手段"></a>支付手段</h3><p>这里”支付”的含义与”购买”相对, 是”还钱”的意思.</p><p>所谓支付手段, 就是在各种情况下, 产生了先获得商品, 然后约定指定的未来某个日期来还钱, 此时货币就充当支付手段, 因为把货币交给原商品占有者的行为是支付.</p><p>接下来分析一下支付手段的特点.</p><p>货币在支付手段中依然执行了价值尺度和购买手段的职能, 因为商品还是由货币估价的(价值尺度), 并且商品流转了(购买手段).</p><p>支付与购买的区别根本在于: 货币交给商品占有者的时间延后了.</p><p>于是自然想到一些与”购买”相比不同的点.</p><h4 id="无法支付"><a href="#无法支付" class="headerlink" title="无法支付"></a>无法支付</h4><p>货币的支付手段产生了信用货币, 支付手段直接引入了信用的问题, 先不深入展开.</p><p>但一般在到期后无法支付, 首先会强制拍卖购买者的财产, 或者导致一些关系的破裂, 或者沦为奴隶.</p><h4 id="目的对比"><a href="#目的对比" class="headerlink" title="目的对比"></a>目的对比</h4><p>商品流通的购买者: 为买而卖. 卖自己的商品是为了买东西.</p><p>货币贮藏者: 为了储存万能的商品(货币).</p><p>欠债者: 为了支付.</p><p>其实我们在生活中可能同时是这些角色:</p><p>我们卖了商品(工作是卖自己的服务), 获得了货币. 打算好这个月工资发了就买个什么东西, 那么就是”为买而工作”; 如果忍者不买东西或者没东西可买, 可以把钱存着以后买什么都可以, 就是货币储藏者; 或者是买了什么24期免息的东西, 则每个月的某一天要支付(还)一笔钱, 此时就是债务人的角色.</p><p>这里提一点, 其中最划算的是债务人, 24期免息其实是让商品更便宜了, 货币是有时间价值的.</p><h4 id="债务关系链与对货币流通量的影响"><a href="#债务关系链与对货币流通量的影响" class="headerlink" title="债务关系链与对货币流通量的影响"></a>债务关系链与对货币流通量的影响</h4><p>在商品第一形态变化(卖)之前, 先发生了第二形态变化(买), 举个很简单的例子, 我卖了一头羊, 拿到了钱, 是为了还我已经吃掉了的牛.(先获得商品, 再卖自己的商品).</p><p>于是很明显地, 支付手段会对货币流通量造成影响. 先抛开无法支付的情况, 支付手段使商品流通先于货币流通, 解决了流通量短时间不足的问题. 如果衣服厂家没钱买布, 那么就无法生产, 如果可以先获得布, 再生产, 卖了衣服后支付布的钱. 就不会出现因为流通量不足导致社会财富增长停滞的问题. (制造衣服是增加社会财富)</p><p>另外, 债务密集以后, 会产生债务链, 在经济发展好的地区, 支付手段会占主要, 金银交易只占小部分.</p><p>也举一个例子: a给b一头牛, 30天后收钱100元. b给a一头羊, 30天后收钱120元. (为了简化关系, 实际上是关系链) 那么, 在进行了债务转移以后, 30天后, 只要a给b20元就行了.</p><p>本来需要220元的流通手段量, 现在只需要20元的支付手段量就可以了. 这是一个节约支付手段的杠杆.</p><h3 id="世界货币"><a href="#世界货币" class="headerlink" title="世界货币"></a>世界货币</h3><p>因为价格标准, 铸币, 辅币和价值符号都是地方形式, 超出了一定区域就无效了(在中国我们就不接受日元或美元买自己的东西吧). 所以在世界市场上, 作为货币的又回到了贵金属块上, 货币的职能和形式也回到了最初的样子.</p><p>所以每个国家都会有准备金, 一部分就是为了世界市场的流通. 货币贮藏的职能, 一部分来源于货币作为国内流通手段和国内支付手段的职能, 另一部分来自于作为世界货币的职能.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完第三章, 对第一章到第三章做一个宏观高度总结:</p><ol><li><p><strong>财富是商品.</strong> </p><p>而不是货币. 存钱并不是持有财富, 而只是为社会做贡献. (完成一部分货币贮藏的职能, 自己付出了通货膨胀的代价, 也承受着货币破碎的风险)</p></li><li><p><strong>财富的生产途径是劳动.</strong> </p><p>并且是唯一途径. 产生财富就能获得货币, 但获得多少与产生了多少财富并不匹配. (价格与商品价值的矛盾). 促进贸易能为社会做出贡献, 也能获得货币.</p></li><li><p><strong>货币的作用是提高人类产生财富的效率.</strong></p><p>第一, 通过形成社会分工. 社会分工使每个人只做一个类别的事, 可精通. 并且使每个人都做社会所需要的事, 可避免无效劳动.(无效劳动吸引不了货币)</p><p>第二, 促进更深入的劳动. 因为酒足饭饱后人会不劳动而休息. 货币的出现给了人类劳动的理由.</p></li><li><p><strong>货币只是一个想象的东西, 并且很多情况会导致想象破碎, 产生危机.</strong></p><p>货币只是一个工具, 而且在很多情况下会出现危机, 使人不再信任他. (例如使用得少, 通货膨胀变快, 国家信用变化) 所以要使货币正常履行他的各个职能, 需要各种金融手段来维护.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资本论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何控制自己</title>
      <link href="/2019/10/12/how-to-control-yourself/"/>
      <url>/2019/10/12/how-to-control-yourself/</url>
      
        <content type="html"><![CDATA[<p>“懂了那么多道理, 依旧过不好这一生”, 这本是一个非常严肃并值得探讨的问题, 大多数人看到这句话的反应是”原来大家都这样”并认为自己的不作为是合理的, 那真的非常糟糕.</p><p>于是这次细看了<code>意志力</code>来粗略探讨一下这个问题产生的原理以及去尝试解决或改善问题.</p><p>现在心灵鸡汤有那么多, 本文会给与你最缺的: 一把喝汤的勺子.</p><span id="more"></span><h2 id="什么是意志力"><a href="#什么是意志力" class="headerlink" title="什么是意志力"></a>什么是意志力</h2><ul><li>某些不作为的亲戚说出了自己非常同意的理论, 我会好奇他那么懂为什么还不是很厉害.</li><li>很多大人会转发”看开”, “不责怪他人”, “心态赢得人生”的微信文章, 但立马就与亲人朋友闹矛盾.</li><li>我们明白学习&#x2F;进步对人的好处, 但不知不觉又在游戏&#x2F;抖音&#x2F;朋友圈中度过了一整天.</li></ul><p>尝试去做身体不愿意做的事, 所需要的能力就是意志力.</p><p>在很多知识体系中都有类似的概念: “脑中的天使与恶魔”, “爬行脑&#x2F;大脑边缘系统与大脑皮层”, “本我与自我”, 那么如何使”天使战胜恶魔”, “大脑皮层控制爬行脑”, “让超我控制行为”, 需要的就是意志力了.</p><h3 id="意志力的作用"><a href="#意志力的作用" class="headerlink" title="意志力的作用"></a>意志力的作用</h3><p>很明显, 拥有更强的意志力, 就可以做出”对自己有利的”而不是”让自己爽的”事情, 从而过上更好的人生.</p><p>意志力加强以后, 对学习提升的效果最明显, 对人际关系也有提升, 对减肥作用比较小.</p><h3 id="意志力减弱产生的问题"><a href="#意志力减弱产生的问题" class="headerlink" title="意志力减弱产生的问题"></a>意志力减弱产生的问题</h3><ul><li>意志力减弱的时候会做出许多让自己后悔的事. 例如暴食, 醺酒, 对亲人&#x2F;朋友说出无法挽回的话.</li><li>失去评价和折中能力, 容易接受推荐值, 比如购买非常不值得买的东西. 所以意志力长期低下的人有再多钱也会全部失去.</li><li>避免选择, 风险厌恶. 导致拖延, 浪费时间, 无作为.</li></ul><h3 id="本文内容提要"><a href="#本文内容提要" class="headerlink" title="本文内容提要"></a>本文内容提要</h3><p>了解了意志力强的收益之大, 意志力弱会把生活搞得多糟糕之后. 预告一下读完本文会知道些什么:</p><ul><li><strong>意志力的基础理论.</strong> 了解了意志力的基本特点才能更好与他相处. (书中都是通过科学实验获得的结论, 这里全文都是总结最终结论)</li><li><strong>分析存在的问题 — 意志力是如何减弱的.</strong></li><li><strong>分析存在的问题 — 锻炼意志力会碰到什么困难.</strong></li><li><strong>解决方案 — 如何控制意志力减弱.</strong></li><li><strong>解决方案 — 如何增强意志力.</strong></li><li><strong>与意志力相关的现象.</strong> 用这次分析的结果来看待一些普遍的问题: 自尊, 减肥, 拖延.</li></ul><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><ul><li>意志力的消耗与增长像肌肉, 使用了会消耗, 休息了会恢复, 锻炼了会增强.</li><li>各方面的意志力(学习, 社交, 控制行为)是从同一个账户中提取的. 在一个方面消耗多了意志力, 能用在其他处的意志力也减少了. </li><li>意志力分为强度和耐力, 并且一种意志力增强其他方面也会增强. (戒了烟的人生活其他方面也更好了)</li><li>葡萄糖是意志力的生理基础. 调用意志力消耗葡萄糖.</li></ul><p>根据这些理论基础, 我们不难看出想提高意志力, 我们可以做的有两点: 减少不必要的消耗, 锻炼意志力使意志力更充沛.</p><p>下面的章节分为2个大部分: <code>现状</code>(意志力没有用到最需要的地方, 锻炼意志力又容易失败) 与<code>解决方案</code>(如何避免意志力消耗, 锻炼意志力的正确方式)</p><h2 id="意志力的消耗"><a href="#意志力的消耗" class="headerlink" title="意志力的消耗"></a>意志力的消耗</h2><p>意志力的消耗有一个特点: <strong>无感知</strong>. 正在消耗意志力的人不会觉得心烦意乱和难受, 而在之后需要使用意志力而意志力不足的时候才感受到问题.</p><p>意志力减弱以后的表现是: <strong>所有情绪都被感受得更强烈了.</strong> 我们可以以此为线索意识到自己的状况. 情绪被强化的表现可以是: 不太开心的事情自己觉得很开心, 不太悲伤的觉得很悲伤. 也可以是: 不太恐怖的觉得很恐怖, 同时面对食物&#x2F;礼物, 也会更想吃&#x2F;打开.</p><p>那么, 在说如何处理意志力消耗前, 先来列举一下消耗意志力的行为:</p><ul><li><p>控制自己的思维. </p><p>准确地说是切换思维(在不同的思维中转换)是消耗意志力的.</p><p>这也是为什么复杂的谎言不能成功, 说谎者要在现实和编造的逻辑中切换思维, 意志力消耗完就不能继续编造了. (所以销售要先让自己相信产品是好的) </p><p>或者是看着红色的”绿”字要回答是什么颜色, 被试者要控制识别颜色和识别字的思维导致回答变慢.</p><p>另外人会有一种”心猿”的体验: 一些事情会自动浮上心头, 又必须控制自己去思考当前的事. 比如工作的时候会想到晚上的约会或是想到明天孩子的家长会.</p></li><li><p>控制情绪.</p><p>在遇到不开心的时候控制自己不生气&#x2F;不发怒. 在听到别人坏消息的时候控制自己不能开心. 或是控制自己在不太喜欢的客人来访时变得开心&#x2F;开朗.</p></li><li><p>控制冲动.</p><p>控制自己不喝酒&#x2F;吃肉等许许多多想干的事.</p></li></ul><p>了解了会不小心在不重要的事上浪费意志力的点, 就可以采取一些策略, 记住一些原则来避免意志力的浪费, 把意志力用在重要的事上.</p><h2 id="锻炼意志力的困难"><a href="#锻炼意志力的困难" class="headerlink" title="锻炼意志力的困难"></a>锻炼意志力的困难</h2><p>除了避免浪费, 我们在锻炼意志力的时候也会遇到一些普遍的困难. 就在开篇所说的”明明决定减肥, 最后又吃了”, “明明决定不生气, 还是暴怒了”, “明明决定好好学习, 却又玩游戏或睡觉了”.</p><h3 id="情绪温差"><a href="#情绪温差" class="headerlink" title="情绪温差"></a>情绪温差</h3><p>举几个最常见的例子: 肚子饿了点菜结果吃了一小半, 浪费了很多粮食. 办了一年健身卡, 去了一周就再也没去过. 情侣结婚后性情大变. 需求评审2周的任务延期到3周还没做完.</p><p>把情绪分成”热”与”冷”, 情绪温差是指<strong>出于不同情绪温度的时候会错误估计另一种温度时自己的行为.</strong></p><p>也就是恶魔睡着的时候, 天使低估了恶魔清醒时控制身体行为的能力, 而没有去做足准备防御恶魔.</p><h3 id="诱惑越近越大"><a href="#诱惑越近越大" class="headerlink" title="诱惑越近越大"></a>诱惑越近越大</h3><p>精神也存在着近大远小的原理. 分别举个物理上和精神上的例子.</p><p>一个戒酒的人路过了个酒吧, 酒吧占了他视野的10%, 他想着路过没有关系, 随着离酒吧越来越近, 酒吧在视野里的比例也就越来越大. 直到… 他走进酒吧的一刻, 酒吧占据了他视野的100%, 再想走出就很难了.</p><p><code>在6天后获得100元</code>与<code>在9天后获得200元</code>中选择, 大多人会选择后者.</p><p>而<code>在现在获得100元</code>与<code>在3天后获得200元</code>中选择, 大多人就会选择现在获得100元.</p><p>这个感受在生活中是非常常见的, 比如食物越容易获得越容易吃(过年胖是因为食物都不需要额外付钱并端到面前), 吵架越激烈的时候越难停止.</p><p>分析完了意志力是如何偷偷消耗的, 以及锻炼意志力时遇到的问题(几乎所有人都是因为这2个困难而失败).  下文开始进入核心环节: 如何解决这些问题, 使自己合理运用意志力并走向更好的人生.</p><h2 id="控制意志力的减弱"><a href="#控制意志力的减弱" class="headerlink" title="控制意志力的减弱"></a>控制意志力的减弱</h2><h3 id="减少意志力下降对生活造成的影响"><a href="#减少意志力下降对生活造成的影响" class="headerlink" title="减少意志力下降对生活造成的影响"></a>减少意志力下降对生活造成的影响</h3><p>意志力的下降是无感的, 所以<strong>当发现自己的情绪被”放大”的时候, 要意识到意志力下降了.</strong></p><p>如果没意识到自己意志力下降, 可能会: 对亲人&#x2F;领导说出无法挽回的话, 购买了性价比很低的东西, 签下了非常不公平的协议. 以及其他不那么严重的问题(暴食&#x2F;烟酒).</p><blockquote><p>当意识到意志力下降时应该做的事: 尽量少说话, 少做决定.</p><p>然后(累了的话)睡觉, 或者(没有能量的时候)补充高葡萄糖的失误. (吃点心, 糖, 粥)</p></blockquote><p>但吃葡萄糖是一个临时的解决方案, 如果想保持长时间不因为缺糖而意志力低下, 要养成吃粗粮(低GI食物)的习惯.</p><h3 id="一次只做一件事"><a href="#一次只做一件事" class="headerlink" title="一次只做一件事"></a>一次只做一件事</h3><p>一次只做一件事, 是用来避免”切换思维”的意志力消耗的.</p><p>也许在同时做多件事的时候你觉得自己可以做到, 但<code>意志力消耗是无感的</code>, 你消耗了本不需消耗的意志力.</p><p>如果在做”红色的绿字是什么颜色”游戏的时, 把”绿”字换成被试者不认识的语言, 被试者识别颜色的速度就提高了许多, 因为他不用认字只需要认颜色就行了.</p><h3 id="处理心猿"><a href="#处理心猿" class="headerlink" title="处理心猿"></a>处理心猿</h3><p>“心猿”是指会在脑中突然出现的事情(上文已提及). 出现心猿以后, 我们需要把思维拉回之前在思考的东西, 这个过程还会反复出现, 所以就消耗了意志力.</p><p>心猿其实是人脑的一种机制, 人脑有定时任务, 把”注册”在脑子里的事情定时过一遍, 来确认是否要做, 如果需要去做的, 就会浮现在脑子里. (思考你为什么会9点去上班, 而不是忘记: 大脑每过一段时间会问现在是几点, 这个时间是否有任务要执行. 如果有, 就把这个任务推到你的意识中)</p><p>解决心猿的方法是:</p><blockquote><p>每个心猿出现, 就把任务列出来, 并且去想清楚解决这个任务的步骤.</p><p>一定要让自己的大脑相信, 这个问题已经想好解决方案了, 那么心猿就不会出现了.</p></blockquote><h2 id="锻炼-x2F-增强意志力"><a href="#锻炼-x2F-增强意志力" class="headerlink" title="锻炼&#x2F;增强意志力"></a>锻炼&#x2F;增强意志力</h2><p>锻炼意志力的核心思路在于: <strong>主动出击, 以攻代守.</strong></p><p>一个对高意志力人的统计结果是: <strong>高意志力的人使用意志力比较少.</strong></p><p>原因就是, 意志力高的人把意志力用在了控制生活轨迹上, 而其他人缺用在”救火”上.</p><blockquote><p>意志力高的人把意志力用在”重要”的事上, 意志力低的人则用在”紧急”的事上.</p></blockquote><p>举几个简单的例子:</p><table><thead><tr><th>场景</th><th>高意志力</th><th>低意志力</th><th>前者意志力消耗以后</th><th>后者意志力消耗以后</th></tr></thead><tbody><tr><td>看到富人</td><td>使用意志力思考并努力变成富人</td><td>使用意志力控制自卑情绪</td><td>变得更优秀</td><td>自暴自弃</td></tr><tr><td>身体肥胖</td><td>使用意志力减肥</td><td>使用意志力控制自卑情绪</td><td>变瘦一些</td><td>任由身体发展</td></tr><tr><td>身体肥胖</td><td>使用意志力接纳自己的肥胖</td><td>使用意志力控制自卑情绪</td><td>胖也自信</td><td>不敢交友&#x2F;自闭</td></tr></tbody></table><p>那么下面来说锻炼意志力, 合理使用意志力的做法.</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><h4 id="养成习惯"><a href="#养成习惯" class="headerlink" title="养成习惯"></a>养成习惯</h4><p>假设做一件对长期有利而短期没效果的事, 是需要使用意志力的.</p><p>而如果连续使用意志力坚持做这件事, 养成了习惯, 之后的意志力就变少了, 而收益没有变少. 就”赚”了.</p><p>举例: 每天看书消耗5分意志力. 坚持了2个月后, 每天看书只要消耗1分意志力. 而看书的收益不变, 使用的意志力减少了. 这就是为什么高意志力的人使用的意志力比较少.</p><h4 id="同时只设定一个目标"><a href="#同时只设定一个目标" class="headerlink" title="同时只设定一个目标"></a>同时只设定一个目标</h4><p>接上一条, 需要养成一个习惯, 需要持续消耗很多意志力.</p><p>如果在养成习惯过程中意志力不够用放弃了, 就非常不划算.</p><p>另外一个原因是, 很多目标之间是存在矛盾的, 而目标之间的矛盾又会额外消耗意志力.</p><p>像”新年目标清单”之类的东西, 因为目标又多冲突的可能又大, 如果同时进行, 可能明年的清单也是他哦.</p><h4 id="使用监督与量化来增强意志力"><a href="#使用监督与量化来增强意志力" class="headerlink" title="使用监督与量化来增强意志力"></a>使用监督与量化来增强意志力</h4><p>监督: 把自己的目标告诉别人, 或者公布于众. </p><p>量化: 用一些手段(软件&#x2F;账本)来记录自己吃了多少东西&#x2F;用了多少钱&#x2F;在每个app上花了多少时间(苹果的screen time). 大多数人看到统计以后会大吃一惊, 原来每天的大部分时间都用在了没有意义的事上.</p><p>监督和量化的基本原理都是: <strong>强化自我意识, 提高自我意识可以增强意志力.</strong></p><p>对于自己的不满, 担心别人对自己印象不好, 担心自己生病, 这些都自我意识的表现.</p><h4 id="设置合理的目标与奖励"><a href="#设置合理的目标与奖励" class="headerlink" title="设置合理的目标与奖励"></a>设置合理的目标与奖励</h4><p>“合理”的展开比较复杂, 这里只能描述一下基本思路.</p><p>首先目标的设定分为长期和短期, 长期与短期在各个场景各有利弊, 但要遵从<strong>鼓励自己更好完成长期目标</strong>的基本原则.</p><p>设置奖励更是个复杂的问题, 因为整个游戏行业的研究都是在探索如何设置奖励可以让人坚持下去.</p><p>游戏是个非常棒的东西, 我们可以仔细分析游戏里吸引自己的内容, 这都是好多优秀的人总结的优秀方法(来使人坚持把事情做下去). 如果我们能分析原因并用到对锻炼意志力过程的奖励, 那么效果会非常好的.</p><p>(在这里也给自己挖个坑, 之后仔细分析一下游戏中吸引自己的点)</p><h3 id="实施技巧"><a href="#实施技巧" class="headerlink" title="实施技巧"></a>实施技巧</h3><p>做好了前期准备, 进入锻炼的时候会碰到情绪温差, 下面几条技巧也许是本文最重要的部分, 也就是”心灵鸡汤的汤勺”.</p><h4 id="把短期与长期联系起来"><a href="#把短期与长期联系起来" class="headerlink" title="把短期与长期联系起来"></a>把短期与长期联系起来</h4><p><strong>思考长期利益更多的人意志力会比思考短期利益更多的人高.</strong></p><p>所以在更多的情况下, 把短期利益和长期利益联系起来, 就会获得更多意志力. 举几个例子</p><ul><li>(我在知乎上看到分享经验)每坚持一件事就告诉自己, 坚持完能获得什么. 比如每天学习1小时, 一年后可以加xxx工资.</li><li>喝喜茶前思考, 如果少喝10杯喜茶, 就能买一支自己喜欢的口红. 如果坚持用老款iphone5年, 省下的每年1万新iphone钱可以买一套舒服的床和沙发.</li></ul><p>如此, 多思考长期利益, 就能提高意志力, 去做正确的事.</p><p>有一点必须强调: <strong>把短期长期联系起来, 并不是在编故事, 而是真实的事, 能获得真实的长期受益.</strong> 事实上确实有很多人在星巴克上花了几万块, 但并没有获得相应的快感.</p><blockquote><p>少吃10杯喜茶, 真的可以获得一支喜欢的口红.</p><p>每天学习1小时坚持一年, 真的可以让工资从1万变2万.</p><p>只是面对短期利益的时候忘记了长期利益, 如果提醒自己长期利益, 那么就真的可以获得长期利益. (短期诱惑一定是让自己”亏大了”的)</p></blockquote><h4 id="避开诱惑"><a href="#避开诱惑" class="headerlink" title="避开诱惑"></a>避开诱惑</h4><p>这是用来针对”诱惑越近就越大”原则的方法.</p><p>如果你想戒酒, 那么就尽量走没有酒吧的路. 如果你想戒游戏, 那么暂时把电脑放到平时看不见的地方.</p><p>有一个”仓储理论”: 把孩子送进学校不是在乎孩子在学校里得到了什么, 目的在于孩子可以不在学校外受到危险.</p><p>我们可以做一些事情来避免诱惑, 比如: (需要减肥)吃年夜饭吃一点就进房间玩游戏.&#x2F;(需要戒游戏)经常约朋友出去玩.</p><h4 id="设置明线"><a href="#设置明线" class="headerlink" title="设置明线"></a>设置明线</h4><p>给自己设置一个<strong>清晰的, 不能找借口的</strong>底线. 让自己不能越过.</p><p>为了理解, 我举两个反例(错误底线):</p><ul><li><p><strong>电脑游戏不能多玩.</strong> </p><p>结果: 好像2局不多, 好像3局不多, 好像… (诱惑越近, 情绪越热, 越无法自拔)</p></li><li><p><strong>为了我的孩子, 我要戒酒.</strong> </p><p>给自己留了后路, 正确的是: <code>孩子死了我也不能喝酒</code>. </p><p>我之前也有类似的观点: <code>因为别人做了坏事, 觉得自己也可以做坏事了. 那么说明自己本来就想做坏事. </code>只是找了个外因的借口.</p></li></ul><h4 id="延后享乐"><a href="#延后享乐" class="headerlink" title="延后享乐"></a>延后享乐</h4><p>这是克制短期诱惑的最佳方式:</p><blockquote><p>有了短期冲动以后不要拒绝冲突, 而是<strong>告诉自己可以做, 但是晚一些.</strong></p></blockquote><p>书中有一个实验是这样的:</p><p>让3组被试者与巧克力在一起. 第一组: 随便吃. 第二组: 今天绝对不能吃. 第三组: 现在不能吃, 之后随便吃.</p><p>在一段时间以后, 当实验者被告知”可以随便吃了”的时候. 第三组被试者吃得最少, 甚至比第一组(之前已经随便吃, 肚子里还有巧克力的组)吃得还少.</p><p>也就是延后享乐(给自己暗示可以做, 就已经获得了满足感)甚至比及时享乐更满足, 并且阻止一些短期冲动.</p><h4 id="实施意向"><a href="#实施意向" class="headerlink" title="实施意向"></a>实施意向</h4><p>实施意向是用来对付”情绪温差”的, 而”情绪温差”正是锻炼意志力途中最重要的敌人, 可见实施意向的重要性.</p><p>具体的方法就是: 在清醒的时候(定计划的时候), <strong>尽可能仔细思考在实行中可能遇到的问题, 并告诉自己, 那个时候该如何做.</strong></p><p>这个难度在于: 不高估自己, 想得够细&#x2F;真正去感受锻炼意志力时的难点.</p><p>比如: 如果菜里有红烧肉, 我就不吃. 比如: 如果决定去吃自助餐, 我就只吃蔬菜和瘦肉.</p><p>(这个技巧有一点像”盗梦空间”的思路.)</p><h4 id="不让自己做别的事"><a href="#不让自己做别的事" class="headerlink" title="不让自己做别的事"></a>不让自己做别的事</h4><p>这是一个实施意向的例子, 用来解决拖延症. </p><blockquote><p>拖延的本质是人不能克制短期冲动.</p></blockquote><p>为什么这么说, 其实仔细思考就能发现: 所谓拖延, 实际上是:<strong>在做长期收益的事的时候, 没有克制住短期冲动, 而去做了短期冲动的事.</strong></p><p>比如: 在看书(长期收益)的时候, 看了下手机(短期快感), 剪指甲, 做家务. (是的, 做家务也是短视的行为, 因为可以立即看到成效, 而长期利益的事不能马上看到效果的).</p><p>所以, 克制拖延的事实意向是: <strong>在做一件长期事的时候, 不能做任何别的事情.</strong> 这样就算不能坚持连续锻炼, 在不做短期冲动的事, 发现没事做以后, 会回去继续锻炼意志力的. 例如: 看书的时候不能做别的事, 包括看手机, 想心事, 睡觉.</p><h3 id="LEAP"><a href="#LEAP" class="headerlink" title="LEAP!"></a>LEAP!</h3><p>知道了如何锻炼意志力, 那么就可以开始行动了. 我们可以按照以下来锻炼意志力.</p><ol><li>设定一个目标. 只能是一个, 然后持续地花意志力, 坚持一段时间. (我定的是2个月, 目标是: 使用的意志力减少了也能维持达成目标)</li><li>给自己设定合理的小目标以及奖励.</li><li>在做任何事情的时候, 尽量思考长期利益.</li><li>仔细思考执行中会遇到的困难, 并定制实施意向. (在实施过程中遇到的困难也要整理进实施意向)</li></ol><p>如此, 每个一段时间养成一个好习惯, 未来的生活便会更加美好.</p><h2 id="意志力周边的故事"><a href="#意志力周边的故事" class="headerlink" title="意志力周边的故事"></a>意志力周边的故事</h2><p>本文内容已结束, 下面说一些书中提到的小事.</p><h3 id="自尊-x2F-自制"><a href="#自尊-x2F-自制" class="headerlink" title="自尊&#x2F;自制"></a>自尊&#x2F;自制</h3><blockquote><p>培养孩子(甚至是影响周围成人的行为). 需要做的是: <strong>一致的, 及时的对他的行为作出相应.</strong> 这样对方就会体会到规则, 而不是混乱.</p></blockquote><p>有一个时代, 大人流行夸奖孩子, 让孩子获得自尊, 并觉得被鼓励多的孩子就会有更大自信和成就.</p><p>然后结果是非常失败. 大人能做的对孩子最好的事就是: <strong>尽量客观地评价孩子的一切行为.</strong> 这样孩子得到正确的反馈, 建立起正确的世界观, 对世界的适应就会更良好了.</p><h3 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h3><p>因为意志力的来源是葡萄糖, 所以用意志力减少葡萄糖摄入本身是有矛盾的.</p><p>正确的减肥的方式还是: 避开诱惑+实施意向+延后享乐. 慢慢让自己变瘦, 不要追求一下子成功.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>element-ui如何在文档中加载md文件</title>
      <link href="/2019/08/23/how-to-build-from-md-to-vue-comp/"/>
      <url>/2019/08/23/how-to-build-from-md-to-vue-comp/</url>
      
        <content type="html"><![CDATA[<p>上次看到element-ui的文档是一个vue项目, 注意到一个细节, 组件的文档是md文件, 并且能够展示组件的效果. 于是来仔细看一下其中的运行流程.</p><span id="more"></span><h2 id="如何把md文件加载到vue项目里"><a href="#如何把md文件加载到vue项目里" class="headerlink" title="如何把md文件加载到vue项目里"></a>如何把md文件加载到vue项目里</h2><h3 id="引入流程"><a href="#引入流程" class="headerlink" title="引入流程"></a>引入流程</h3><p>代码里是直接引入并调用<code>Vue.component</code>的, 类似于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docGuide <span class="keyword">from</span> <span class="string">&#x27;../README.md&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;docGuide&#x27;</span>, docGuide);</span><br></pre></td></tr></table></figure><p>显然<code>docGuide</code>应该是一个vue实例而不可以是md文件. 所以找到webpack配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.md$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">compilerOptions</span>: &#123;</span><br><span class="line">            <span class="attr">preserveWhitespace</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">loader</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./md-loader/index.js&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>原因是在webpack里配置了md的加载规则.</p><h3 id="webpack-loader介绍"><a href="#webpack-loader介绍" class="headerlink" title="webpack loader介绍"></a>webpack loader介绍</h3><p>从这个场景我们可以快速得出两个结论.</p><ul><li>loader是一个函数, 如果匹配到的项目进入了dep graph, 就会被作为参数传入loader函数, 并获取函数的输出内容作为打包结果.</li><li>如果一个匹配<code>use</code>了多个loader, 那么loader会从下至上执行, 并且把执行后的结果作为下次执行的输入.</li></ul><p>除此之外, loader还可以接受option来根据是否是生产环境&#x2F;项目业务来定制行为.</p><p>特别注意的是, loader是运行在node环境里的, 所以在这里可以调用任何node的方法, 甚至在这里直接把文件写到输出目录里.</p><p>在我们的场景中, 可以看出, md文件先进入了自己写的<code>md-loader</code>中, 然后应该再被<code>vue-loader</code>处理. 那么我们可以猜到: 这个loader接受md文件类似于<code># title</code>, 经过处理应该输出vue-loader可以处理的vue文件, 类似于: <code>&lt;template&gt;&lt;h1&gt;title&lt;/h1&gt;&lt;/template&gt;</code>. 接下来就看看<code>md-loader</code>的处理流程.</p><h2 id="md-loader"><a href="#md-loader" class="headerlink" title="md-loader"></a>md-loader</h2><p>按照道理说到这已经没有什么值得看下去的了, md的js库用一下就可以获得html, 外面再包一层template就是标准vue文件了. 其实vue里写个组件parse一下md文件就行了, 这里为什么要用loader? 因为有更厉害的功能.</p><p>这里的md支持一个语法: <code>:::demo $&#123;描述&#125; (组件例子)</code>就会自动展示组件效果, 并且可以看到当前效果的代码, 操作代码显示&#x2F;隐藏.</p><p>于是我们必须来看一下这个用起来很帅的loader了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> content = md.<span class="title function_">render</span>(source); <span class="comment">// 步骤1: 渲染md文件</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 步骤2: 对demo进行读取, 并生成必须的js. (demo中包含js)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;template&gt;</span></span><br><span class="line"><span class="string">      &lt;section class=&quot;content element-doc&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;output.join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/section&gt;</span></span><br><span class="line"><span class="string">    &lt;/template&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;pageScript&#125;</span></span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="brief"><a href="#brief" class="headerlink" title="brief"></a>brief</h3><p>我粗略把md处理分成2个步骤. 首先我们得知道这个loader的输入, 输出是什么, 并且sample是如何运行的.</p><p>举一个例子来查看输入输出: 正常的md都会被普通的parse成html, 假设我在md里输入了sample, 那么最后的输出会类似于:</p><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">demo-block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$&#123;描述&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;source&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">element-demo0</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span> <span class="attr">v-pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xf-input-range</span> <span class="attr">v-model</span>=<span class="string">&quot;inputRangeData&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          data () &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">inputRangeData</span>: [<span class="number">1</span>, <span class="number">2</span>]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">demo-block</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;component-doc&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="string">&quot;element-demo0&quot;</span>: (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">/** 处理输出 **/</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                render,</span><br><span class="line">                staticRenderFns,</span><br><span class="line">                ...democomponentExport</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在html中看到了<code>demo-block</code>, 我们就来看一下这个组件.</p><h3 id="demo-block"><a href="#demo-block" class="headerlink" title="demo-block"></a>demo-block</h3><p>这个组件是在文档入口被引入的, 我们编写的组件也是在入口被引入的, 所以文档的sample才能识别这些组件.</p><p><code>demo-block</code>就是展示sample效果和代码显示&#x2F;隐藏的组件.</p><p>其实从md-loader编译后的html文件(上文中)就能看出: demo-block中有3个slot, 一个是default, 一个source, 一个是highlight. </p><p>default是描述; source里的是一个奇怪的: <code>&lt;element-demo0&gt;</code>; highlight中是sample代码.</p><p>default和highlight都是普通的html, 值得继续看的是source的内容是一个临时组件.(从名字就可以看出来了)</p><p>于是看到script部分. <code>element-demo0</code>是在这里被定义的, 也就是loader把sample的行为写到这个临时组件里了.</p><p>看到这里, 已经完全了解了<code>md-loader</code>的输入输出了. 接下来仔细看看这个loader是如何把<code>:::demo</code>这个语法一步步编译成这样的输出的.</p><h3 id="md-render-source"><a href="#md-render-source" class="headerlink" title="md.render(source)"></a>md.render(source)</h3><p>作者用了<code>markdown-it-chain</code>这个工具解析了md, 我没有去文档看, 但从api上来看这个工具很棒, 支持自定义标签, 用2个字段, 一个<code>validate</code>类似于webpack loader的<code>test</code>, 一个<code>render</code>类似于<code>use</code>. 所以很容易理解.</p><p>用了这个工具, 就可以轻松读到<code>:::demo</code>中的内容, 并写成想要的html.</p><p>经过这个处理, html已经变为了:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">demo-block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$&#123;描述&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--element-demo: &lt;xf-input-range v-model=&quot;inputRangeData&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;script&gt;</span></span><br><span class="line"><span class="comment">      export default &#123;</span></span><br><span class="line"><span class="comment">        data () &#123;</span></span><br><span class="line"><span class="comment">          return &#123;</span></span><br><span class="line"><span class="comment">            inputRangeData: [1, 2]</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &lt;/script&gt;=</span></span><br><span class="line"><span class="comment">    :element-demo--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span> <span class="attr">v-pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xf-input-range</span> <span class="attr">v-model</span>=<span class="string">&quot;inputRangeData&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          data () &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">inputRangeData</span>: [<span class="number">1</span>, <span class="number">2</span>]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">demo-block</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仔细与最终结果对比:</p><p>被<code>&lt;!--element-demo:</code>包含的部分, 在最终输出里变成了: <code>&lt;template slot=&quot;source&quot;&gt;&lt;element-demo0 /&gt;&lt;/template&gt;</code>.</p><p>这样就很容易知道第二个步骤做了什么了.</p><h3 id="整理页面所有sample"><a href="#整理页面所有sample" class="headerlink" title="整理页面所有sample"></a>整理页面所有sample</h3><p>因为一个页面也许有很多sample. 那么就会有很多<code>&lt;!--element-demo:</code>. 现在把一个md文件加载成一个vue component, 就只能有一个script, 所以必须把所有demo合并成一个script. 就是最终步骤了.</p><p><a href="https://github.com/ElemeFE/element/blob/dev/build/md-loader/index.js">代码</a>就不贴在这里太长了, 我总结一下流程:</p><ol><li>遍历所有<code>&lt;!—element-demo:</code>, 并正则分析出他们的html和script部分.</li><li>用<code>&lt;element-demoX/&gt;</code>来替换位置.</li><li>把对应的html和script写成对应的临时component, 串在一起放到最终输出的script中.</li></ol><p>这3个步骤只有步骤3是需要仔细看的, 其他2个都非常好理解, 代码也很直白.</p><p><a href="https://github.com/ElemeFE/element/blob/dev/build/md-loader/util.js#L30">步骤3</a>的思路其实也很简单, 要把html和script的信息写入<code>&lt;element-demoX /&gt;</code>中. 使用<code>vue-template-compiler</code>把html编译成render方法, 再把script里所有内容原样放入就可以了. (其实vue本来就要把template转成render的)</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui项目结构概览</title>
      <link href="/2019/07/18/element-ui-structure/"/>
      <url>/2019/07/18/element-ui-structure/</url>
      
        <content type="html"><![CDATA[<p>vue的生态环境的ui组件从一开始就只有element可以用, 因为有团队维护, 也慢慢发展到别的ui组件没有竞争能力的地位了. 来看看element是如何组织代码的. 代码是写作的时候新拉的<code>2.10.1</code>.</p><style>  table {    table-layout: fixed;    width: calc(1030px * 0.75 - 40px);    word-break: break-word;  }</style><span id="more"></span><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>从<code>package.json</code>的<code>main</code>字段和webpack配置找到入口是<code>src/index.js</code>.</p><p>这个文件是从<code>build/bin/build-entry.js</code>根据配置生成而来的, 内容没有什么特别的, 大致是:</p><ul><li>引入每个组件.</li><li>install方法里注册组件, 一些快捷方式, i18n处理, (并vue-i18n的api对接), 接受一些业务相关的参数.</li><li>export单个组件和install方法.</li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建命令是<code>dist</code>(contributing guide中提到的), 所以我们来看一下<code>dist</code>命令做了些什么事.</p><table><thead><tr><th align="left">命令</th><th>操作</th><th>源</th><th>目标</th><th>描述</th></tr></thead><tbody><tr><td align="left">npm run clean</td><td>删除</td><td>lib等编译结</td><td></td><td></td></tr><tr><td align="left">npm run build:file</td><td></td><td></td><td></td><td>初步编译到各个语言的vue文件</td></tr><tr><td align="left">— node build&#x2F;bin&#x2F;iconInit.js</td><td>整理</td><td>packages&#x2F;theme-chalk&#x2F;src&#x2F;icon.scss</td><td>examples&#x2F;icon.json</td><td>整理有哪些icon</td></tr><tr><td align="left">— node build&#x2F;bin&#x2F;build-entry.js</td><td>生成</td><td>components.json</td><td>src&#x2F;index.js</td><td>make new 会修改components.json</td></tr><tr><td align="left">— node build&#x2F;bin&#x2F;i18n.js</td><td>编译</td><td>examples&#x2F;pages&#x2F;template&#x2F;${page}.tpl</td><td>examples&#x2F;pages&#x2F;${lang}&#x2F;​${page}.tpl</td><td>根据examples&#x2F;i18n&#x2F;page.json的配置来把tpl编译成vue(正则替换)</td></tr><tr><td align="left">— node build&#x2F;bin&#x2F;version.js</td><td>整理</td><td>package.json</td><td>examples&#x2F;versions.json</td><td>文档切版本用的version配置文件, 把当前版本兼容进去</td></tr><tr><td align="left">npm run lint</td><td></td><td></td><td></td><td>运行eslint</td></tr><tr><td align="left">webpack –config build&#x2F;webpack.conf.js</td><td>编译</td><td>src&#x2F;index.js</td><td>lib</td><td>umd</td></tr><tr><td align="left">webpack –config build&#x2F;webpack.common.js</td><td>编译</td><td>src&#x2F;index.js</td><td>lib</td><td>commonjs</td></tr><tr><td align="left">webpack –config build&#x2F;webpack.component.js</td><td>编译</td><td>配置在components.json中, 都是packages下的index.js</td><td>lib</td><td></td></tr><tr><td align="left">npm run build:utils</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">npm run build:umd</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">npm run build:theme</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>总结: 输出的内容就是<code>src/index.js</code>export出来的各个组件, 如果直接<code>use</code>, 就会加载所有组件. 复杂在还提供了主题&#x2F;i18n&#x2F;不同加载方式的处理, 这些之后再细看.</p><p>知道了输出了什么, 接下来要看的是如何进行开发.</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p><code>package.json</code>提供了两个命令, <code>dev</code>和<code>dev:play</code>.</p><p>先来看<code>dev</code>命令.</p><h3 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h3><ol><li><code>npm run build:file</code>: 对代码进行初步编译, 从tpl编译到vue文件, 对版本和i18n做处理.</li><li><code>webpack-dev-server --config build/webpack.demo.js</code>: 编译文档页面<code>examples/entry.js</code></li><li><code>node build/bin/template.js</code>: 对tpl的修改做监听实时编译成各个语言的vue文件.</li></ol><h3 id="example页面"><a href="#example页面" class="headerlink" title="example页面"></a>example页面</h3><p>先从webpack配置说起.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>: isProd ? &#123;</span><br><span class="line">    <span class="attr">docs</span>: <span class="string">&#x27;./examples/entry.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;element-ui&#x27;</span>: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">  &#125; : (isPlay ? <span class="string">&#x27;./examples/play.js&#x27;</span> : <span class="string">&#x27;./examples/entry.js&#x27;</span>),</span><br></pre></td></tr></table></figure><ul><li>dev命令入口<code>entry.js</code></li><li>dev:play命令入口<code>play.js</code></li><li>正式环境入口<code>entry.js</code>, 另外同时编译组件库源码.</li></ul><p><code>entry.js</code>是文档页面的入口, 文档页面是个独立的vue项目了. 唯一值得element自己写了一个loader把md编译成vue文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.md$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">compilerOptions</span>: &#123;</span><br><span class="line">            <span class="attr">preserveWhitespace</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">loader</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./md-loader/index.js&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>webpack的use是reverse执行的, 所以先把md文件编译成vue文件, 再由vue-loader处理.</p><h3 id="dev-play"><a href="#dev-play" class="headerlink" title="dev:play"></a>dev:play</h3><p>play使用了同一个webpack配置, 但入口是<code>play.js</code>, examples有个play文件夹, 下面只有个index.vue, 是用来开发单个组件时候调试的.</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li>自定义主题的实现</li><li>template和render的选择原则</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gladwell的写作技巧</title>
      <link href="/2019/05/21/gladwell-s-writing-skill/"/>
      <url>/2019/05/21/gladwell-s-writing-skill/</url>
      
        <content type="html"><![CDATA[<p>之前在软老板博客看到的写作技巧摘要, 觉得有意思.</p><p>不止是写作, 可以仔细理解, 提高自己的表达能力. </p><p>我是个表达能力特别弱的人, 之前看金字塔原理烂尾了, 这次简单总结下看到的内容.</p><span id="more"></span><p><a href="https://taimur.me/posts/notes-from-malcolm-gladwell-s-writing-masterclass-part-4/">原文</a>分为4个部分, 链接里是第四部分, 因为带着前面3篇文章的链接. (本文不是完全翻译)</p><h2 id="不要完成拼图"><a href="#不要完成拼图" class="headerlink" title="不要完成拼图"></a>不要完成拼图</h2><p>如果叙述让读者可以轻松推断出结局, 那么故事就不会有趣.</p><p><strong>最好的叙述是不完美的. 有一点不完整的故事会把你吸引进来. 人们会去讨论那些不按自己的猜想走的, 那些令人纠结的故事.</strong></p><h2 id="使用结构"><a href="#使用结构" class="headerlink" title="使用结构"></a>使用结构</h2><p>结构可以帮你清楚的表达. 可以参考金字塔原理.</p><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><p>复杂的思想比较难传达, 那就要给读者一些工具来帮助他们理解. 在开始叙述故事以后, 你可以暂停一下并引入一个思维模型, 再继续说故事.</p><p>读者会本能地把新的思维模型应用到后面的故事中, 这么做读者不仅能更好理解故事, 还能更有参与感.</p><h2 id="使用数据"><a href="#使用数据" class="headerlink" title="使用数据"></a>使用数据</h2><p>人们真的很喜欢看数据. 我们大家第一次接触数据是在学校, 我们每个人都想知道别人的考试成绩.</p><h2 id="给读者发糖"><a href="#给读者发糖" class="headerlink" title="给读者发糖"></a>给读者发糖</h2><p>思考一件事和阐述一件事是不同的.</p><p>我们思考的方式是复杂的, 不连贯的, 甚至有时是矛盾的. 去阐述我们的思考是非常难的事.</p><p>所以最后我们说出口的话都变成<strong>我们有能力表达出来的话</strong>: (而不完全是思想的内容)</p><ul><li>我们记得的事情</li><li>我们可以表达出来的事情</li><li>我们可以在短时间内说完的事</li></ul><p><strong>读者会思考的事情和他们会说出来的事情也是不同的. 所以写作者的任务是同时给与读者他们会想的和会说的.</strong></p><p>在一个故事里, “糖”是指人们可以讨论的东西, 而”主食”是指读者可以思考得更深的东西. 一篇好的文章二者缺一不可.</p><p>“糖”让读者把一些片段告诉他们的朋友来让你获得新的读者, 而”主食”会把新的读者留住.</p><h2 id="设置惊喜"><a href="#设置惊喜" class="headerlink" title="设置惊喜"></a>设置惊喜</h2><p>我们告诉别人故事是为了获得”给他人惊喜”的回报.(看对方知道新东西的反应). 有一些人被告知了新信息以后都会表示不惊喜, 并说”哦, 我早知道了”. 不要成为这种人.</p><p>当一个人告诉你一件事时, 他在冒一个险: 你对这件事不感兴趣. 如果你表现得不屑, 那他最后会不再告诉你别的事, 如果你表现得热情, 他还会告诉你更多. 作为一个作者, 你的任务是: <strong>创造一个读者会感到惊喜的故事</strong>.</p><p>而惊喜的设置方式就是: 告诉别人他还不知道的事. 就算意见事他已经知道了75%, 你也可以发掘2%他不知道的事, 并从这2%的新的角度描述事情.</p><h2 id="邀请读者进入"><a href="#邀请读者进入" class="headerlink" title="邀请读者进入"></a>邀请读者进入</h2><p>通过告诉读者他们是故事的一部分来激发读者的反应.</p><p>可以在故事出现悬疑的时候提示读者, “你是怎么想的?”, “如果你是他, 你会怎么做?”</p><p>或是让读者在某些时候做出解答, 让读者选a或b或c.</p><h2 id="有目的性地保留一些信息"><a href="#有目的性地保留一些信息" class="headerlink" title="有目的性地保留一些信息"></a>有目的性地保留一些信息</h2><p>写作有一个核心是要创造一些能让读者持续关注的东西, 所以你可以通过策略性地保留一些信息来保持读者的持续关注. <strong>当读者觉得需要知道一些信息的时候, 他们会继续阅读直到获得这些信息.</strong></p><p><strong>最好的叙事者, 会通过掌控惊喜和悬疑来吸引读者.</strong></p><h2 id="不要上网"><a href="#不要上网" class="headerlink" title="不要上网"></a>不要上网</h2><p>有趣的东西会在你没有寻找他的时候发生. 百度会告诉你你正在寻找的东西, 并且告诉你别人已经遇到过, 解决过的问题. 更糟糕的是, 搜索结果还会根据热度排名. 你在想写一些新鲜的东西时候绝不会想得到这些信息.</p><p>图书馆则不同, 每本书都被同类的书包围着, 书下都有注释, 让你追溯作者的步伐. 你能在图书馆获得很多百度不到的东西.</p><p>推广到我们的认知, **不同获取知识的途径的人, 会拥有不同的知识结构. **而大多数人的获取知识的结构是相同的, 既被动的, 被别人操作的. 如广告(别人想让你知道), 头条&#x2F;抖音&#x2F;知乎&#x2F;百度(推荐系统), 或无脑地把听到的东西作为自己的知识并传播出去, 形成谣言链条.</p><p>推荐系统推荐的内容是: 你想看的(你曾经看过的), 所以<strong>只是被动地, 舒服地获取信息, 会让一个人思想停滞.</strong></p><h2 id="跟随自己的好奇心"><a href="#跟随自己的好奇心" class="headerlink" title="跟随自己的好奇心"></a>跟随自己的好奇心</h2><p>我们不能知道什么东西将会变成有用的东西, 所以只需要顺着自己的好奇心.</p><p>原文中说了个故事, Malcolm知道了有个村庄的人都不会死, 即使人们都吸烟和肥胖. 虽然已经有团队对村庄进行了医学调研并写了一本书, Malcolm还是保留了他对村庄调查的笔记和录音. 15年后Malcolm写的关于这个村庄的书出版重新把这个村庄带到人们眼前.</p><p>所以当不知道应该做什么好的时候, 可以用自己的好奇心引路.</p><h2 id="把想法讲给别人听"><a href="#把想法讲给别人听" class="headerlink" title="把想法讲给别人听"></a>把想法讲给别人听</h2><p>因为写好的文章读者看了以后的反馈我们是无从知道的, 而把故事想讲给朋友听, 可以从朋友是否眼神呆滞, 是否提出问题等状态来获取反馈.</p><p>自己觉得有趣的点和别人觉得有趣的点是不同的, 而可以用这个方法来知道交集, 把更好的东西放到文章里.</p><h2 id="发散你的想法"><a href="#发散你的想法" class="headerlink" title="发散你的想法"></a>发散你的想法</h2><p>每个人的脑子里都放着一些零散的东西, 访问到这些东西是产生想法的好办法. 当你告诉别人一个想法, 别人说”哦, 这令我想起…”这个想起的东西就是你需要的.</p><p>一个良好的对话形式是:</p><p>我先告诉你一个我脑子里的东西, 你回复一个你脑子里相关的东西, 我再回复与你说的相关的东西. 如此往复, 我们就建立了一个对话流. 如果双方都是健谈的话, 会慢慢出现有趣的东西.</p><p>但如果这些没有自然发生, 你可以尝试问对方(或自己): “这有没有让你想到些什么事?”</p><h2 id="离开你自己的岛"><a href="#离开你自己的岛" class="headerlink" title="离开你自己的岛"></a>离开你自己的岛</h2><p>一个事件的发生可以从不同领域解释. 所以如果你想有多个角度解释事件, 你就需要拥有多个领域的知识.</p><p>这就是所谓”当你有一把锤子, 看任何东西都是钉子”. 最简单的例子是一个读书人手上的武器只有知识, 然而去了知识不能解决问题的地方被人一锤子锤烂了.</p><p>离开自己的岛是指: 进入和了解不同领域, 让自己手上不止有锤子, 还有螺丝刀, 套筒, 内六角… 这样看到螺丝的时候不会用锤子去敲.</p><p>原文的故事是说圣经里身体弱小的大卫杀了身体强壮的哥斯拉. (这个故事以前我也哪听到过.) 作者用内分泌学解释了哥斯拉身体大导致眼睛不好才输了战斗, 从另外的角度解释了以弱胜强的原因.</p><h2 id="让思路慢下来"><a href="#让思路慢下来" class="headerlink" title="让思路慢下来"></a>让思路慢下来</h2><p>在思路进行过程中都会遇到问题, 不要试图把问题敷衍过去.</p><p>而且自己思路不顺的时候, 对方也会不顺.</p><p>所以可以在不顺的时候等待一下, 承认我还没理解, 也可以在觉得妙的时候说妙啊!</p><p><strong>等待是一个很有用的策略, 慢下来可以解决很多问题, 等待一下可以给自己时间思考, 有助于更深理解问题以及拓展思维.</strong></p><h2 id="告诉读者为什么有趣"><a href="#告诉读者为什么有趣" class="headerlink" title="告诉读者为什么有趣"></a>告诉读者为什么有趣</h2><p>读者不是每次都会理解你说的东西为什么有趣的. <strong>有些你感觉很有深意很有趣的东西, 别人并没有感受到.</strong></p><p>一个作者的工作是<strong>耐心去思考读者如何能感受你的感受, 而不是只从自己的角度输出观点.</strong></p><h2 id="要使用谦虚的策略"><a href="#要使用谦虚的策略" class="headerlink" title="要使用谦虚的策略"></a>要使用谦虚的策略</h2><p><strong>谦虚可以使你更简单地探索世界.</strong> 谦虚的态度使谈话变得更好. 在谈话中尝试插入自己的观点到正在进行的谈话中, 话题就会偏移; 但如果认真听对方的话并感到有趣, 会比只在自己的世界里感到更有趣.</p><p>有些人可能认为自己说话比较对, 所以不愿意听别人说话, 别人说任何话都把话题转移到自己想说的事上来. 这样的形式根本不算对话, 并且双方能获得的新思想都很少, 对话效率很低.</p><h2 id="把复杂的东西写得简单"><a href="#把复杂的东西写得简单" class="headerlink" title="把复杂的东西写得简单"></a>把复杂的东西写得简单</h2><p>写作必须简单得让任何读者都看得懂.</p><p>如果读者首先被复杂冗长的句子打倒了, 那文章就没有意义了. 读者可以看不懂文章, 但一定要是因为内容深刻而看不懂, 而不是句子.</p><p>简单的句子还有另外一个好处, 就是在短句基础上, 有少数的复杂的, 长的句子, 会很明显, 这样读者能更仔细深刻地去理解长的句子了.</p><h2 id="标题是你的广告"><a href="#标题是你的广告" class="headerlink" title="标题是你的广告"></a>标题是你的广告</h2><p>标题是一种被限制了时间的与读者交流的方式. 一定要花时间思考标题.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何探测小程序返回到webview页面</title>
      <link href="/2019/05/13/miniprogram-back-to-webview-detection/"/>
      <url>/2019/05/13/miniprogram-back-to-webview-detection/</url>
      
        <content type="html"><![CDATA[<p>在公司项目中经常会遇到一个场景, 尝试过各种不同的方法, 最后想到了一种很技术上简单且可行的方法.</p><span id="more"></span><h2 id="经常被QA同学反应同一类型的问题"><a href="#经常被QA同学反应同一类型的问题" class="headerlink" title="经常被QA同学反应同一类型的问题"></a>经常被QA同学反应同一类型的问题</h2><p>项目是小程序(wepy), 部分页面使用webview(vue). 经常会遇见一个场景: 当小程序navigateTo到一些页面对用户的”收藏状态”, “身材细节”做了修改后, 用户点击返回按钮回到上一个页面, <strong>收藏的状态或是身材细节没有改变</strong>.</p><p>那是当然的, 作为一个小程序中的webview, api相当有限, 没有一个事件可以让网页触发重新渲染动作, 轮询更是不理智的表面功夫.</p><p>我们试过绑定blur和click事件来模拟事件, 试过从业务逻辑上加入一些时间点检查状态, 最后才想到个技术简单, 操作简单的解决方案.</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>第一步, 在小程序webview绑定的url上加上时间戳.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-view</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;url&#125;&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onShow () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">url</span> = $&#123;base_url&#125;?ts=<span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步, 在html里监听query变化. 我遇到问题的项目使用的是vue.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;$route.query.ts&#x27;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">fetchData</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">patchRender</span>() <span class="comment">// 获取数据, 重新渲染变化的部分</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就解决了触发退回到webview的事件探测问题, 剩下的只要根据业务来重新渲染可能变化的部分就行了.</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>小程序的部分每次都需要改变url的query参数没有办法, 但是对vue设计这么良好的框架还有一定改良空间.</p><p>我们可以把这串代码写到mixin里, 对性能有些小影响, 但方法没写也不会去执行, 只是在不需要的页面上多了个observer.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;$route.query.ts&#x27;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">onShow</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">onShow</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么在vue页面中就省去了写watch的麻烦, 直接像小程序那样写onShow方法就行了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onShow () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">fetchData</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">patchRender</span>() </span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  fetchData () &#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结, 使用了这个方法如需再添加需要探测onShow事件的页面, 只需要:</p><ol><li>小程序webview的url在onShow的时候修改ts参数</li><li>在vue文件里添加onShow方法, 进行业务操作. (方法里的this是正常指向vm的)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用transform画一个圆</title>
      <link href="/2019/03/26/draw-a-circle-with-css-transform/"/>
      <url>/2019/03/26/draw-a-circle-with-css-transform/</url>
      
        <content type="html"><![CDATA[<p>看到soul上的球, 尝试用css画一个球, 本想应用到博客标签栏, 还是感觉不合适, 这篇文章来讲一下用css transform画这个球对这个css的理解.</p><span id="more"></span><div class="stage"></div><style>.stage {width: 200px;height: 200px;        margin: 0 0 50px 25px;transform-style: preserve-3d;animation: rotate 10s infinite linear;}.spot {width: 38px;height: 38px;top: 81px;left: 81px;background: #03A9F4;box-shadow: 0 0 5px #000000;border-radius: 50%;position: absolute;}@keyframes rotate {0% {transform: rotate3d(1, 1, 1, 0deg);}100% {transform: rotate3d(1, 1, 1, 360deg);}}</style><script>let stage = document.getElementsByClassName('stage')[0]function addSpot (angleLO, angleLA) {let spot = document.createElement('div')spot.className = 'spot'spot.style.transform = `rotate3d(${Math.cos(angleLO)}, ${Math.sin(angleLO)}, 0, ${angleLA}deg) translateZ(100px)`stage.appendChild(spot)}let longitudeNum = 10let latitudeNum = 6let radius = 100for (let i = 0; i < latitudeNum; i++) {for (let j = 0; j < longitudeNum; j++) {addSpot(i / latitudeNum * 360 * Math.PI / 180, j / longitudeNum * 360)}}</script><div class="square">    <div class="top">1</div><div class="bottom">2</div><div class="left">3</div><div class="right">4</div><div class="front">5</div><div class="back">6</div></div><style>.square {width: 100px;height: 100px;margin: 100px;transform-style: preserve-3d;animation: rotate 4s infinite linear;    top: 0;    right: 0;    position: absolute;}.square > div {width: 100px;height: 100px;position: absolute;font-size: 40px;line-height: 100px;text-align: center;color: #fff;opacity: 0.5;}.top {transform: rotateX(90deg) translateZ(50px);background-color: #ABFF96;}.bottom {transform: rotateX(-90deg) translateZ(50px);background-color: #F99F6D;}.left {transform: rotateY(90deg) translateZ(50px);background-color: #F859A3;}.right {transform: rotateY(-90deg) translateZ(50px);background-color: #B869FB;}.front {transform: translateZ(50px);background-color: #3F92FB;}.back {transform: translateZ(-50px);background-color: #C2FF43;}@keyframes rotate {0% {transform: rotate3d(0, 1, 1, 0deg);}50% {transform: rotate3d(1, 0, 1, 180deg);}100% {transform: rotate3d(1, 0, 1, 360deg);}}</style><h2 id="例子中的图像"><a href="#例子中的图像" class="headerlink" title="例子中的图像"></a>例子中的图像</h2><p>通过抄了一个正方体的例子, 模仿了一个球, 因为球的点比较多, 所以不得已使用了js. 通过正方体思考了球表面的点的通解, 代码直接审查元素即可, <strong>可以通过修改参数和css来调整球的点的个数和大小.但点的个数提高会对性能造成影响</strong> <em>(远古浏览器看不到例子)</em></p><p>另外, <a href="https://webpack.github.io/">webpack</a>的logo也是一个理解transform的很好的例子, 有兴趣也可以抄一下试试.</p><h2 id="transform的实现"><a href="#transform的实现" class="headerlink" title="transform的实现"></a>transform的实现</h2><p>主要用到的css属性是<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms">transform</a>的3d部分, 并没有用到文档所有. transform有2d, 3d之分. 这里要提到几个相关属性: </p><ul><li>transform-style, 通过设置父元素的transform-style为<code>preserve-3d</code>来使容器内的空间变为3d.</li><li>transform-origin, 设置transform的轴, 对旋转, 缩放, 拉伸有影响.</li></ul><p>无论是2d还是3d, 实现原理都是计算坐标, 3d只是把第三维的坐标通过三角比映射到2d坐标上. <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function">文档</a>中详细说明了计算方法: <strong>把原始坐标看做一个向量, 把transform的参数(变化方法)作为二维或三维向量, 把两个向量相乘, 获得结果坐标.</strong></p><p>transform有很多参数, 如rotate, translate, scale, skew. 其实都只是几个线性变换的快捷方式, 也就是通过自己计算也可以实现. 例如<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate">rotate</a>在二维变换中就是把[cos(a), -sin(a), sin(a), cos(a)]的2*2矩阵与初始坐标相乘.</p><p>为什么要知道一点transform是如何计算的? 因为光试属性会发现一些莫名其妙的现象, 光去猜测需要花更多的时间来掌控这些transform-function. 接下来很简单地介绍下transform-function和基本用法.</p><h2 id="transform-function"><a href="#transform-function" class="headerlink" title="transform-function"></a>transform-function</h2><p>所有的function在上面发过的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function">文档</a>中都有, 这里简单的说一下transform都能做些什么变换. 注意, 所有变化都是可2d, 可3d的.</p><ul><li>rotate系列, 作用是旋转, 默认轴是左上, 通过设置transform-origin改变.</li><li>translate系列, 作用是移动, 这个移动在画立体图形上非常有用, 并且需要仔细理解, 因为可以在第三维上移动, 并和其他transform-function有组合效果.</li><li>scale和skew系列, scale是保持比例的缩放, skew不保持比例, 在3d上用的时候可以改变模型的形状.</li><li>perspective, 调整视角.</li><li>matrix和matrix3d. 自定义线性变换. 当然可以操作任何其他的, 例如<code> matrix(cos(5), -sin(5), sin(5), cos(5), 0, 0)</code>就等价于<code>rotate(5)</code>. 看来对线性代数理解深的可以创造更有意思的线性变换吧.</li></ul><p>这些变换都是可以叠加使用的, 同系列的也可以, 像: <code>transform: rotate(5deg) rotateX(10deg) rotateY(20deg)</code>都是可以的.</p><p>知道了这些知识就可以开始画方画圆啦.</p><h2 id="如何把脑子里的图形画出来"><a href="#如何把脑子里的图形画出来" class="headerlink" title="如何把脑子里的图形画出来"></a>如何把脑子里的图形画出来</h2><p>之前使用transform都是比较简单的图形, 所以其实写错了, 但效果差距不多, 记得我之前自己画过一个方块, 但六个面并不能无缝连接起来, 当时没细想也就过去了. (甚至没有想过是自己的问题, 还觉得css只能实现成这样). 现在仔细思考, 自己画了一个球, 在过程中发现了几个比较重要的注意点, 并总结了画图形的思路.</p><p>先来说总体思路.</p><ol><li>在脑子里呈现你想画的图形.</li><li>思考图形可以由哪些面组成.( 比如圆形就很多小面积的面.) 因为web里只有div, 也就是一个个面.</li><li>思考可以有所有面通解公式的原点在哪里.</li><li>创建所有面.</li><li>把所有的面absolute定位到原点, 并设置通用css.</li><li>思考公式, 把公式运用到每个面上.</li></ol><p>至于公式的写法, 可以用这样的思路:</p><p>首先要明确: 你在操作向量. 如果按照之前的操作, 所有的面已经定位到原点了. 只要思考, 如何从原点<em>运动到</em>他应该在的地方就行了.</p><p>最后说一下注意的点, 也是之前画错图形的原因!</p><ul><li>因为矩阵乘法不满足交换律, 所以transform-function的顺序要注意. 从物理意义上思考, 一个向量先转向再直行, 和先直行再转向, 最后当然会到不同的地方了.</li><li>坐标是一个向量, 而不是一个点, 一定要确定原点和坐标系方向再进行变换. 不然会变到莫名其妙的地方.</li></ul><p>最后, 上面例子中把画好的图形加了各角度旋转的动画是为了证明图形没有画错.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借鉴vue文档改版博客</title>
      <link href="/2019/02/22/learn-from-vuejs-org/"/>
      <url>/2019/02/22/learn-from-vuejs-org/</url>
      
        <content type="html"><![CDATA[<p>vue的文档是hexo写的, 我的博客也是hexo写的, 虽然性质不同但为什么别人的好看这么多呢.</p><p>我自己修改主题也比较多次了, 看看文档代码学了点细节, 算作一次博客小改版.</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>从layout开始看vue的文档, 发现也没什么特别的, 但很多细节特别巧妙, 用普通的技术达成高端的效果, 尤老不愧是设计出身的. 本文的标题会一个个分散地列出这次博客改版的内容.</p><h2 id="基本样式"><a href="#基本样式" class="headerlink" title="基本样式"></a>基本样式</h2><p>vue的主题色是两个, 主色绿, 副色橙. 这两个颜色在色盘上应该是接近180度的. 分别用在小代码块和链接上. 于是我尝试根据类似思路修改了<code>小代码块</code>和<a href="https://vuejs.org/">链接</a>的css.</p><p>另外我的主题的<em>斜体</em>和<strong>粗体</strong>区别不大, 普通的字也太淡了, 一并修改了.</p><h2 id="引用块和代码块"><a href="#引用块和代码块" class="headerlink" title="引用块和代码块"></a>引用块和代码块</h2><p>vue的引用快和代码块均使用了hexo的tag plugin, 而我用了原生的markdown.</p><p>我的主题的引用块特别难看, 一开始我以为是plugin和markdown的区别, 后发现plugin也是渲染成markdown的. 只是我css的问题. 代码块也改一下颜色了, 再修改一下引用块的css.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">bar</span>: foo,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><blockquote><p>现在引用块的css比较能看了.</p></blockquote><h2 id="rawhtml"><a href="#rawhtml" class="headerlink" title="rawhtml"></a>rawhtml</h2><p>vue文档中感到比较神奇的是一些”提示”之类的块, 感觉不是markdown. 从主题代码中看不出原因, 结果在hexo文档中找到了解释. 使用<code>&#123; % raw %&#125;</code>和<code>&#123; % endraw %&#125;</code>就可以打出生html.</p><p>因为这个功能, 我放弃了使用了2年的typora.(卸载纪念) 还是分割型的md工具好用.</p><p>于是有两个好处, 一是可以在解释代码的时候直接贴一些效果, 比如:</p><input id="rawhtmltest" placeholder="在文章中写小例子是ok的"/><button>但复杂的还是需要jsfiddle</button><style>    #rawhtmltest {background: pink; width: 300px;}</style></style><p>还有个拓展, vue文档中还有些很帅的标签, 只需要加上类就可以使用效果, 我直接抄过来, 改了下颜色, 以作别的用处. (因为博客和文档性质不同)</p><div class="summary"><p>这是一段章节总结. 这对于写博客比较有用, 采用的是vue的tips样式.</p></div>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相对论科普</title>
      <link href="/2019/02/07/the-theory-of-relativety/"/>
      <url>/2019/02/07/the-theory-of-relativety/</url>
      
        <content type="html"><![CDATA[<p>记得小学四年级我就买了新出的时间简史, 初高中又爱好物理, 虽然完全不懂但对相对论一直感兴趣.</p><p>近期读了一部分科普书<code>宇宙的琴弦</code>, 对相对论科普进行一些整理.</p><span id="more"></span><h2 id="探索的过程"><a href="#探索的过程" class="headerlink" title="探索的过程"></a>探索的过程</h2><p>每个细分科目的开始于过程其实都遵循着一些历史规律:</p><p> 根据以往理论 &#x3D;&gt; 发现实验结果与以往理论不符 &#x3D;&gt; 大胆猜测 + 实验 &#x3D;&gt; 猜出新的理论. 如此的.</p><p>在经济中, “首先是行动”. 科学也是如此, 人的逻辑其实很差, 所以要以公理加数学推导来证明. 可以说数学能表现人类的伟大, 数学是理性战胜感性的产物. 有个玩笑是, 学生时代看到证明题的反应有两种, 第一, 这还需要证明吗, 第二, 这东西怎么可能证明. 后才发现数学是多伟大的东西.</p><p>发现的问题基本是从某个角度, 发现了问题后还需去找寻新的角度来看待事物, 就像世界真理是复杂的, 我们只能通过真理在某些事件上的投射来猜测真理的真面目. 所以”找角度”是科学家的大部分工作, <code>科研人员的顶级能力其实是想象</code>, 这个结论倒也是非常的有趣.</p><p>本文会跟着科普书一起走一遍, 从 “问题的发现” 到 “多个投射角度看待问题” 到 “理论的定义” 到 “理论的应用和证实” , 没有证明没有计算地了解一下概念, 了解一下历史.</p><h2 id="狭义相对论"><a href="#狭义相对论" class="headerlink" title="狭义相对论"></a>狭义相对论</h2><p>因为我小时候看时间简史的关系, 我理解的相对论其实一直是狭义相对论, 所谓的黑洞, 时间旅行这些东西都是基于狭义相对论的.</p><h3 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h3><p>简单问题: </p><blockquote><p>火车由左向右5m&#x2F;s运动, 火车里的人由左向右扔球, 5m&#x2F;s. 问: 地面上的人观察到球的速度是多少</p></blockquote><p>答案是10m&#x2F;s, 因为地面的人看火车在动, 球的速度是相对火车的, 所以地面的人看起来, 球的速度是由左向右10m&#x2F;s.</p><p>然后实验发现, 如果把球换成光, 结果就不同了.</p><blockquote><p>设光速为c.</p><p>火车由左向右0.5c运动, 火车里的人由左向右打开手电筒, 问: 地面的人看到手电筒照射的光的速度是多少</p></blockquote><p>按照牛顿力学的思路应该是1.5c, 可地面测量的光速还是c.</p><p>这个可怕的实验结果推翻了人类对世界的认识: <strong>光速是不变的</strong>.</p><p>光速不变是狭相的一个定理, 另外一个是相对性原理, 之后再解释.</p><h3 id="概念的重建"><a href="#概念的重建" class="headerlink" title="概念的重建"></a>概念的重建</h3><p>为什么相对论发现了几百年, 人们对物理的理解还是牛顿的经典力学, 因为我们活在牛顿的低速世界, 对真实世界的”直觉”是不存在的. </p><p>所以发现了光速不变之后, 一下子会产生大量反直觉的问题, 只能通过数学公式来引导直觉, 引导想象来仔细感受这个世界的概念.</p><p>使用一个基本公式: 速度 &#x3D; 距离 &#x2F; 时间 ( v &#x3D; s &#x2F; t )</p><p>什么是距离? <strong>距离是空间的概念, 描述物体的位置之间的关系</strong></p><p>什么是时间? <strong>时间是时间的概念, 描述事件发生的前后关系</strong></p><p>速度是距离和时间的比值, 所以速度是用来表现<strong>空间和时间关系</strong>的量.</p><p>之前, 我们一直认为: v 是由 s 和 t 决定的, 而现在实验证明了, <strong>光速才是绝对的, 所以时间和空间是物体运动相对光速的速度而变化的</strong>.</p><p>这里有一个光子钟的设想:</p><blockquote><p>有一个光子钟, 由2个上下相对的镜子组成. 一个光子在镜子中来回反射.</p><p>现在把这个光子钟放到由左向右运动的火车.</p></blockquote><p>由<code>光速在任何参考系下测量速度相同</code>的结论, 试比较火车上的观察者和地面观察者的结论.</p><blockquote><p>对于火车上的观察者: 光子的运动是直上直下, 速度是光速</p><p>对于地面的观察者: 光子的运动还有火车的横向速度, 所以运动路线比火车上的观察者长, 速度也是光速</p></blockquote><p>根据s &#x3D; v * t, 速度相同, 地面的观察者观察到的距离更大, 所以地面观察到火车的光子钟在做慢动作, 而火车上的观察者观察到的是正常的时间.</p><p>这是一个狭相的推论: 运动越快的物体时间越慢.</p><h3 id="相对性原理"><a href="#相对性原理" class="headerlink" title="相对性原理"></a>相对性原理</h3><p>光速不变原理再加上相对性原理就更能打击人的世界观了, 说了定以后我会举几个例子, 仔细感受相对性原理的神奇. 相对性原理内容是: 运动是绝对的, 静止是相对的. 并且在所有惯性参考系下所有物理过程相同.</p><p>试想一下场景:</p><blockquote><p>a身处一片黑暗之中, 只能看见自己的身体. 发生了一个事件: a看见b慢慢向自己靠近, a与b打了招呼, b又慢慢远离了自己.</p></blockquote><p>a认为b在运动过程中经过了自己, 但我们以宇航员b的角度思考, 会发现b的描述和a的完全一致. a和b没有一个人可以确定是谁在运动, 而谁是静止的.</p><p>相对性原理就会引发一些悖论, 下面说两个.</p><ol><li>同时出生的兄弟的哥哥坐上了速度很快的飞机进行了旅行, 当回到地面的时候哥哥说我在高速运动, 我比你年轻. 弟弟说, 我相对你也在高速运动, 你回来的时候我比你年轻.</li><li>两个一样长度的火车和隧道, 火车高速通过隧道, 高速物体运动方向长度变短, 隧道认为火车变短了, 所以有一段时间火车会完全消失在隧道里. 但隧道相对于火车也在高速运动, 那么火车认为隧道变短了, 所以有一段时间火车的头尾都在隧道外面.</li></ol><p>这两个悖论都是因为相对性原理, 我来简单解释一下.</p><ol><li><p>“观测”本身就需要时间, 哥哥在高速离开弟弟的时候, 兄弟两人确实都认为”对方变得比自己年轻”了. 因为运动速度很快, 而信息是通过光速传播的, 所以”双方都认为对方更年轻”是由信息传播时候导致的时间差.</p><p>那么哥哥回到地球的时候确实比弟弟年轻的原因是哥哥在回来的时候经历了加速度. 加速度才是导致时间扭曲的原因, 这点会在之后的广义相对论解释.</p></li><li><p>火车与隧道做了一个实验: 隧道前后的门会在火车完全在隧道中的时候同时关闭, 而火车会在头尾都露在隧道外面的时候头尾同时向上发射一颗火箭.</p><p>结果是: 双方时间都成功了, 但都认为对方”作弊”了. 隧道认为: 火车发射火箭不是同时的, 火车认为: 隧道关闭阀门不是同时的.</p></li></ol><p>关于例子2, 书中还有一个小故事: </p><p>在签订停战协议的时候, 双方国家都不愿意先签字, 于是流行一种”灯光协议”, 双方坐在离一盏灯一样距离的地方, 打开灯, 当看到灯光的时候, 双方就同时签字. 有一次灯光协议发生在火车里, 地面上的民众看到签字以后打起来了, 因为认为灯光先到达了一方, 而那一方总统也确实先签字了.</p><p>但火车中的观察者仍觉得双方是同时签字的. 这就是<code>同时</code>是相对的, 因为时间是相对的.</p><h3 id="时空是交叉的"><a href="#时空是交叉的" class="headerlink" title="时空是交叉的"></a>时空是交叉的</h3><p>小时候我特别讨厌”四维世界”的一维是”时间”的概念, 我认为他们根本不懂四维, 我心里的四维是空间上的拓扑四维, 而现在确理解到也许第四维是时间. 因为时间和空间是垂直的, 时间也是空间的一种, 因为之前一直认为”时间是尺”, 而现在知道了”光速是尺”的事实.</p><p>下面说一个故事.</p><blockquote><p>一部车的速度是100km&#x2F;h, 有一条直线是100km, 那么这部车用了一小时完成了这条路线.</p><p>有一次这部车行进使用了超过一小时的时间. 最后发现是路线歪了.</p><p>于是驾驶员尽力注意保持路线是直的, 但跑着跑着又超过了一小时. 这次原因是地面的土变少, 路线的高低不是平的了.</p></blockquote><p>这个故事告诉我们, 速度不变的情况下, 只要速度给了一部分<code>分速度</code>到非目标方向上, 那么目标方向的速度就变慢了, 完成目标方向的时间也就边长了.</p><p>这个方向可以是左右, 可以是上下, 也可以是<code>时间</code>.</p><p>所以, 运动速度本身就是跑在时间里的, 因为<code>速度是描述距离与时间的关系的量</code>. 在时间上的分速度越快, 那么在空间上的分速度就越慢了.</p><p>试想一个问题. 一个旅行者以0.5倍光速旅行去一光年的地方旅行回来, 需要多久?</p><p>答案是大于2年的, 旅行者本身感受到的时间是2年, 但地面观察者感受的时间更久, 换句话说, 0.5倍光速的旅行不止在距离上旅行, 也在时间上旅行到了地面的未来. 如果速度越快, 旅行到的未来也就越快.</p><p>另外有个推论, 光是不会老的, 因为光的速度全在时间里而不在空间里, 所以我们看见的光就是宇宙大爆炸时候产生的光.</p><h3 id="狭相总结"><a href="#狭相总结" class="headerlink" title="狭相总结"></a>狭相总结</h3><p>这次的思考狭相我改变了之前对狭相的看法.</p><p>之前我一直把相对论想成”科幻”, 通过相对论就能进行时间旅行之类的想法. 而现在认识到的是, **狭相的根本发现是光速不变, 从而得出时间和空间是相对的, **从而得出后面的那些推论:</p><ul><li>所谓时间变慢是指相对其他参考系, 本征时间不会变慢, 所以长生不老是不存在的, 存在的只是时间旅行.</li><li>时间旅行的本质是发生在加速度的时候, 相对运动的时候的时间只能说是”观察结果”, 而不能放在一起比较(比较谁年轻, 谁长谁短). 甚至相对运动的物体只是碰到一次而之后再也碰不到了.</li><li>相对运动的惯性系互相观察得到时空的变化都是因为”观察的速度是光速”, 本质是光速不变原理导致是观察结果相对.</li><li>所以, 不同惯性系的人其实生活在不同的世界里, 只是他们在达到同一个惯性系的时候进行了相互比较.</li><li>狭相在生活中是一直存在的, 如果两个人相距5米, 一个人向另一个人走去, 那么走到一起的时候移动过的人是走到了不动的人的未来的. 只不过差别很小, 如果速度是1m&#x2F;s, 走了5s, 那么差别是<code>5s * 3e-16</code>秒.</li></ul><h2 id="广义相对论"><a href="#广义相对论" class="headerlink" title="广义相对论"></a>广义相对论</h2><h3 id="问题的发现-1"><a href="#问题的发现-1" class="headerlink" title="问题的发现"></a>问题的发现</h3><p>狭相修正了牛顿的经典力学, 虽说推翻, 但还是能把牛顿力学重新定义起来, 但在某个上产生了矛盾. 牛顿认为万有引力只与两个物体的质量与距离相关, 狭相的基本原理是光速不变, 没有东西可以超过光速.</p><p>试想一个问题: 如果太阳突然消失了, 因为引力与质量相关, 地球与太阳引力发生变化, 地球会立即逃离太阳系. 但地球要得知太阳消失的信息需要8分多钟, 如果太阳一消失地球马上发生逃逸, 那么这个信息的速度就比光速还快, 与狭相的基本原理背道而驰了.</p><p>于是爱因斯坦发现这个坑比想象得深, 自己挖的跪着也要填完, 于是提出了广义相对论. 下面的演绎要从等效原理说起.</p><h3 id="等效原理"><a href="#等效原理" class="headerlink" title="等效原理"></a>等效原理</h3><p>说一个故事</p><blockquote><p>在一个做自由落体运动的电梯箱中, 箱中的物体处于失重状态, 平抛一颗小球, 小球不会向下运动, 而是保持水平运动直到碰到箱壁. <strong>那么在电梯中的人就无法得知自己是在自由落体的电梯中, 还是在无引力的太空中</strong>.</p></blockquote><p>同样地, 如果电梯在加速上升, 我们也无法区别出是否”电梯没有上升, 只是自己长胖了, 亦或是地球质量突然变大了”.</p><p>等效原理就是指, 引力与加速度是等效的.</p><p>于是通过等效原理, 我们就可以通过研究加速度的参考系, 来对比引力了. 研究了加速度, 正好也弥补了狭相的理论只能用于惯性系的局限.</p><h3 id="转环"><a href="#转环" class="headerlink" title="转环"></a>转环</h3><p>那么什么东西一直有加速度, 还便于研究, 那就是圆周运动. 试想一个转环, 由一些轴和转环边框组成, 实验人员在转环内部做测量.</p><p>首先测轴长(也就是半径)和边框(周长), 方法是拿一把30厘米的尺一点点移动测量. 转环正在转, 我们需要考虑狭相的相对效应:</p><ul><li>(基于地面观察)尺子在测量边框的时候变短了, 因为测量边框时尺子的长度是转环运动方向, 而转环的周长并没有变(因为速度方向是圆的切线, 所以转环没有变大)</li><li>(基于地面观察)尺子在测量轴的时候没有变, 因为运动方向是尺的宽.</li></ul><p>所以结果是: 半径测量与地面观测一致, 但周长测量比地面观察更长. 因为测量的尺变短, 但周长没变短. 这个时候的半径周长比已经不符合圆周率了.</p><p>第二个实验: 两个实验者分别站在圆心和圆边缘. 圆心的实验者沿着轴向外运动. 仔细思考: 因为半径不同, 两个实验者的线速度是不同的, 根据狭相, 半径越大(越靠外)的运动速度越大, 时间就越慢.</p><p>我们发现, 正在做加速的物体的空间, 时间都发生了扭曲. 在这个加速系中, 各个地方的空间和时间都是不均匀的. 并应用刚才的结论, 加速和重力是等效的. 于是推导出: 引力的原理是质量扭曲了时空. 那么被扭曲的时空怎么去感受呢, 有一个简单的模型.</p><h3 id="膜球模型"><a href="#膜球模型" class="headerlink" title="膜球模型"></a>膜球模型</h3><p>试想在一张纸上画一个圆, 这个圆一定是符合正常圆周率的, 但把纸在三维空间里弯曲一下, 或是让圆心下陷一些(就像刚才的转环), 再从二维测量圆周率就有变化了. 所以广相的公式需要了解黎曼数学, 三维空间被引力的扭曲需要数学公式来带动感性认知.</p><p>膜球模型是指空间是无限张水平的膜, 有质量的物体好比一个球放到了膜上, 膜因为球的质量大小进行了不同程度的扭曲, 此时再放东西到膜上, 东西就会顺着膜的扭曲而靠近质量大的物体.</p><p>膜球模型只是一个帮助理解的模型, 对于时间的扭曲表现得更差, 后面继续讨论几个广相的侧面表现.</p><h3 id="最短距离"><a href="#最短距离" class="headerlink" title="最短距离"></a>最短距离</h3><p>我们再次讨论一个说过的问题: 在自由落体的电梯中横向扔出一个小球. 这个小球会一直沿水平方向运动.</p><p>那么在地面观察电梯中的小球发生了什么呢, 没错, 是抛物线. 现在我们已经知道时空是相对的, 所以在时空里, 最短的距离就是引力&#x2F;加速度影响下的抛物线, 抛物线的形状就是一种”时空扭曲”的肉眼可见的表现了.</p><p>并且我们平时认为在走直线, 也是在沿测地线行进, 这就是为什么一直往前走能绕地球一圈走回来.</p><h3 id="时间的扭曲与黑洞"><a href="#时间的扭曲与黑洞" class="headerlink" title="时间的扭曲与黑洞"></a>时间的扭曲与黑洞</h3><p>在转环的第二个实验里提到, 越靠近外部的点, 速度越快, 受到向心加速度越大, 时间越慢. 那么我们来假设另外一个事件.</p><blockquote><p>一个飞船飞到了能受到太阳引力的地方, a与b都带有时钟. 从飞船放下一根绳子, 绳子垂向太阳, b沿着绳子像太阳靠近, 离太阳越近, b受太阳引力影响越大, b的时钟就变得越慢.</p></blockquote><p>受到引力越大, 事件就变得越慢, 所以在地球上和月球上的时间过得也是不同的, 只是地月质量是6倍左右, 几乎感知不出, 另外太阳的质量也不大, 时间得变慢感觉得也不明显, 那么我们之后可以思考一个问题: <code>我们认为太阳的岁数是100亿年, 那么太阳内部的实际时间是多少, 又是通过什么原理让我们感受到100亿年的呢?</code></p><p>相比太阳, 黑洞的质量就大多了, 越靠近黑洞的时候时间就变得越慢, 当无限接近视界的时候, 外部看来时间就无限接近凝滞, 黑洞内的世界现在的人类还只能通过数学和想象来猜测是什么样的.</p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>相对论是这本书的5分之1, 看了以后还是迷迷糊糊的, 却也有一些感受的.</p><ul><li><p>科学是上层建筑, 先把饭恰了再搞科学吧, 所以为什么科学家总是投靠资本的. 我们这些普通人看这个纯为娱乐一下.</p></li><li><p>感叹科学家的伟大.</p><p>问问自己, 苹果掉在头上会不会去思考为什么. 对于平时生活的细节, 甚至是冲突矛盾, 我们都不会仔细思考原因, 并用一些心理防御机制(如否认, 投射)来让自己得到暂时的舒缓. 思考是痛苦的, 只有这种痛苦能让我们获得避免日后一些问题的能力. 只要向那些伟大的人学习思考生活的细节, 我们也能在自己的领域和生活里获得相应的东西.</p></li><li><p>序中说道, 研究的这些世界的道理是冷冰冰的, 真正让研究者感到快乐的是家人和亲情. 感情才是支持我们活下去的东西, 其他皆是娱乐.</p></li><li><p>专利局的工作应该挺空的.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相对论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从生活中发现否认</title>
      <link href="/2019/01/07/talk-of-denying/"/>
      <url>/2019/01/07/talk-of-denying/</url>
      
        <content type="html"><![CDATA[<p>“队友不行, 我玩得很好了”, “他水平很一般为什么成就比我高”, “他家里条件好他才发展得好”. 这些很常见的或是自己的想法, 或发生在别人身上. 距离上次看心理书已经一年多了, 嘴里一直挂着”投射”, 现在回过头看了下以前的总结, 又会有很多新发现.</p><span id="more"></span><h2 id="否认可能是最常见的心理防御"><a href="#否认可能是最常见的心理防御" class="headerlink" title="否认可能是最常见的心理防御"></a>否认可能是最常见的心理防御</h2><p>先来一句话复习什么是心理防御机制:</p><p>当本我(想做什么)与自我(应该做什么)或超我(道德上应该做什么)产生了矛盾的时候, 自我会使用一些机制把自我压到”无意识”中, 这个机制就叫心理防御. (详解在之前的弗洛伊德理论文章中)</p><p>心理防御会消耗心理能量, 这也是导致”伪内向”性格的原因, 因为太多能量用在心理防御上而没有心理能量与他人交流. </p><p>否认的定义: 认为某些事实是不真实的, <strong>在旁人看来是他的逻辑有问题</strong>.</p><p>一开始所列出的情况如:</p><ul><li>认为自己被拖累, 自己很强</li><li>认为别人好都是运气好, 自己好是努力. (<strong>几乎所有人都有这个情况</strong>)</li><li>认为别人好是被帮助或出身好. (这也许是真实的)</li></ul><p>看书时候看到的例子是: 一位深爱妻子的丈夫, 在妻子死后一直表现为妻子还活着的样子, 自我使用否认不让某些想法达到意识.</p><p>看书的时候没有特别的体会, 而记住并过了一年多竟然发现很多地方会发生书中的情况.</p><p>而如果”认为别人好都是运气, 自己好是努力”真的是一种心理防御机制, 那么如果自己一直不好, 就一直要启动, 就会导致自己心理能量常年缺失了.</p><p>并且心理防御机制的作用是防止不开心的事情进入意识, 副作用是自己会被自己骗而做了错误的事. (逻辑错误当然做错误的事)</p><p>ps: 这和”归因决定人的行进轨迹”与”你的生存本能正在杀死你”有着非常类似的推论, 所以各个学派也许是从不同的角度一起寻找真理.</p><h2 id="奇妙的投射"><a href="#奇妙的投射" class="headerlink" title="奇妙的投射"></a>奇妙的投射</h2><p>再来说一下投射, 投射的定义是: 把无意识冲动归于别人. 简单地说就是”对模棱两可东西的判断是自己的真实想法”.</p><p>这也是佛教的观点”世界是镜子”. 哲学课也教过谁说旗动杆动的想法.</p><p>投射的原理是: 如果没有想法就没有输出, <strong>一个人的输出(想法)一定是他的心里看法</strong>. 比如被观测者说一幅画是老虎, 如果他没有知道老虎这个东西, 他是不可能说出老虎的.</p><p>“画像”, “别人做这件事的动机”是常见的投射场景.</p><p>另外还有一些常见的场景是:</p><ul><li>穿秋裤是因为妈妈说我冷.</li><li>一个人喜欢被如何对待就会如何对待别人.</li></ul><p>我们可以通过一些细节来知道某个人心里的一些东西, 知道他需要什么, 害怕什么.</p><p>其实想到这里, 会有疑惑: “凭经验猜测别人的想法”, “家境好的人就有更好的发展”. 这些判断也许是真的, 而不是心理防御(或是心理防御正好猜到了现实).</p><p>我们的想法都只是猜测, 人会使用数学, 会去通过严格的逻辑证明一个猜测, 是非常伟大的. 但在大多情况下, 我们的猜测是无法去证实的, 因为我们每天也许会有一万个猜测, 但去严格证明一个猜测可能需要几周或者几十年. 但对于自己的”真正想法”, 自己有没有处于”心理防御”状态, 自己静下来是可以感受到的.</p><p>我上学的时候喜欢物理, 所以感觉心理, 甚至所有学科, 甚至语言都要用心理解意思, 语言只是工具, 通过语言理解别人要传达的意思才是本质, 这是很难的. 同样地, 用语言表达自己也是很难的.</p><h2 id="聊一聊口红效应"><a href="#聊一聊口红效应" class="headerlink" title="聊一聊口红效应"></a>聊一聊口红效应</h2><p>口红效应是指在经济下降的时候, 口红的销量反而上升. 口红不是生活必需品, 但人在买不起更好的东西的时候会用不多的钱去购买廉价的奢侈品.</p><p>这很可能是反向作用的一种表现形式.</p><p>反向作用的定义是: 我们会按照无意识欲望相反的方式行动, 以躲开可怕的欲望或念头. 例如一个女人反复告诉别人他多爱自己的母亲, 其实他在隐藏无意识中对母亲的强烈憎恨.</p><p>可以很快地想到其他的一些例子: </p><ul><li>经济不好的时候, 一些人害怕想到自己的贫穷, 就买一些买得起的(本来不会买的)奢侈品来让自己看起来有钱一些, 避免想到自己穷而难过.</li><li>工资收入比较低的人更容易月光. (这是我本人的经历, 在我工资2600的时候我会花小2000抽lol皮肤)</li><li>上班的时候没有做什么事的人更偏向于加班, 或者是留在公司继续什么都不干. (低效率的结果, 而不是原因)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序如何处理键盘覆盖输入框</title>
      <link href="/2018/12/27/input-position-in-mini-program/"/>
      <url>/2018/12/27/input-position-in-mini-program/</url>
      
        <content type="html"><![CDATA[<p>在移动端里, 当输入框处于页面比较下方的时候回发生键盘覆盖输入框的情况, 在小程序中也发生了类似情况, 但小程序提供了一些api, 但不能达到需求. 这里来简单说一下解决思路.</p><span id="more"></span><h2 id="小程序的默认行为"><a href="#小程序的默认行为" class="headerlink" title="小程序的默认行为"></a>小程序的默认行为</h2><p>在发生了键盘覆盖输入框的时候, 在不操作任何api的情况下, 小程序会把屏幕向上推, 推到<code>输入框正好在键盘上方</code>的位置.</p><p>也就是如果不经过处理, 小程序的键盘是不会覆盖输入框的. 但是在我的需求里这样还不够, 因为页面上部分是需要持续展示的内容, 不希望把页面向上推.</p><p>所以下面要通过小程序的api来解决这些问题.</p><h2 id="cursor-spacing"><a href="#cursor-spacing" class="headerlink" title="cursor-spacing"></a>cursor-spacing</h2><p>在比较正常的UI设计中, 输入框外面实际都会有一层wrapper, 而很明显小程序是默认行为是不知道的, 所以结果是会把这层wrapper的下半部分(输入框以下的)切掉. 那么就非常难看了.</p><p>引入这个api<code>cursor-spacing</code>, 设多少, input下面就留多少. 这个数字应当是’输入框下边缘到wrapper结束的距离”.</p><p>小程序的坑在于: 文档上的单位是错的, 本来就需要试才知道这个属性的含义是什么, 所以单位错导致无效果就让一(大)部分人放弃了. 正确的单位是<strong>带有单位的字符串</strong>. 例如<code>10px</code>或者<code>100rpx</code>.</p><h2 id="adjust-position"><a href="#adjust-position" class="headerlink" title="adjust-position"></a>adjust-position</h2><p>刚才说到我的需求, 我希望页面不向上推, 而直接把输入框顶上来.</p><p>于是尝试了这个api. 默认是true, 把他设为false. 效果变成了: 点了输入框, 键盘完美覆盖输入框.</p><p>于是在加上<code>cursor-spacing</code>, 发现这两个api是不能同时生效的.</p><p>所以最后结论是: 单纯用提供的api无法实现需求了. 所以只能监听事件自己做.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>手动操作输入框思路:</p><ol><li>adjust-position设为false.</li><li>在输入框的wrapper的bottom样式绑到本地数据, 并设为absolute定位.</li><li>在focus事件里改变输入框的位置.</li><li>在blur事件里复原输入框的位置.</li></ol><p>按照这个思路操作, 遇到了几个问题:</p><h3 id="如何确定输入框的位置"><a href="#如何确定输入框的位置" class="headerlink" title="如何确定输入框的位置"></a>如何确定输入框的位置</h3><p>发现在<code>bindfocus</code>事件中可以获得键盘的高度, 经过尝试, 键盘的高度是以<code>px</code>为单位的. 所以直接把bottom的值设为px高度就行了.</p><p>如果输入框wrapper的相对定位不是页面底部, 情况就比较复杂, 若是用rpx为单位, 需要获得屏幕宽高来计算px数, 在不麻烦的情况下可以调整布局使wrapper相对于页面底部定位.</p><h3 id="在改变style后输入框立即失去焦点"><a href="#在改变style后输入框立即失去焦点" class="headerlink" title="在改变style后输入框立即失去焦点"></a>在改变style后输入框立即失去焦点</h3><p>发生了这个情况后表现为: 点了输入框, 输入框的wrapper闪一下又回原处. (因为失去焦点)</p><p>经过多次试验, 需要做的是在绑定一个本地变量到<code>focus</code>属性.</p><p>然后用wx:if根据是否focus隐藏输入框, 放一个假的输入框, 点击以后使改变focus属性来唤起键盘.</p><p>贴一份<a href="https://github.com/cwj0417/step/blob/master/src/pages/did/index.vue">实现的代码</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用sort实现orderby</title>
      <link href="/2018/12/21/js-order-by-via-sort/"/>
      <url>/2018/12/21/js-order-by-via-sort/</url>
      
        <content type="html"><![CDATA[<p>工作到了这个年数, 感觉那些基本函数语法已经跟人合一了, 根本不会为操作一些数据结构而思考半天了. 在做小程序的时候遇到了个orderby的场景, 结果发现没有以为的那么简单. 也许是之前不求甚解的原因, 那么现在来解决orderby的问题.</p><span id="more"></span><h2 id="问题的产生与探讨方向"><a href="#问题的产生与探讨方向" class="headerlink" title="问题的产生与探讨方向"></a>问题的产生与探讨方向</h2><p>在小程序中有个将list的某一条置顶的需求, 在初始化数据到时候可以使用数据库的orderby, 但在更新数据以后再重新初始化就显得有些不妥, 所以我尝试直接使用computed列表来解决这个问题.</p><p>所以现在的问题是: <strong>输入list, 输出orderby置顶字段</strong>.</p><p>之前以为的sort很简单, 我就尝试了: <code>arr.sort(i =&gt; i.stick)</code>. 字面看起来是根据stick字段来排序. 输出结果一团糟. 仔细思考了下又尝试了别的方法, 还是失败, 才决定仔细想一下应该如何处理.</p><h2 id="对sort的理解与快速shuffle"><a href="#对sort的理解与快速shuffle" class="headerlink" title="对sort的理解与快速shuffle"></a>对sort的理解与快速shuffle</h2><p>先说一下之前对sort的理解.</p><p>sort接受的参数返回大于0或者小于0. 根据结果来排序.</p><p>所以有一个快速shuffle数组的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>因为函数的返回结果一半是大于0一半是小于0的(不严格, 但之后也认为概率是一半一半). 所以任何输出进行了如此处理, 都会变成一个随机顺序的数组.</p><p>另外一个例子, 对一个数组: <code>[1, 2, 3, 4, 5, 10, 11, 12]</code>进行排序, 如果不传参数排序结果是错的, 因为默认是localCompare. 所以要写成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure><p>这样才能得到正确从小到大的排列.</p><p>以上就是我多年以来对sort的所有理解. 所以才会写出上面的: <code>arr.sort(i =&gt; i.stick)</code>这样搞笑的东西. 因为理解是有问题的.</p><h2 id="sort是如何排序的"><a href="#sort是如何排序的" class="headerlink" title="sort是如何排序的"></a>sort是如何排序的</h2><p>因为不知道sort函数得到了结果后是如何排序的. 所以对sort的理解有问题. 而我们知道reduce就是从头到尾遍历并传递每次计算的结果. sort却不知道. 所以打出每次的返回值来看一下每次得到返回值后sort做了些什么.</p><p>我们要对不同数组进行同样的操作, 排序方法是一样的, 先写一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">log</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, a - b &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始对不同数组进行排序: 先来1到5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">sort</span>(log)</span><br></pre></td></tr></table></figure><p>结果: <code>[1, 2, 3, 4, 5]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 1 true</span><br><span class="line">3 2 true</span><br><span class="line">4 3 true</span><br><span class="line">5 4 true</span><br></pre></td></tr></table></figure><p>尝试: 从5到1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].<span class="title function_">sort</span>(log)</span><br></pre></td></tr></table></figure><p>结果: <code>[1, 2, 3, 4, 5]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 5 false</span><br><span class="line">3 4 false</span><br><span class="line">2 3 false</span><br><span class="line">1 2 false</span><br></pre></td></tr></table></figure><p>目前看来, sort应该是插入排序. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>].<span class="title function_">sort</span>(log)</span><br></pre></td></tr></table></figure><p>看log的时候我把当前排序结果也打一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">5 3 true [3, 5]</span><br><span class="line">7 5 true [3, 5, 7]</span><br><span class="line">9 7 true [3, 5, 7, 9]</span><br><span class="line">2 9 false // 2还是与当前最大的9比.结果第一次false</span><br><span class="line">2 7 false // 于是一路比下来</span><br><span class="line">2 5 false</span><br><span class="line">2 3 false // 比到最小的, 于是确定了位置 [2, 3, 5, 7, 9]</span><br><span class="line">1 5 false // 1选择了与5比, 此时5是中间位置的数, 而不是最大的数</span><br><span class="line">1 3 false // 然后一个一个比较下来</span><br><span class="line">1 2 false [1, 2, 3, 5, 7, 9]</span><br><span class="line">6 5 true // 6还是于5比, 此时5也是中间位置的数</span><br><span class="line">6 9 false // 没有选择与7, 而是与9比了</span><br><span class="line">6 7 false</span><br></pre></td></tr></table></figure><p>从这些log能得出一些粗浅的结论:</p><ol><li>sort是插入排序</li><li>每次比较的数字会根据两个因素来决定: 分别是之前比较的结果和当前排序的位置</li></ol><h2 id="如何实现orderby"><a href="#如何实现orderby" class="headerlink" title="如何实现orderby"></a>如何实现orderby</h2><p>首先明确思路:</p><p>sort认为每个元素之间的关系是比大小, 所以我们需要做的是<strong>写出任意两个元素的相对顺序的普遍公式</strong>.</p><p>先构建一组数据:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">gnrt</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">age</span>: <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">50</span>), <span class="attr">height</span>: <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">200</span>) &#125;)</span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>&#125;).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title function_">gnrt</span>())</span><br></pre></td></tr></table></figure><p>我们先建立<code>纯数字, 无顺序</code>的orderby来理这个思路.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> orderby = <span class="keyword">function</span> (<span class="params">arr, ...orders</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> order <span class="keyword">of</span> orders) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[order] - b[order] !== <span class="number">0</span>) &#123;</span><br><span class="line">res = a[order] - b[order]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>orderby(arr, &#39;height&#39;, &#39;age&#39;)</code>就得到了理想的orderby结果了: 根据权重排序, 如果都一样就保持顺序.</p><p><strong>#后续#</strong></p><p>这个思路清晰以后, 做兼容就容易了:</p><ol><li>如果要指定顺序, 在排序参数里带特征, 例如’height’, ‘-height’, 来决定在执行的时候是a - b 还是b - a.</li><li>如果要指定排序函数(在非数字情况下). 把排序参数改写成兼容function的, 判断是string就执行默认, 是function就调用function即可.</li></ol><p>当然, 功能越完善的函数就越复杂, 函数本身只是函数复杂度和业务复杂度交换的作用. 具体实现就不写了.</p><h2 id="所以置顶排序如何实现"><a href="#所以置顶排序如何实现" class="headerlink" title="所以置顶排序如何实现"></a>所以置顶排序如何实现</h2><p>我们已经想清楚了orderby的实现, 那么置顶排序是stick这个布尔值字段, 就必须根据我上面说的传函数进去, 并且改写orderby函数.</p><p>这样又要多些2个函数, 所以我选择:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arr.<span class="title function_">filter</span>(&#123;stick&#125; =&gt; stick), ...arr.<span class="title function_">filter</span>(&#123;stick&#125; =&gt; !stick)]</span><br></pre></td></tr></table></figure><p>搞定.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写一个swiper</title>
      <link href="/2018/12/17/how-to-build-a-swiper/"/>
      <url>/2018/12/17/how-to-build-a-swiper/</url>
      
        <content type="html"><![CDATA[<p>swiper是个常用组件, 但是在生态圈还不太完善的小程序中出现了比较特殊的需求的时候就产生了很大的问题. 出于无奈要自己写一个, 于是倒看到了另外一个世界.</p><span id="more"></span><h2 id="为什么要去造这个轮子"><a href="#为什么要去造这个轮子" class="headerlink" title="为什么要去造这个轮子"></a>为什么要去造这个轮子</h2><p>我们这个工龄的已经麻木的人为什么会想去造轮子, 当然造轮子是一种工作能力, 造轮子能获得加深职业槽的结果.</p><p>但很明显这不是我的出发点, 实在是对需求无解没有可用轮子, 所以要解释一下背景:</p><h3 id="背景和目的"><a href="#背景和目的" class="headerlink" title="背景和目的"></a>背景和目的</h3><p>首先, 使用组件是一个通常的思路, 这也导致了我其实对实现细节深入不够. 小程序的生态非常新, 最近一个项目用mpvue, 虽然使用了强大的vue直接使用vue的ast, 但是很多lib都是强dom依赖的, 特别是某些组件, swiper就是其中一个. (notification和toast就更不用说了)</p><p>我本来有两个需求: 写swiper-cell, 和把一个swiper改写成无限滚动的.</p><h3 id="如何把组件改到小程序上"><a href="#如何把组件改到小程序上" class="headerlink" title="如何把组件改到小程序上"></a>如何把组件改到小程序上</h3><p>普通的web组件不能使用在小程序上的原因就是dom依赖. 简单地看又分为两种:</p><ul><li>swiper的dom依赖为操作样式. 众所周知swiper的原理就是监听操作和控制滚动, 所以解决方案用style绑定就行了.</li><li>弹框类的dom依赖是创建dom. 这个处理就要放弃原来的api了. 因为dom一定要写在template里, 小程序也有操作template的api, 但是比较麻烦.</li></ul><p>swiper就相当简单, 在组件中用一些本地数据控制写到style中, 操作数据就能操作样式了.</p><h2 id="写一个swiper的思路"><a href="#写一个swiper的思路" class="headerlink" title="写一个swiper的思路"></a>写一个swiper的思路</h2><p>写一个swiper, 首先要知道划动的基本环境, 那就是:</p><h3 id="template结构-x2F-dom结构"><a href="#template结构-x2F-dom结构" class="headerlink" title="template结构&#x2F;dom结构"></a>template结构&#x2F;dom结构</h3><p>一个swiper的dom结构基本就是:</p><ul><li>一个wrapper, 作用是控制整个组件的样式和计算高度, 并使内部元素有更多实现方式.</li><li>内部元素wrapper, 这个元素会包含所有swiper-item, 所以长度&#x2F;高度是溢出的, 划动的核心就是操作这个元素的位置. 或者用transform, 或者用absolute定位(此时需要外部wrapper相对定位, 这个情况外部wrapper是必须存在的).</li><li>内部元素(swiper-item). 内部元素没有特别好说的, 可以特别说的是水平和竖直两个swiper的情况. 两个方式可以把情况写成通用, 一个是transform控制, 一个是外部flex布局.</li></ul><p>其实布局是写组件最复杂的部分, 因为要计算元素高度, 思考各个情况. 因为我只是写了一个供自己使用的组件, 所以做得不完善. 所以进入下个部分.</p><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>刚才提到了3个元素, 只需要在内部元素wrapper上加上3个事件监听就行了, 分别是touchstart, touchmove, touchend. swiper本身就是移动端的东西, 这3个事件足以. 我们分别在三个事件做的事情是:</p><ul><li>touch start: 记录开始触摸的点, 存到组件数据中.</li><li>touch move: 根据触摸开始的点和当前的位置, 来移动wrapper的位置.</li><li>touch end: 根据阀值来确定swiper应该自动滚动到哪儿, 并按照这个位置移动.</li></ul><p>基本思路就是这么简单, 只是在move的时候可以注意的细节非常多, 比如划动范围, 比如手势是横向的还是纵向的, 最后来把wrapper定位到合适的地方.</p><p>那么提到了:</p><h3 id="移动wrapper位置"><a href="#移动wrapper位置" class="headerlink" title="移动wrapper位置"></a>移动wrapper位置</h3><p>在touch move 和 touch end的时候都需要操作wrapper的位置, 出于小程序兼容考虑, 直接在wrapper上绑定style到组件数据, 控制这些组件数据就行了. 别的地方有做法是获取组件的$el(也就是dom)来操作.</p><p>其实功能已经搞定, 但这样使用起来体验非常差, 所以其中还有一个小细节是:</p><h3 id="设置transition"><a href="#设置transition" class="headerlink" title="设置transition"></a>设置transition</h3><p>得益于css3和小程序的不需要兼容, 直接设transition就可以使划动过度很舒服了.</p><p>但注意: 必须分两个时间</p><ul><li>在move的时候(也就是手指还在屏幕上的时候), 要把transition设为很低, 或者为0.</li><li>在end的时候, 把transition设高, 让用户体验是慢慢弹回到该在的位置.</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做swiper和swiper-cell的基本思路还是很简单的, 只是细节上需要细心打磨操作感, 另外如果希望做成通用组件, 在设置dom和wrapper组件的时候需要花比较多的功夫来提供api.</p><p>最后贴一个<a href="https://github.com/cwj0417/step/blob/master/src/components/swiperCell.vue">自己写的超简单, 功能单一的swiper-cell</a>和<a href="https://github.com/airyland/vux/blob/v2/src/components/swiper/swiper.js">vux的功能比较完善的swiper</a>地址.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 小程序 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资本论第二章 交换过程</title>
      <link href="/2018/12/02/das-capital-2/"/>
      <url>/2018/12/02/das-capital-2/</url>
      
        <content type="html"><![CDATA[<p>这章是对上个部分的拓展, 并描述从商品到货币产生的奇妙过程, 这个货币的产生过程就是由大量的交换过程导致演化的.</p><span id="more"></span><h2 id="主题内容概述"><a href="#主题内容概述" class="headerlink" title="主题内容概述"></a>主题内容概述</h2><h3 id="商品和人的关系"><a href="#商品和人的关系" class="headerlink" title="商品和人的关系"></a>商品和人的关系</h3><p>因为商品是东西不会自己动, 是通过人来交换的, 所以人在商品交换中的角色是经济关系的人格化.</p><p>而商品占有者的商品对他没有直接的使用价值, 所以才会把商品卖给别人, 所以商品对于人(卖家)来说是交换价值的承担者. 所以: <strong>每个商品占有者(卖家)都把自己的商品作为特殊等价物(类似货币的作用, 但注意, 只是对自己来说).</strong> 并且是<strong>每个</strong>, 自己都把自己的商品作为特殊等价物, 那么每个人看别人的商品的属性都是对立的.</p><p>这时货币还没有形成, 也就是上章所讲的”扩大的相对价值形式”, 随着交换的进行, 大家发现了价值对立, 没有统一的问题. 问题与矛盾就产生, 所以逐渐出现了货币. 那么历史(或者说人性&#x2F;需求)把什么物变成了货币这种猛兽呢?</p><h3 id="什么性质的物适合当货币"><a href="#什么性质的物适合当货币" class="headerlink" title="什么性质的物适合当货币"></a>什么性质的物适合当货币</h3><p>最初交换频率比较多的东西自然会成为货币, 一开始是牲畜或者奴隶, 随着商品交换的发展, 货币慢慢落到了贵金属上, 因为:</p><ul><li>贵: 稀有, 能集中表现人类劳动结果.</li><li>金属: 方便任意分隔与任意组合.</li></ul><p>所以选择了”贵 金属”. 所以金银是天然的货币, 而不是铜铁, 因为稀有.</p><p>前阵看了个小道消息, 美国打算开采地球周围某颗小行星, 用2.6亿美元的成本开采, 可以获得这个行星上价值300亿美元的铂金. 但会出现一个问题: 地球上现有的铂金就大幅降价了, 所以这是无意义的行为, 最后放弃了.</p><p>为什么获得成本降低, 价值就会降低, 在上一章已经讨论了, 其实反复强调<strong>充当货币的物需要是稀有的</strong>, 是因为:</p><h3 id="货币是一种商品"><a href="#货币是一种商品" class="headerlink" title="货币是一种商品"></a>货币是一种商品</h3><p>经过了第一章和第二章的推论, 要明白货币的本质是一个商品, 只是在历史过程中被赋予了独特的<strong>价值形式</strong>. 所以: 每一份货币能交换多少商品, 就是由货币的本质(商品)来决定的, 因为是商品, 才能度量人类劳动力在这个物上的消耗, 才能判断交换比例(也是上一章的结论).</p><h2 id="额外的知识概念和感悟"><a href="#额外的知识概念和感悟" class="headerlink" title="额外的知识概念和感悟"></a>额外的知识概念和感悟</h2><h3 id="起初是行动"><a href="#起初是行动" class="headerlink" title="起初是行动"></a>起初是行动</h3><p>货币实际上是先形成, 再被发现和认识的. 这算是个世界发展的哲学.</p><p>我看来的模型是: 理论与实践的关系.</p><p>很明显, 大多数时间是实践先行的. 我们人生经历过的很多个第一次都是没有人教过自己的.</p><p>理论先行的情况有二. 一是上课&#x2F;看书. 二是理论科学家(现代一些物理学家).</p><p>所以我的结论是: 理论先行的是极少部分的聪明人. 所以读书的时候真的以学知识为目的读书的人也是极少的.</p><h3 id="思考理所当然事情深入的推论"><a href="#思考理所当然事情深入的推论" class="headerlink" title="思考理所当然事情深入的推论"></a>思考理所当然事情深入的推论</h3><p>我们以为商品交换是理所当然的, 但文中提到在以前共同体的社会成员中并不存在, 因为<strong>要承认货币就要先承认每个人是独立的和物是私有的</strong>.</p><p>这是一个非常厉害的看待事物的思维, 其实是上一章”能比较的物一定在某个维度是相同的”的拓展.</p><p>在我们看来许多事是理所应当的, 但这个理所应当下包含了一些信息的, 我们要知道某些环境是当前事情成立的必须条件, 多思考理所应当的事情能更好地防范其实必然会发生的突发事件. (比如死亡)</p><h3 id="问题和解决问题的手段是同时产生的"><a href="#问题和解决问题的手段是同时产生的" class="headerlink" title="问题和解决问题的手段是同时产生的"></a>问题和解决问题的手段是同时产生的</h3><p> 想到了哪儿听到的一句话: 抱怨越多的地方机会就越大. 有问题的地方才有方案, 才产生价值.</p><p>也想到了物理界的大时代, 只要一个理论被提出, 相关的领域就会快速发展.</p><p>又想到一个场景, 老师上完课最后会问, “还有什么问题吗”, 当然结果一般都是没人有问题. 结果考试分数都很糟糕.</p><p>所以觉得有问题, 有困难的时候, 也许是进步的机会, 是证明自己能力和价值的机会.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资本论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替身使者互相吸引</title>
      <link href="/2018/11/11/stand-user-attract-each-other/"/>
      <url>/2018/11/11/stand-user-attract-each-other/</url>
      
        <content type="html"><![CDATA[<blockquote><p>i reject my humanity, jojo!</p></blockquote><p>众所周知替身使者互相吸引, 昨天翻老板朋友圈看到了12年发的川崎600级别的大排, 进行了一番思考.</p><span id="more"></span><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>大二的时候被忽悠看了jojo, 从而变成了小众自嗨群体, jojo里有一个理论: 替身使者互相吸引, (替身能力可以理解为特殊能力, 而常人看不出)也许是为了解释类似”男主为何正好在xxx时遇到女主”, jojo提出了这个理论, 使剧情合理化.</p><p>所以这也成了jojo神了的地方, 因为这个理论很准.</p><h2 id="简短地回忆"><a href="#简短地回忆" class="headerlink" title="简短地回忆"></a>简短地回忆</h2><h3 id="jojo"><a href="#jojo" class="headerlink" title="jojo"></a>jojo</h3><p>首先看jojo的人本身就是个小众群体, 15年进入了我毕业后第二家公司, 不超过10个人的公司, 竟然有3个人追jojo还比我深, 一位同事还送了我正版手机壳.</p><h3 id="钢琴"><a href="#钢琴" class="headerlink" title="钢琴"></a>钢琴</h3><p>16年我买了架电钢琴, 花了2个月时间学会了致爱丽丝, 然后朋友圈有个女孩子开始发学钢琴的视频, 还弹了这首(的简化版). 当然我弹的是完整版, 当然那个女孩子也不知道我的存在.</p><h3 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h3><p>大概也15左右的时候学了日语, 15年进的那个单位就出现了一个自学n2的同事, 就是那个不到10人的公司, 还与jojo的同事不重复. 之后还和一位日语专业的朋友保持了很近的关系.</p><h3 id="摩托"><a href="#摩托" class="headerlink" title="摩托"></a>摩托</h3><p>我是今年6月开始骑换挡的摩托车, 然后当时在的公司就开始赶人了, 于是我被赶到了新的公司(随手找的), 公司老板是比我资深多的摩托玩家, 还因为一些巧合我还加上了开杜卡迪大魔鬼的小哥微信.</p><p>稍作总结, 我是一个不喜欢主动去进入兴趣圈子的人, 确实也没这么做, 但是身边就会莫名其妙出现和做和自己一样的事的人.(并且事情是小众的)</p><h2 id="反思-amp-结论"><a href="#反思-amp-结论" class="headerlink" title="反思&amp;结论"></a>反思&amp;结论</h2><p>刚进入玄学思路的时候, 反思了下, 这样感觉的原因是典型的选择性思维, 人的大脑的工作方式导致了我会有这个感觉. 所以上面的感觉都只是感觉, 而不能作为论据, 因为都是毫无逻辑的.</p><p>开了摩托以后发现路上摩托好多, 很明显这是不可能的, 只是注意到了而已.</p><p>所以也许现在的单位也有人追jojo, 只是我没有注意, 就没有发现他而已.</p><p>证明一个真命题很难, 证明一个假命题只要找反例就行了. 这是我对于玄学的抵抗方式(是的, 希望信星座的你们也能懂).</p><p>得出一个结论: <strong>每个人活在同一个物质世界, 但活在不同的精神世界.</strong> 比如一个不懂摩托的人, 看到豪车从身边经过还什么都不知道, 脑子里还只是想着今天回家要上钻石. 一件事发生, 不同的人看到的是不同的事情.</p><p>看到过一个图片是:</p><blockquote><p>​把袜子反穿了, 那么这个世界穿上了你的袜子, 而你是世界上唯一没穿袜子的人.</p></blockquote><p>同样的, <strong>我学了摩托, 我就把世界变成了很多摩托手的世界.</strong> 这个感受也是没问题的.</p><p>同样可以拓展为: <strong>当我变成了一个有趣的人, 那么这个世界就变成了有趣的世界.</strong></p><p>(其实只是世界本来就有趣, 而你本是一个无趣的人).</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资本论第一章 商品</title>
      <link href="/2018/11/08/das-capital/"/>
      <url>/2018/11/08/das-capital/</url>
      
        <content type="html"><![CDATA[<p>这个主题起源于我上个月想买摩托牌照, 进而思考为什么铁皮会那么贵, 如果我买了会不会贬值之类的问题. 而开始看资本论. 看了第一章及之后的目录感觉这本书非常容易看, 因为有连贯性和目的性, 像在看故事.</p><span id="more"></span><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>是的, 读后感也要作序.</p><p>谈一下我对看这本书的看法的转变: 之前我认为希望能看完, 看了一些感觉到, 就算一点细节也要咀嚼, 所以我现在不以看完为目的, 而是尽量深刻地理解为目的, 不求看完. (只看小目标, 自己心里知道大目标是早晚完成的. 这也是一种重要的道理或说是哲学.) 但心里知道如果这样做了, 迟早会看完. 反而以看完为目标, 倒是看不完了吧.</p><p>再谈一下看了几页的感受: 可能是翻译过来的关系, (原版还不是英语, 我直接放弃了看原版) 更大部分可能是本身就需要仔细理解, 所以有时候一些词甚至断句都需要仔细看几遍. 只要一处不懂, 继续往下看, 结果就是越来越不知所以导致放弃.</p><p>序完, 下面开始读后感之: 第一章, 商品.</p><h2 id="主体内容概述"><a href="#主体内容概述" class="headerlink" title="主体内容概述"></a>主体内容概述</h2><p>作为”资本论”的第一章, 也能说明”商品”是万恶之源, 是研究”资本是什么”的细胞和入口, 所以第一个问题是: 商品是什么?</p><h3 id="商品是什么"><a href="#商品是什么" class="headerlink" title="商品是什么"></a>商品是什么</h3><p>首先商品是个东西, 一个有价值的东西. <strong>一个商品的价值分为使用价值和价值量.</strong> 这是两个非常重要的概念.</p><h4 id="使用价值"><a href="#使用价值" class="headerlink" title="使用价值"></a>使用价值</h4><p>使用价值是指商品的用处. 但是这部分价值不涉及价格, 也就是传说中的”无价之宝”. 空气, 处女地, 天然草地这三个东西也有价值, 但是不一定会有价值量.</p><h4 id="价值量"><a href="#价值量" class="headerlink" title="价值量"></a>价值量</h4><p>价值量也就是价格, 之所以有价格, 也就是有交换.</p><p>举一个贯穿本文的例子: 衣服与布.</p><p>首先布一定是有”使用价值的”, 当然衣服也有. 但是价值量是由交换产生的. (之前一直说价格量是价格, 是不严谨的, 只是便于理解)</p><p>有个人发现他需要衣服, 但是手上只有布. 于是想用布交换衣服, 他和邻居成功地交换了衣服和布.</p><p>我们来分析一下这次交换: 首先布和衣服都有”使用价值”, 因为没人会用布去交换一块石头(指代没使用价值的东西, 严格来说石头是有使用价值的). 其次, 在交换的时候, 一定会产生”用多少布交换多少衣服”的问题, 那么这个”多少”就是”价值量”了.</p><p>所以做一个简单的总结: <strong>一个有使用价值的物在交换的时候产生价值量.</strong> 所以有一个推论是: <strong>一个物可以只有使用价值, 但不可能只有价值量, 因为价值量产生的前提是使用价值(交换).</strong></p><p>那么你接下来会问, 到底是多少布交换多少衣服, 如何决定呢?</p><h4 id="价值量由什么决定"><a href="#价值量由什么决定" class="headerlink" title="价值量由什么决定?"></a>价值量由什么决定?</h4><p>直接说答案: 社会平均劳动力的消耗.</p><p>比如1匹布是1人织1天. 做一件衣服需要10匹布, 并且1人做10天才能把布做成衣服. 那么他们交换的比例可能是: <strong>20匹布交换1件衣服</strong>.</p><p>顺带解释一下”平均”劳动力. 如果我织布很慢, 2天织1匹, 并不能让衣服可以交换10匹布. 因为别人织布是1天1匹.</p><p>再解释一下”社会劳动力”. 社会劳动力是与很多因素相关的, 比如: 气候, 科技, 劳动人员素质, 生产力(劳动效率).</p><p>如果你问”金银”的价值量是什么, 不是不需要劳动吗? 他需要的劳动是寻找, 比如1个人找1天可以获得1克银, 但找10天才可以获得1克金, 所以金的价值量是银的10倍.</p><p>举几个例子来说明价值量的变化:</p><ul><li>工业革命有了蒸汽织布机, 1个人1天可以织2匹布. 那么1件衣服就能换40匹布了.</li><li>气候变化, 青菜的产量不同, 导致青菜的价格四季不同. (至于质量如何可能是心理, 但价格确实是劳动力(气候变化影响劳动力)变化导致的).</li><li>钻石和石墨的化学元素是一样的, 但现在钻石只能靠找所以价值量很高, 如果科技能达到高温高压处理石墨, 那么钻石的价值量会下降. 比如原来1人100天能找到1克钻石, 那么后来1人1天造1克钻石, 价值量就下降100倍.</li></ul><h3 id="商品的二重性"><a href="#商品的二重性" class="headerlink" title="商品的二重性"></a>商品的二重性</h3><p>商品的二重性是商品的两个因素(使用价值和价值量)导致的.</p><p>商品承载了两个属性, 一个是使用属性, 一个是价值属性.(对应使用价值和价值量)</p><p>分别来讨论两个属性的来源.</p><p>用我最喜欢的摩托车来举例. 再用我比较想买的宝马水鸟举例. 520斤的重量, 价格裸车人民币25万.</p><p>这部摩托的二重性是第一个方面: 他是一部摩托, 有使用价值(具体价值不赘述, 略过10000字). 第二个方面: 他有他的价值量. (在这里的表现为25万, 但价值量是劳动力的消耗, 推算到价格还有很多路, 并不完全相等)</p><p>所以有了这部车子以后: 社会上又多了一部交通工具, 并且社会有多了价值25万的东西.</p><p>但是! 摩托的使用价值和售卖价格是无关的! 因为<strong>使用价值是固定的, 而价值量是由消耗的劳动力决定的.</strong> 那么:</p><h4 id="使用价值是如何产生的"><a href="#使用价值是如何产生的" class="headerlink" title="使用价值是如何产生的?"></a>使用价值是如何产生的?</h4><p>一些东西自然就有使用价值, 而一些不是, 比如这部摩托520斤几乎都是金属, 而很明显他的使用价值远高于金属.</p><p>其实所有”创造”本质都是改变状态, <strong>劳动是财富之父, 土地是财富之母</strong>. 世界上的物质不会变, 变的只是存在的状态. (当然根据熵增定律, 生产越快世界毁灭越快)</p><p>所以人类消耗劳动力, 通过改变金属形态, 创造了使用价值, 创造了社会财富.</p><p>但这部摩托能卖多少钱, 是由他的价值量决定的.</p><h4 id="价值量是如何产生的"><a href="#价值量是如何产生的" class="headerlink" title="价值量是如何产生的?"></a>价值量是如何产生的?</h4><p>之前回答过了, 是劳动消耗的多少决定的. 所以一个商品的使用价值和价值量是无关的. 举几个例子的情况:</p><ul><li>还是一样质量的摩托, 生产速度提高一倍, <strong>摩托的使用价值不变, 摩托价值量就减半.</strong></li><li>同样的生产时间, 摩托的质量翻倍, <strong>摩托的使用价值翻倍, 摩托价值量不变.</strong></li></ul><p>所以商品的使用价值和价值量是不相关的. 此为商品的二重性.</p><h3 id="商品的价值"><a href="#商品的价值" class="headerlink" title="商品的价值"></a>商品的价值</h3><p>讨论完了商品承载的价值, 我们开始讨论商品交换时候的价值量.</p><p>用布交换衣服, 一定是按照一定的比例. 这里开始我们讨论交换商品的交换比例, 以及货币是如何出现的.</p><h4 id="关于比较"><a href="#关于比较" class="headerlink" title="关于比较"></a>关于比较</h4><p>交换比例, 我们就要比较布和衣服的价值, 但有一个问题是: 布和衣服是不同质的, 不同质也就不能去比较量.</p><p>有一个基本道理是: <strong>要去比较量, 首先要找到一个相同质.</strong> 就像把摩托车和一只鸡比较, 是无从比较的. 如果把摩托车和自行车比较, 那么他们在”速度”这个维度是有相同质的, 于是可以在速度这个维度去比较量(速度的快慢).</p><h4 id="相对价值形式与等价价值形式"><a href="#相对价值形式与等价价值形式" class="headerlink" title="相对价值形式与等价价值形式"></a>相对价值形式与等价价值形式</h4><p>那么商品的种类千奇百怪, 我们怎么让所有商品同质呢?</p><p>由衣服和布说起, 在交换时, 交易双方尝试把一件商品作为一个标准, 来计算另一件商品的价值. 比如:</p><blockquote><p>​把”布”作为一个标准, 那么1件衣服有20匹布的价值.</p></blockquote><p>于是20匹布和1件衣服的比例进行了商品交换.</p><p>接下来我们对”把布作为标准”这个行为进行深入的讨论.</p><p>在把布当做标准的时候, 布本身已经失去了他使用价值的意义, 而成为衡量衣服价值的尺子.</p><p>也就是如果把布作为一个标准&#x2F;单位&#x2F;标尺来衡量衣服价值的时候: <strong>布失去了使用价值, 而只剩价值量. 同时衣服只剩下使用价值, 他的价值变成了以布为单位的数量</strong>.</p><p>于是我们给了他们一些身份:</p><p>作为标准的布称作<strong>相对价值形式</strong>, 因布而获得价值的衣服称作<strong>等价价值形式</strong>.</p><p>当然如果把衣服作为标准, 布的价值就是1&#x2F;20的衣服, 此时衣服就处于相对价值形式, 而布处于等价价值形式.</p><h4 id="相对价值形式的量的确定"><a href="#相对价值形式的量的确定" class="headerlink" title="相对价值形式的量的确定"></a>相对价值形式的量的确定</h4><p>讨论完了商品在交换中所处的价值形式, 那么交换的量是如何确定的呢, 为什么20匹布&#x3D;1件衣服呢?</p><p>答案是根据两者价值量的比例. 价值量又是由平均社会劳动力的消耗决定的. 所以:</p><p><strong>交易商品的比例是由双方商品的劳动力消耗量动态决定的.</strong></p><p>交易的比例的各个情况就不作详细解释了.(每一方的劳动力消耗有变化都会导致比例的变化, 当然比例不变也可能是两方的变化相同, 不代表劳动力消耗没有发生变化)</p><h4 id="价值形式的演化"><a href="#价值形式的演化" class="headerlink" title="价值形式的演化"></a>价值形式的演化</h4><p>讨论完了衣服和布, 我们很明显会感受到两个问题:</p><ul><li>无论如何交换谁作为标准, 交换比例是不变的. (20布&#x3D;1衣服 或者 1衣服&#x3D;20布)</li><li>这个交换形式没有通用性, 如果按照这个算法, 任意两个商品的交换都必须定义谁是相对价值形式.</li></ul><p>在漫长的历史的商品交换中, 交换次数越来越多, 交换品种越来越多, 物品的价值形式发生了一些变化.</p><h5 id="简单的相对价值形式"><a href="#简单的相对价值形式" class="headerlink" title="简单的相对价值形式"></a>简单的相对价值形式</h5><p>之前讨论的”衣服和布交换, 布作为价值标准”称作为简单的相对价值形式. 这个形式只存在于2件商品交换的时候. 所以有一些特点:</p><ul><li>每次交换都需要在两个商品中确定一个作为相对价值形式的商品.</li><li>在不同的交易中不能沿用之前交易的结果.</li><li>这个形式是偶然形成的. 是最初商品交换的时候交换双方达成的形式, 不具有拓展性.</li></ul><p>当人们发现交换商品能给生活带来便利, 就进行了更多的商品交易, 于是演化成了下一种形式.</p><h5 id="扩大的相对价值形式"><a href="#扩大的相对价值形式" class="headerlink" title="扩大的相对价值形式"></a>扩大的相对价值形式</h5><p>一个人拥有的东西比较单一, 我们暂认为某个人是生产布的, 他在交换了一次衣服以后, 慢慢地尝试与别的商品进行交换, 并且每次都<strong>把别的商品作为相对价值形式的商品,</strong> 自己的布作为等价价值形式.</p><p>这样做有一个麻烦的地方, 每次都把布以外的商品作为相对价值形式, 那么每次都要计算自己的价值. 也就是: 1匹布值1&#x2F;20件衣服, 1匹布值1&#x2F;50斤铁, 值1&#x2F;100头牛…</p><p>这种形式称作扩大的相对价值形式, 那么每多一个需要交换的商品, 布的身份又多了一种, 即: 值xxx份xx商品.</p><p>又在漫长的历史中, 发现如果把所有方向都交换过来, 那么就会获得另一种价值形式.</p><h5 id="一般价值形式与货币"><a href="#一般价值形式与货币" class="headerlink" title="一般价值形式与货币"></a>一般价值形式与货币</h5><p>把扩大的相对价值形式反过来, 把自己手上的布作为相对价值形式, 从而变为了: 1件衣服值20匹布, 1斤铁值50匹布, 1头牛值100匹布…</p><p>这样做出现了新的商品, 只要去评估新商品的值多少布就行了, 而不用重新定义相对价值形式的商品.</p><p>看似扩大的相对价值形式和一般价值形式只是反了个方向, 但是有本质的区别: 我们之前说过, <strong>处于相对价值形式的商品在这次交换中是失去使用价值的</strong>. 在一般价值形式中, 我们手里的布已经无所谓能不能使用了, 而是作为一种体现别的商品价值的存在.</p><p>在历史的演化中, 金慢慢占领了一般价值形式的中心角色. 成为一般等价物. 所以其他所有商品都使用金作为标准来衡量自己的价值, 成为了货币形式.</p><p>那么现在的人民币又是怎么回事, 为什么可以印到超过金的存量, 人民币到底值不值钱, 经济到底在往什么方向发展. 这些问题是我们关心的. 掌握基本了解货币历史也许可以明白钱的秘密. (本文完, 待续)</p><h2 id="额外的知识概念和感悟"><a href="#额外的知识概念和感悟" class="headerlink" title="额外的知识概念和感悟"></a>额外的知识概念和感悟</h2><h3 id="关于价值量和开源"><a href="#关于价值量和开源" class="headerlink" title="关于价值量和开源"></a>关于价值量和开源</h3><p>价值量(对于货币来说就是价格)是取决于平均劳动力的. 很明显的推论是: <strong>我拥有更高的技术而不公布, 我能拥有高于平均的生产力</strong>. 所以我获得相同的价值量就更轻松.</p><p>软件行业有个行为叫开源. 自己造了一些能极大程度提高所有人工作效率的软件, 并开放使用和开发源代码, 毫无疑问这是加速人类发展(同时也是加速毁灭, 因为发展的尽头就是毁灭)的. 那推论就是: 开源的人不喜欢钱.</p><p>明显是不可能的. 至于原因, 我也不知道. 但是一些大公司的好东西确实是闭源的, 或者是没用了才扔出来开源. (是不是在黑阿里)</p><p>我初步猜测原因可能是以下:</p><ul><li>技术发展到某个程度, 一定会有人开发出这个技术, 所以出于踮脚效应或是黑暗森林原则, 先开源的先出名, 等别人开源出来类似的东西自己无名也无钱了.</li><li>对自己的技术有信心, 即使开源了能看懂的人也不多, 造工具给别人用反而能让大多人技术不进步, 反而成为自己的护城河.</li></ul><h3 id="社会财富的趋势"><a href="#社会财富的趋势" class="headerlink" title="社会财富的趋势"></a>社会财富的趋势</h3><p>由商品的二重性进一步思考.</p><p>很明显的一点是: </p><ol><li>这个社会的使用价值的量在上升. 比如自行车场在不断把铁变成自行车, 自行车的使用价值比铁高, 所以整个社会的使用价值的量在上升.</li><li>商品的价值量是由劳动消耗产生的, 那么每天都有人在劳动, 所以每天会产生很多价值量.</li></ol><p>使用价值好说, 社会在越变越好.</p><p>但是对于价值量来说, 比如生产了25万的摩托车, 那世界上就多了25万人民币吗? 如果不是多了, 那么这25万的”凭空出世”对每个人手里握有的货币产生了什么样的影响?</p><p>另外, 人消耗自己来制造财富(使资源变得有序). 应该是在消耗自己生命, 生命应该是在消耗世界的某种有序, 所以是不是加速发展是在加速世界的灭亡, 也许”使用价值”足够就好, 不需要过剩, 资本是否在毁灭世界?</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资本论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue源码之VNode(二)附带之前的总结</title>
      <link href="/2018/11/08/vue-source-vnode-2/"/>
      <url>/2018/11/08/vue-source-vnode-2/</url>
      
        <content type="html"><![CDATA[<p>因为生活和工作的关系, 已经有半年多没写有意义的博客了, 最近重新开始之前的学习和做一些有”不紧急而重要”的事情.</p><span id="more"></span><p>先用一小段说下对工作的看法. 看似工作忙于业务毫无成长(也许确实是这样的), 但脱离了业务的技术也是空的, 也许搞一下业务, 搞一下生活, 再搞一下理论, 互作休息, 也是一种文武之道, 人是有周期的.</p><p>那么下面正式开始, 先来回顾一下之前看vue源码的内容, 再从之前断掉的地方继续开始.</p><h2 id="之前的vue源码阅读脉络总结"><a href="#之前的vue源码阅读脉络总结" class="headerlink" title="之前的vue源码阅读脉络总结"></a>之前的vue源码阅读脉络总结</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>vue把自己称作<code>progressive js framework</code>, 这也是vue作者吹自己的一个亮点, 并且确实因为这个特点被weex(来自阿里), mpvue(来自美团点评)充分开发而把vue的使用场景扩大到了更多的地方, 可以说水平越高越体会到了尤老板的远见和对技术的理解. 这里先不花一整个小节谈解决方案的优美了, 这并不是说了就能理解的, 只能体会.</p><p>那么vue就有很多入口, 通过<code>package.json</code>找到了rollup的配置文件, 发现有很多配置, 那么我们来找一下我们要分析的目标入口.</p><ol><li><p>根据我们使用的项目的webpack的配置(vue的alias), 使用的是<code>dist/vue.esm.js</code>, 根据rollup的配置, 最后找到了入口是: <strong><code>platforms/web/entry-runtime-with-compiler.js</code></strong>.</p><p>而这个文件只是对引入的vue做了处理输出, 引入源是**<code>platforms/web/runtime/index.js</code><strong>, 而这个文件又是引入</strong><code>core/index</code>**, <code>core/index</code>中才是真正对vue进行定义的地方. platforms文件夹下的代码是对vue的一些关于平台的方法进行了实现. 可以理解为bom&#x2F;dom相关的操作都在这里, 不让这些影响js core的纯净.</p></li><li><p>在<code>entry-runtime-with-compiler</code>中, 重写了mount方法, 在mount时<strong>把template处理成render函数</strong>, 如果有render函数就无视template.</p></li><li><p>在 runtime&#x2F;index.js 中, 加上平台相关的config, directive, component, 和patch方法, 并<strong>定义了mount方法,</strong> 位置是 core&#x2F;instance&#x2F;lifecycle.</p></li></ol><h3 id="core部分"><a href="#core部分" class="headerlink" title="core部分"></a>core部分</h3><p>到了core&#x2F;index.js, 从instance&#x2F;index引入了vue的主体, 并挂载暴露给全局的api, 和ssr的变量(这里先不关心ssr). 这里展开就非常多了. 所以看完一个部分的源码, 就会再回到core&#x2F;index这个入口来进行下个部分的分析(给自己挖好了后面的坑). 我之前看的是源码部分是围绕”数据响应及更新dom”来的, 也简单回顾一下之前的结论. </p><ol><li>在vue初始化的时候会把data, computed等属性加上getter方法, 每次getter的时候都会触发watcher来执行一些动作.</li><li>而vue中的template, 或者是.vue文件中的模板都会被(webpack或是vue的compiler)编译成render函数, render函数里就带着一些被observe的变量. 在initLifecyle的时候会注册watch函数, 注册的时候会第一次运行render函数, 运行的时候就把render函数里的observe变量的getter跑了一遍, 所以被observe的对象一有变化就会触发updateComponent.</li><li>updateComponent最后是调用了patch函数, patch函数第一次会挂载dom, 之后都是diff dom再去改变dom.</li></ol><p>已经快到之前看到的部分了, 最后一部分这次重新再走一遍, 回顾到此结束.</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>其实这部分(初始挂载dom&#x2F;数据变化diff dom)的过程都清楚了, 现在只是去看细节如何实现.</p><p>所以我们的目的是: </p><ul><li>VNode的结构是怎么样的? </li><li>render函数是怎么把template编译成ast的?(无非是正则, 但是还是想去看)</li><li>patch函数的具体实现.(第一次根据VNode挂载和根据VNode来diff, diff应该复杂许多)</li></ul><p>万恶之源在<code>core/instance/lifecycle.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>vm._render()</code>的作用是: 根据render函数来生成VNode. render函数是根据其他种种编译来的, 之前已经说过了.</p><p><code>vm._update()</code>的作用是调用patch, 可以理解为处理一些参数并调用patch.</p><p>那么<code>._render()</code>的结果作为了patch的参数, 不得不先看<code>._render()</code>的细节了.</p><h2 id="render"><a href="#render" class="headerlink" title="._render()"></a><code>._render()</code></h2><p>看了_render函数, 取了options里的render函数(此时的render函数已经是经过编译的), 并调用. 其他代码都只是做一些容错处理, 我们这次先走主线, _render函数的核心语句是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br></pre></td></tr></table></figure><p>第一个参数就是Vue, 第二个参数就是生成VNode的方法.</p><p>因为render方法可以自己写, 所以看如何编译template不是必须的, 看着文档上的render function guide就行了.</p><p>文档上render function的参数是: tag, data, children. 我们直接用文档上第一个最简单的例子来分析:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render</span>: <span class="keyword">function</span> (<span class="params">createElement</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">      <span class="string">&#x27;h&#x27;</span> + <span class="variable language_">this</span>.<span class="property">level</span>,   <span class="comment">// tag name</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> <span class="comment">// array of children</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意第二个参数不是data, 而是children. 这个函数的执行以后的渲染结果应该类似于:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    title 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就先来看看<code>createElement(&#39;h1&#39;, &#39;title 1&#39;)</code>返回的VNode是怎么样的吧.</p><h3 id="createElement"><a href="#createElement" class="headerlink" title=".$createElement()"></a><code>.$createElement()</code></h3><p>找到文件<code>core/vdom/create-element.js</code>. 除了创建VNode的核心部分, 之前的代码做了一些参数的处理(data是optional参数), 以及滤空滤错处理, 不符合预期的输入就会返回空的VNode或者报warn. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">  children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">  children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据<code>normalizationType</code>对children做处理, 这个值只有template编译成render的时候是<code>SIMPLE_NORMALIZE</code>, 自己写render函数的时候是<code>ALWAYS_NORMALIZE</code>, 所以我们看后者.</p><h3 id="normalizeChildren"><a href="#normalizeChildren" class="headerlink" title=".normalizeChildren()"></a><code>.normalizeChildren()</code></h3><p>代码在core&#x2F;vdom&#x2F;helpers&#x2F;normalize-childrens.js</p><p>代码开头就进行了大段业务逻辑的注释, 大概意思是经过编译的render函数是不需要normalize的, 除非有数组嵌套, 所以有嵌套的时候就把数组flatten了(simpleNormalizeChildren), 还有一种情况是手写的render函数, 要进行full-normalize, 因为文档提供的api的快速通道是”如果穿字符串就代表字符串节点”除此之外都必须用createElement创建vnode, 也就是normalize有两个工作: 1. flatten, 2. 把字符串转成text节点.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">normalizeChildren</span> (<span class="attr">children</span>: any): ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isPrimitive</span>(children) <span class="comment">// 判断children的类型是否string, number, symbol, boolean</span></span><br><span class="line">    ? [<span class="title function_">createTextVNode</span>(children)]</span><br><span class="line">    : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)</span><br><span class="line">      ? <span class="title function_">normalizeArrayChildren</span>(children)</span><br><span class="line">      : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果children直接是字符串, 那就返回一个只含一个text节点vnode的数组. 否则进行<code>normalizeArrayChildren</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeArrayChildren</span> (<span class="attr">children</span>: any, nestedIndex?: string): <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">let</span> i, c, lastIndex, last</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    c = children[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(c) || <span class="keyword">typeof</span> c === <span class="string">&#x27;boolean&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line">    lastIndex = res.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    last = res[lastIndex]</span><br><span class="line">    <span class="comment">//  nested</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里的效果其实也是flatten</span></span><br><span class="line">        c = <span class="title function_">normalizeArrayChildren</span>(c, <span class="string">`<span class="subst">$&#123;nestedIndex || <span class="string">&#x27;&#x27;</span>&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isTextNode</span>(c[<span class="number">0</span>]) &amp;&amp; <span class="title function_">isTextNode</span>(last)) &#123;</span><br><span class="line">          res[lastIndex] = <span class="title function_">createTextVNode</span>(last.<span class="property">text</span> + (c[<span class="number">0</span>]: any).<span class="property">text</span>)</span><br><span class="line">          c.<span class="title function_">shift</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="property">push</span>.<span class="title function_">apply</span>(res, c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPrimitive</span>(c)) &#123; <span class="comment">// 这个分支和simple normalize 一样</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isTextNode</span>(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="comment">// this is necessary for SSR hydration because text nodes are</span></span><br><span class="line">        <span class="comment">// essentially merged when rendered to HTML strings</span></span><br><span class="line">        res[lastIndex] = <span class="title function_">createTextVNode</span>(last.<span class="property">text</span> + c)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// convert primitive to vnode</span></span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title function_">createTextVNode</span>(c))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isTextNode</span>(c) &amp;&amp; <span class="title function_">isTextNode</span>(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        res[lastIndex] = <span class="title function_">createTextVNode</span>(last.<span class="property">text</span> + c.<span class="property">text</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// default key for nested array children (likely generated by v-for)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isTrue</span>(children.<span class="property">_isVList</span>) &amp;&amp;</span><br><span class="line">          <span class="title function_">isDef</span>(c.<span class="property">tag</span>) &amp;&amp;</span><br><span class="line">          <span class="title function_">isUndef</span>(c.<span class="property">key</span>) &amp;&amp;</span><br><span class="line">          <span class="title function_">isDef</span>(nestedIndex)) &#123;</span><br><span class="line">          c.<span class="property">key</span> = <span class="string">`__vlist<span class="subst">$&#123;nestedIndex&#125;</span>_<span class="subst">$&#123;i&#125;</span>__`</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实贴代码前已经总结过了: flatten数据结构使之成为一层的vnode的数组. 把render手写的string转成text vnode. 附带了一些把邻近的text节点合并的业务.</p><p>结论: 通过了normalize, children已经全部成为<code>[vnode, vnode, …]</code>的形式了.</p><p>接下来是createElement的核心代码.</p><h3 id="返回vnode"><a href="#返回vnode" class="headerlink" title="返回vnode"></a>返回vnode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// tag是string</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag) <span class="comment">// 如果有旧的取旧的, 没得就获得, 用来判断svg或者math</span></span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123; <span class="comment">// case: 是平台相关的标签(div, span)</span></span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>( <span class="comment">//</span></span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children, <span class="comment">// 这个config.parsePlatformTagName的具体内容是: _ =&gt; _ 是什么就返回什么.</span></span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// resolveAsset: 如果有 options.components[tag], 就返回他, 也就是返回了一个component</span></span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      <span class="comment">// 对这个情况在后面做处理~ 这里先正常返回, 也就是未知标签</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    <span class="comment">// 另一种语法: 直接传component options的情况, 用component options 创建子component, 这里的tag是component options</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里根据tag分为4个情况:</p><ol><li>tag是标准html标签. (div, span, img等)</li><li>tag是已经被注册在$options.component中的组件名. (比如’comp’, 在实例中有components: {comp: {template: ‘…’}})</li><li>tag是未知标签, 又没有被注册过.</li><li>tag不是字符串, 直接是component的构造函数.</li></ol><p>case1和3都进行了相同的操作: <code>new VNode(tag, data, children, undefined, undefined, context)</code>. 看了VNode, VNode这个类本身没什么方法, 只是储存着一些数据罢了, 构造方法里也只是把各个参数保存到实例的属性里. (这里也不贴代码使版面混乱了)</p><p>case2和4进行了另一个类似的操作: <code>createComponent(tag, data, context, children)</code>(在case2的时候多穿了个tagName).</p><p>总结: 在render函数的tag为非组件的时候, createElement返回一个VNode.</p><h3 id="createComponent"><a href="#createComponent" class="headerlink" title=".createComponent()"></a><code>.createComponent()</code></h3><p>首先确定的是: 这个方法最后返回的是一个VNode.</p><p>代码比较多, 功能比较杂, 简单地过一下看得懂的, 并确定这个返回的VNode中带了哪些信息.</p><ul><li>处理了data里的<code>v-model</code>. (众所周知v-model是个语法糖, 根据是否配置来转化为props和emit)</li><li>处理了functional组件.</li><li><code>installComponentHooks</code>. 给组件安装上属于组件的生命周期, 有init, prepatch, insert, destroy. 类似于重载生命周期方法, 因为在写好的方法里调用了options里的生命周期.</li></ul><p>最后new一个VNode:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>这里比其他地方多的是, 传了<code>ComponentOptions</code>, 注释中看到这是ssr相关的.</p><p>总结: createComponent也只是返回了一个VNode, 但现在看得太粗, 组件相关的实现应该需要仔细看这里, 现在先跳过.</p><p>那么其实render函数主要就是把options里的render函数塞到一个VNode里并返回, 交给patch处理.</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>据说vue3.0改写了这部分, 所以想看的欲望减少了.(为懒找了借口)</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用一千元买到iphoneXs</title>
      <link href="/2018/10/10/how-to-buy-an-iphonexs-with-1000-rmb/"/>
      <url>/2018/10/10/how-to-buy-an-iphonexs-with-1000-rmb/</url>
      
        <content type="html"><![CDATA[<p>当有一个很想买却觉得太贵的东西的时候, 我们应该如何处理, 我来说说我的想法.</p><span id="more"></span><p>我已经在很长一段时间被欲望所折磨, 十一里去苏州西山玩了几天, 环岛摩托都是沪a宝马杜卡迪的公升车, 我心态彻底崩了, 那么在上海开车要增加车辆选择权的话必不可少的是牌照, 于是思考了一些问题.</p><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>已经近3个月没写博客, 因为换了新工作, 疲于业务(因为没有需求的公司不会招人的), 感觉自己在卖时间换钱, 也是在江湖漂水平又差不得已, 忙得没时间学习就导致脑子一包草.</p><p>其实也不是没有收获, 包括之前的rn, 现在的小程序, 但是没有时间去整理(其实是没有值得整理的有价值的东西).</p><p>忙+没精力+技术档次比较低, 这个作为博客那么久不更的原因, 也算作提醒自己很久没有进步了.</p><p>下面进入正题, 思考价格问题是因为购买摩托沪c拍照的欲望快速上升, 我也许很久没有这么想买一个东西了, 那么接下来开始谈谈我对物价的看法.</p><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>本文的定位是, 关于物价的简单思考. 之前因为是个孩子, 赚得少用得少, 眼界短, 对经济毫无认识, 所以现在的看法也是毫无根据的思考, 之后应该会对这方面的东西进行一定的学习.</p><p>任何思考都需要带着问题来找答案, 所以摩托拍照作为例子来分析了, 我的目标牌照是摩托黄牌沪c, 简单说一下价格, 15年初2万, 15年末4万, 16年末6万, 17年末10万, 18年中7万.</p><p>于是我关注了每天牌照买卖信息, 最近两天每天跌一千, 交易量变大, 所以开始思考这代表了什么.</p><h2 id="交易量代表什么"><a href="#交易量代表什么" class="headerlink" title="交易量代表什么"></a>交易量代表什么</h2><p>基础的问题是: 价格下跌, 交易量增大, 我是否应该买入?</p><p>其实之前对交易量一直没有概念, 这是一个仔细思考交易量意义的时机.</p><p>先来讨论下什么情况会产生交易: 那牌照打比方, 卖家认为6.5价格愿意出手, 买家认为6.5可以入手, 那么这笔交易就达成了. 所以根本上来说, 是买卖双方意见产生分歧而导致了交易行为. 所以交易量大, 代表了买卖双方分歧大. 那么作为买方, 应该去猜测卖方买空的原因, 再进行合理的买入.</p><p>所以我没有得出是否应该买入的结论, 但是我们可以根据交易产生的原因进行一些推测.</p><h2 id="意愿模型"><a href="#意愿模型" class="headerlink" title="意愿模型"></a>意愿模型</h2><p>之前得出交易行为是双方意见的分歧, 其实这个偏向于炒作价格, 在牌照交易中, 还存在真实需求的问题. 综合一下, 我把交易产生的原因总结为:<strong>双方意愿的和达到某个程度就产生了交易.</strong></p><p>那一定会产生一个情况: 某个东西买卖双方都认为价格过低了会产生什么情况? 卖方当然不愿意卖了, 所以价格会上升, 来平衡双方的意愿. 反之亦然.</p><p>虽然说反之亦然, 其实价格下跌倒是值得研究的情况, 价格下跌可以说是清除泡沫的过程, 一件物品的价值可以分成”实际作用”和”价格预期”两个部分, 拿牌照做比, 现在牌照6.5万, 实际作用是可以计算的: 外地牌照只是比沪牌多了2个问题: 1. 每年验车的路程和时间(其实就是拿出一天做个摩旅). 2. 如果被抓有可能会遣送会原地, 也就浪费一天时间和千把块钱. 这点钱乘以概率绝对不足5千. 所以如果摩托牌照泡沫破除也就是五千的价格了.</p><h2 id="意愿不等同于价值"><a href="#意愿不等同于价值" class="headerlink" title="意愿不等同于价值"></a>意愿不等同于价值</h2><p>但很明显, 虽然算出了验车或出了事故的成本并不高, 但还有一个问题是担心受怕和经济问题. 如果我经济很宽裕, 我愿意30万买个沪a的. 所以价值不等同于意愿, 这也是现在房价是天价的原因.</p><p>现在问题走到了: 价格是买卖意愿产生的, 我只要保证买方的意愿足够, 就能保证价格不会下跌得太多.</p><p>于是在各个平台看到很多谩骂牌照价格的人, 还有一些人放假消息, 说牌照即将开放. <strong>这些人看来是在做空, 其实正是他们提高了牌照的价格</strong>, 他们把自己的意愿表现出来, 别的人自然感受到牌照只要降低价格总有人要, 买入的意愿就增强, 价格就提高了.</p><h2 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h2><p>意愿高低决定价格, 本质就是供求关系决定价格, 这里的供求就是指有意愿买&#x2F;卖的人的数量. 所以总结一下市场的特点, 利用市场的规律, 我们就可以做到: 买更值得的东西, 获得更高的利润. 指出两点:</p><ul><li><p>市场是公平的, 因为没有强迫手段, 市场是双方意愿达成的, 交易双方都是自愿的.</p></li><li><p>实际价值不等同意愿, 这就是广告, 推销存在的意义, 改变人的意愿, 就能改变物品的市场价格(注意并没有改变物品的价值). 广告和推销的目的是提高意愿, 注意这和成本无关, 也就是成本10元的东西, 只要没人愿意买, 他就可能1元, 2元被卖出去.</p><p>只要意愿足够, 价格也会提高, 比如演唱会票价是有国家调控(限制票价)的, 但买演唱会票本身是市场行为, 所以产生了黄牛, 所以黄牛是市场的一个环节.</p></li></ul><p>既然市场是由意愿组成的, 那么意愿除了被广告洗脑, 是否也有实在的硬的原因呢? 我猜想意愿的理性成分是由一些东西组成的:</p><ul><li><strong>实际需求</strong>: 实际需求指的是衣食住行的真正被需要的东西. 比如粮食少了, 价格就一定会抬高, 而不需要任何广告. (摩托牌照其实是有实际需求部分的, 摩托很明显是出行最舒服的方式了).</li><li><strong>精神需求:</strong> 这部分需求也是很实际的, 只是非物质. 但指的是真是的精神需求, 而不是冲动. 拿牌照举例, 真是的精神需求是, 害怕被警察抓, 而不是觉得有牌照很帅.</li><li><strong>购买力与剩余资本:</strong> 有购买力是基本的, 所以价格也与购买力直接相关, 拿&lt;&lt;我不是药神&gt;&gt;举例, 就算设计声明, 购买力不足依旧不能产生交易. 从另一面来说, 购买力如果剩余, 交易价格也会上升, 因为交易对象会产生资本性质, 举例是房价, 因为房子保值(是没房的人的刚需, 又是大价值物件). 之前我得过结论, 通货膨胀平均是每年10%, 也就是剩余的钱10万明年就变成9万, 这也是一些可以保值的东西上涨飞快的原因, 社会的剩余资本会集中到这些”可以成为资本”的物品上, 换句话说, 以这个性质而产生的意愿的前提是当前社会有大量剩余资本.</li></ul><h2 id="如何用1000买到iphoneXs"><a href="#如何用1000买到iphoneXs" class="headerlink" title="如何用1000买到iphoneXs"></a>如何用1000买到iphoneXs</h2><p>作为结论环节, 先来说自己得到的结论: 首先买东西分为两种: 消耗品和非消耗品. 我的结论的前提是非消耗品.</p><p><strong>购物的价格分为几个部分:</strong></p><ul><li>实际部分: 缺少了这个东西会对生活造成影响. 在满足社会生产大于需求的情况下, 物品一定高于这个售价. 这个部分与马洛斯需求理论层次同步, 在越高的需求层次, 需求的东西也越多. (根据我之前的分析, 几乎每个人都几乎都在最高层) 这也解释了为什么医药费那么贵大家也愿意付.</li><li>精神需求部分: 因为炫耀&#x2F;怕麻烦&#x2F;冲动等产生的购物需求. 这是我认为钱足够才去买的部分, 比如摩托车, 化妆品, iphone手机等, 这些明显会快速贬值, 并且只在购买的短时间内有快感.</li><li>剩余资本部分: 因为社会剩余资本过多, 如果不购买就会被贬值, 但这部分价格会根据社会发展情况变化.</li></ul><p>所以<strong>什么值得买?</strong> 第一, 必需品. 第二, 保值品. 第三, 占收入比例很少的东西随便买, 因为存款会贬值.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git操作总结</title>
      <link href="/2018/07/31/git-op-summary/"/>
      <url>/2018/07/31/git-op-summary/</url>
      
        <content type="html"><![CDATA[<p>昨天在工作中需要把一个commit提交到另外一个比较老的分支上, 在解决问题以后决定对git操作进行整理, 之前的git操作有点随意了.</p><span id="more"></span><p>这次的整理的方式是: 以日常开发经常做的操作为线索, 逐个整理操作方式. 于是从新建一个repo开始, 然后在多处操作就当模拟多人开发了.</p><p>本文在每个问题(每个标题)下会先写最简单的写法, 再使用<code>别的做法</code>为标签来写不是最简便的方法, 并做一些简单解释.</p><p>我在本地创建了2个文件夹, 作为2个工作空间, 来模拟推&#x2F;拉&#x2F;冲突&#x2F;分支等操作.</p><p><strong>奉上<a href="https://git-scm.com/docs">原始资料: git手册</a></strong></p><h2 id="建立版本库"><a href="#建立版本库" class="headerlink" title="建立版本库"></a>建立版本库</h2><p>在github上新建了一个repo. 把版本库拖到本地.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:cwj0417/gitop.git ./</span><br></pre></td></tr></table></figure><p><code>./</code>这个参数代表在当前目录建立, 默认是新建一个同名文件夹.</p><p><strong>别的做法:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:cwj0417/gitop.git</span><br></pre></td></tr></table></figure><p>在当前文件夹下建立了repo, 并添加一个远程仓库, 配置远程仓库的本地名字(origin)和地址. 现在的状态使用<code>git remote -v</code>可以看到remote的状态. 前面的<code>git clone</code>是快捷做法.</p><p>顺带一提, 如果项目较大又只需要最新代码, 可以加上参数来减少拉取的代码. <code>git clone &lt;repo&gt; --depth 1</code>.</p><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>在做出更改之后, 把文件添加到工作区, 并提交到本地repo.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;first commit&#x27;</span><br></pre></td></tr></table></figure><p><code>git add</code>后面的<code>.</code>代表添加所有工作区的变化到stage.</p><p>当然这个<code>.</code>可以改成文件名或者文件夹, 来分批commit改动.</p><p><strong>别的做法:</strong></p><p>如果改动的文件只是修改了内容(没有产生create或者delete). 可以省去<code>git add</code>, 在commit的时候加参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &#x27;modify: develop&#x27;</span><br></pre></td></tr></table></figure><h2 id="推送代码到远端"><a href="#推送代码到远端" class="headerlink" title="推送代码到远端"></a>推送代码到远端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>就搞定了. <code>git push</code>的语法很复杂, 只是因为我们当前只有一个分支简化了语法.</p><p><strong>别的做法:</strong></p><p>例子中的repo是新建的, 所以只有一个追踪分支, 如果有多个, 就要用完整的语法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure><p>解释: origin代表远程主机名字, 因为一个repo可以有多个远程主机. 表示对这个远程主机进行操作.</p><p>master:master 把本地的master分支推到远程的master分支, 相同分支名可以简化为master.</p><p>那么在多个分支下如何追踪分支呢?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/master</span><br></pre></td></tr></table></figure><p>解释: 把本地的master追踪到 origin为本地名字的远程分支 的master分支.</p><p>那么可不可以在多分支的情况下至输入<code>git push</code>呢</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这样设置了默认分支, 下次直接<code>git push</code>就行了.</p><h2 id="从远端获取到代码"><a href="#从远端获取到代码" class="headerlink" title="从远端获取到代码"></a>从远端获取到代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>如果没有追踪分支, 那么就需要:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:master --rebase</span><br></pre></td></tr></table></figure><p>和push的原理一样, 只是这里的<code>master:master</code>的方向与push相反, 是&lt;远端分支&gt;:&lt;本地分支&gt;. 当然如果分支名一样就可以简写成<code>master</code>.</p><p>当然也可以和push一样追踪分支. 代码一样不重复写了.</p><p><strong>别的做法:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge</span><br></pre></td></tr></table></figure><p>以前听了同事的一个说法, 不要pull, 很危险. 现在明白了以后觉得直接pull没有任何问题, 估计这个说法也是以讹传讹. 意思只是: merge是会改变工作区的指令. 明白pull会改变工作区就行了, 只是一个快捷操作. 如果怕出问题, 可以先commit到本地repo, 如果出了很难解决的冲突直接reset就行了, reset操作会在后面说.</p><p><strong>搞笑的做法:</strong></p><p>之前一直不知道rebase, 那么就很有意思了, 我是这样做的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>哈哈. 这样来避免产生merge commit. 对了之前没说, <code>--rebase</code>参数是这个作用.</p><p><strong>如果产生了冲突:</strong></p><p>手动修改好冲突以后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;resolved conflict&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>就可以. 也可以把commit替换为<code>git rebase --continue</code>, 如果想把工作区状态回到rebase前, 可以执行<code>git rebase --abort</code>.</p><h2 id="撤回代码"><a href="#撤回代码" class="headerlink" title="撤回代码"></a>撤回代码</h2><p>发生错误在所难免, 这个部分说一下发生了非预期的提交应该怎么做.</p><h3 id="查看历史commit"><a href="#查看历史commit" class="headerlink" title="查看历史commit"></a>查看历史commit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>在发生问题的时候就体现出了commit的重要性, 所以可以在工作流里加上commit钩子来验证commit内容.</p><p>那么如果想看每个提交的改动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>或者查看代码的具体改动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>那串很长的东西就是commit号, 作为操作依据.</p><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>回滚动作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>这里的<commit>号可以是那串很长的东西, 也可以是: <code>HEAD</code>, 代表最近的提交, 或是<code>HEAD^</code>, <code>HEAD^^</code>以此类推, 代表倒数x次的提交.</p><p>效果:</p><p>把commit重置到目标节点, 工作区代码不变. 也就是<strong>回到写好代码, 但没有add和commit的状态</strong>.</p><p>当然也可以把工作区代码也被撤销. 但是算敏感操作, 因为工作区代码撤销就等于删除了目标commit之后的工作代码. 只要加个参数.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>另外还有个参数<code>--soft</code>, 作用是把工作区变成已经add但没有commit的状态.</p><p>顺带一提还有一个参数<code>--mixed</code>是默认参数, <code>git reset &lt;commit&gt;</code>没有加参数就是这个效果.</p><p><strong>回滚以后的效果:</strong></p><p>首先要明白这个操作回滚的是本地repo, 所以reset以后就变成了退回版本而导致落后远端版本, 就意味着需要fetch和merge才能继续提交, 和远端代码(之前错误提交的代码)如果有不同还需要解决冲突.</p><h2 id="回滚已经提交的内容"><a href="#回滚已经提交的内容" class="headerlink" title="回滚已经提交的内容"></a>回滚已经提交的内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>效果和手动该文件一样</p><h2 id="建立新分支"><a href="#建立新分支" class="headerlink" title="建立新分支"></a>建立新分支</h2><p>现在单分支的多人合作的基本流程已经差不多了, 下面的部分来看看常用的分支操作.</p><p>场景是如果要进行容易出错的功能, 或是对某个发布的公司做出特别的改动, 就需要新建分支.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt;</span><br><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><p><code>git checkout -b &lt;branch&gt;</code>是在本地建立分支, <code>git push origin &lt;branch&gt;</code>是把新建的分支推到远端.</p><h2 id="拉取-x2F-切换到新分支"><a href="#拉取-x2F-切换到新分支" class="headerlink" title="拉取&#x2F;切换到新分支"></a>拉取&#x2F;切换到新分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure><p><code>git fetch</code>是拉取远端代码, <code>git checkout &lt;branch&gt;</code>是切换分支.</p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>在功能开发完成以后就要把功能分支合并到主要开发分支上了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge &lt;branch&gt; --no-ff</span><br></pre></td></tr></table></figure><p><code>git checkout master</code>切换到master分支, <code>git merge &lt;branch&gt;</code>将<branch>的代码内容合并到master. <code>--no-ff</code>会使合并产生一个节点, 可以方便查错.</p><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>在大版本节点或是发布点打标签可以方便回滚(滑稽).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag &#x27;tag-name&#x27;</span><br><span class="line">git push origin --tags // push所有标签</span><br><span class="line">git push origin &#x27;tag-name&#x27; // push单个标签</span><br></pre></td></tr></table></figure><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>这个场景是用在要临时加急发布一个功能, 或是本来需要发布的功能之后又被提交了代码的情况.</p><p>这个时候一般develop分支上有n个commit, 原先发布的动作可能是: 把分支切到master, merge develop. 但是现在不能把这n个commit全merge了, 只能选择某些commit来merge.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>这样做会产生一个cherry-pick的commit, 没有什么毛病, 但是如果要cherry-pick多个commit, 想一次性commit, 可以加上<code>-n</code>的参数来避免自动commit.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次工作大变动</title>
      <link href="/2018/07/24/how-to-face-work-related-anxiety/"/>
      <url>/2018/07/24/how-to-face-work-related-anxiety/</url>
      
        <content type="html"><![CDATA[<p>工作出现了大变动, 需要去离家32公里的地方上班, 而处于对同事的感情又不舍得直接离职. 矛盾就会导致焦虑, 于是导致了身体出现了很多小问题. 于是看了一本书来学习如何调整心态, 本文大部分是作为读后感的. 其他会写一下最近看的类似的文章和发生的触动自己的事情.</p><span id="more"></span><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>先来说说最近我身上发生了哪些不愉快的事.</p><ul><li>我的摩托车骑了1500公里已经倒地2次, 箱子摔烂了2个.</li><li>我的摩托车骑了1500公里发生一次事故, 争论了大概一个半小时. 经过了朋友帮忙才赔付了合理价格.</li><li>工作产生调动, 舒适感被打破.</li><li>摩托车后轮被扎. 从发现到修车无奈还带了人骑了30公里车胎烫炸, 心疼车胎.</li><li>开始胃疼. (之前胃镜结果不是很好)</li><li>与胃疼出于一个原因(副交感神经紊乱)导致头疼, 胸闷, 半身出汗, 神经性皮炎.</li></ul><p>这一串事情其实相互有关联: 状态不好, 所以心情&#x2F;身体&#x2F;行为的恶性循环就开始了.</p><p>其实我自己一直认为没有什么大不了的事(事实也确实如此), 但是身体的诚实的, 身体出现了问题.</p><p>于是我看了一本书叫<code>你的生存本能正在杀死你</code>. 另外看了朋友推荐的文章<code>不要自称是程序员，我十多年的 IT 职场总结</code>. 总结了一些感受, 很多感受与书的主题无关, 在此做下记录与总结.</p><h2 id="什么是副交感神经紊乱"><a href="#什么是副交感神经紊乱" class="headerlink" title="什么是副交感神经紊乱"></a>什么是副交感神经紊乱</h2><p>人的神经系统分为交感神经和副交感神经(植物神经), 交感神经控制意识和紧急状况处理, 植物神经控制平静时候的不随意的肌肉. 人在判断危险的时候交感神经会兴奋来保证自身安全, 交感神经过于兴奋导致副交感神经功能紊乱了.</p><p>也就是人在本能地感到危险的时候会发生紊乱. 那么被植物神经控制的心跳&#x2F;呼吸&#x2F;肠胃蠕动&#x2F;肌肉跳动就开始紊乱了. 神经紊乱导致胃病的基本原理是: 胃蠕动过快, 分泌更多的胃酸, 导致伤害胃粘膜, 导致各种胃&#x2F;十二指肠炎症和溃疡.</p><p>当然这些病长时间持续会有更厉害的变化, 所以要及时调整心态.</p><h2 id="一些现在常见的现象"><a href="#一些现在常见的现象" class="headerlink" title="一些现在常见的现象"></a>一些现在常见的现象</h2><p>从这里开始是书里讲到的, 书里讲到21世纪的特点: 社会稳定, 经济发达, 娱乐便利. 几乎是一个非常好的时代, 但却不被承认. 来说一些这个时代经常有的现象:</p><ul><li>下定决心减肥, 并做足功课, 最后还是失败, 或是成功以后一放松就回到原先的体重.</li><li>经常忍不住地看手机, 检查消息和朋友圈, 或是其他的回复.</li><li>在做”重要不紧急”的事的时候(比如看书学习), 就忍不住拿出手机&#x2F;打开网页来做娱乐的事.</li></ul><p>还有另外一部分行为类别, 他们的特点是短时间解决问题, 引起长期的更大问题(这个叫做”坏习惯”, 之后会展开解释):</p><ul><li>借酒消愁.</li><li>经常感到无聊, 好玩的东西越来越少.</li><li>需要看手机&#x2F;玩游戏&#x2F;看电视以后才能安心睡觉.</li><li>拉肚子的时候不敢出门害怕找不到厕所, 而越害怕就越需要找厕所.</li></ul><p>另外一个是我们会对不是很大的事情做出很大的反应(不适阀值降低):</p><ul><li>哪里疼了就百度, 然后越想越觉得自己得了癌症.</li><li>被插队就非常生气.</li><li>一言不合就愤怒.</li></ul><p>我相信每个人或多或少都有这些现象的影子, 并且自己也知道在做错的事情, 我最近有几天就沉迷淘宝和小程序游戏, 看着也舒服, 时间一下子就过去了, 精力没了, 成果没的. 每天下午醒过来想喝奶茶, 但是不想喝水, 这算是典型的例子了.</p><p>那么这些问题的原因是什么, 如何解决. 在下面几个部分来展开.</p><h2 id="这些现象生物基础"><a href="#这些现象生物基础" class="headerlink" title="这些现象生物基础"></a>这些现象生物基础</h2><p>这本书好像是个医生写的, 很多地方都提及了一些专业的东西. 看的时候比较仔细就没做笔记, 我来说两个书中提及的基本原理.</p><h3 id="大脑结构分层"><a href="#大脑结构分层" class="headerlink" title="大脑结构分层"></a>大脑结构分层</h3><p>这个理论把大脑分为了3层.</p><ul><li>小脑: 爬行脑, 这个脑在x年前就存在了, 也就是最低级的脑子, 他负责人的呼吸&#x2F;心跳等无意识行为. 在我很小的时候就听过一些例子如: 学自行车时是大脑在学, 然后小脑记住了, 学会以后骑自行车的动作是小脑控制的.</li><li>大脑边缘系统: 在小脑上面的一块大脑. 这块大脑是控制人的情绪的, 我们上面的例子所感受到的不适&#x2F;愤怒&#x2F;无聊就是这块脑子在控制了.</li><li>大脑皮层: 这个部分是只有人类最发达的部分, 也就是人类和别的动物不同的地方, 具有思考&#x2F;语言&#x2F;逻辑等高级功能的地方. 我小时候也听说过一个讲法, 大脑皮层的沟越深人越聪明, 爱因斯坦的脑子被解剖发现他大脑皮层摊开以后面积超大.</li></ul><p>那这三层脑子和这些现象的联系在哪里呢.</p><p>主角是大脑边缘系统和大脑皮层. 与小脑不同, 大脑边缘系统是有思考能力的: 比如想吃东西&#x2F;想玩游戏&#x2F;想喝酒. 下面举一个例子.</p><p>看到了一堆甜食, 大脑边缘系统: 大量能量, 可以维持很久生命, 能吃多少吃多少, 储存成脂肪作为灾备. 大脑皮层: 现在的社会已经能确保每天有充足的食物了, 过多囤积只会导致各种疾病, 没有饿就不吃东西.</p><p>那么大脑边缘系统和大脑皮层谁更强呢? 不经过锻炼的人都是大脑皮层较弱, 也就是本能会战胜理智. 最后明明知道不好, 也选择了吃喝&#x2F;玩游戏.</p><h3 id="多巴胺"><a href="#多巴胺" class="headerlink" title="多巴胺"></a>多巴胺</h3><p>这个名字应该非常熟悉了. 人觉得开心舒服就是大脑在分泌多巴胺. 在吃东西的时候, 获得成就的时候等. 也就是大脑对某些事情的奖励机制, 那我们需要研究的就是: 如何让多巴胺分泌得多. 因为分泌得多我们就快了.</p><p>这本书的观点是: 多巴胺在获取过程里分泌得多, 并且对新的事物反应更灵敏. 也就是吃巧克力蛋糕的时候, 快吃到的瞬间是最快乐的, 吃得越多快乐越少.</p><p>这个观点我非常同意了, 吃饭的第一口是最香的.</p><p>所以推论就是, 人需要获得快乐, 就需要不断的接触新事物并取得成就. 重复使用一个方法快乐会降低. 这是生物基础决定的.</p><h2 id="好习惯与坏习惯"><a href="#好习惯与坏习惯" class="headerlink" title="好习惯与坏习惯"></a>好习惯与坏习惯</h2><p>书中成为”适应良好的习惯”和”适应不良的习惯”, 如何理解呢?</p><p>以减肥为例. 大多数肥胖是如何形成的: 习惯性吃东西. 很明显这就是”坏习惯”. 那么这个坏习惯是如何产生的:</p><p>第一步, 在心里不舒服的时候想获得快乐, 发现吃东西可以获得快乐, 于是选择吃东西了.</p><p>第二步, 第二次希望得到快乐的时候也选择了吃东西, 但是吃和上次一样的已经不够了(上面的多巴胺分泌量理论), 所以要吃两份.</p><p>第三步, 每次都吃得更多才能获得到对应的快乐.</p><p>第四步, 无法自拔, 变成肥胖.</p><p>也许大多人(我直到现在才仔细感受)都认为自己吃东西就是饿了. 那么可以下次吃东西前仔细考虑是不是真的饿了, 甚至早中午饭都不一定饿, 因为那是人的习惯而已.</p><p>再举一例来证明: 现在奶茶横行, 为什么人渴的时候不买水, 而买奶茶呢. 大脑皮层都知道奶茶是对身体不好的.(自己制作的奶茶就很难喝了, 因为奶茶让人舒服的地方就是糖). 所以买了奶茶而不买水的原因就是希望获得快乐. (原因参考大脑边缘系统战胜大脑皮层). 最后形成了喝奶茶的坏习惯.</p><p>以吃东西&#x2F;喝奶茶为例, 类似的还有吃安眠药&#x2F;喝酒等. 来总结坏习惯的定义: 为了获得快乐或克服恐惧(安眠药&#x2F;喝酒)而采取的措施从长期来看是有害的, 并且每次效果递减.</p><p>那么什么是好习惯呢? 开车时转向打等, 有突发情况下意识踩刹车, 就是好习惯. 好习惯是无害, 并能解决问题的.</p><p><strong>好习惯与坏习惯的根本差别</strong>是: 坏习惯是依赖外部的. 举一个简单的例子: 普通的感冒过一周就会自愈, 如果为了提早好吃了药, 每次都得吃药, 每次效果都越差, 对身体又不好, 抗生素依赖导致死亡的例子太多. 这就是坏习惯的形成.</p><h2 id="现代的哪些元素降低了我们的不适阀值"><a href="#现代的哪些元素降低了我们的不适阀值" class="headerlink" title="现代的哪些元素降低了我们的不适阀值?"></a>现代的哪些元素降低了我们的不适阀值?</h2><p>这个主题是为了引出另外一个观点: 人要懂得拒绝信息.</p><p>现代的元素使人产生负面情绪的因素分为两大类:</p><h3 id="便利"><a href="#便利" class="headerlink" title="便利"></a>便利</h3><p>说一个小故事, 我高中的时候因为手机不好还是什么情况, 在朋友家门口的烈日下等了2小时. 然后回家, 因为无法联系.</p><p>现在想要知道一样东西, 拿出手机百度, 搞定. 以前: 图书馆翻阅资料, 查找分类, 等查到想要的东西得至少花大半天.</p><p>以前买东西要想哪儿有店, 怎么去. 现在淘宝不谈了.</p><p>(等等等, 好像都是信息科技搞的鬼.)</p><p>过于的方便加大了我们对方便的预期, 所以降低了不适的阀值. 高中的时候有同学从邮政买东西, 等一个星期, 期待地等到很开心, 现在淘宝买东西2天没到已经打电话投诉并生气了.</p><p>便利导致不适就是上文所说的, 是靠外界的东西获得的快乐, 越容易获得的快乐越会让人降低不适阀值.</p><h3 id="信息暴力"><a href="#信息暴力" class="headerlink" title="信息暴力"></a>信息暴力</h3><p>先来说一个场景: 电视到广告的时候我特意去做别的事情来节约时间, 或是与朋友聊天. 现在的网络广告还可以静音.</p><p>但很可惜的是, 我们仍能记住广告的内容. 我们现在还记得佳洁士&#x2F;乐事&#x2F;洁云&#x2F;立白的广告词.</p><p>这里要介绍一个新观点: 信息不必通过大脑皮层(不经过思考)就可以被记住. 只要看到&#x2F;听到的东西就会直接被记住. 所以广告算是一种信息强暴. 我认识的销售朋友也经常有这种话术: 不带逻辑地直接告诉你结论, 然后我就被洗脑了. </p><p>那么信息是如何不经过大脑皮层就被记住的呢. 答案是: 经过了大脑边缘系统.</p><p>我们知道的是, 大脑边缘系统是没逻辑能力的. 大脑边缘系统喜欢的是: 生存. 比如吃, 逃战. 等保护自己的东西. 所以话术与广告是直接与你大脑边缘系统对话的, 这是非常肮脏的行为.</p><p>举例子: 奥妙洗衣粉: 孩子碰到了个东西, 广告里画个放大镜, 画一些很恶心的东西说是细菌. 通过让人感到威胁的东西来激活与大脑边缘系统的沟通. 然后说奥妙可以解决. 于是奥妙穿过大脑皮层进入了你的脑子. 在买洗衣粉的时候, 大脑知道广告不代表什么, 但你最后还是买了奥妙, 因为是大脑边缘系统做的决定, 正如你最终还是吃了奶油冰激凌.</p><h2 id="焦虑等于压力"><a href="#焦虑等于压力" class="headerlink" title="焦虑等于压力"></a>焦虑等于压力</h2><p>这是这本书的有意义的前提, 使我们难受的是焦虑, 不是压力, 经过合理科学的锻炼, 做到在较大的压力下也能感到较少的焦虑, 甚至开心. 而不是较小的压力感受到很大的焦虑, 甚至变成病态. </p><h2 id="书的结论"><a href="#书的结论" class="headerlink" title="书的结论"></a>书的结论</h2><ul><li>快乐与难过是相对存在的. 有难过才有快乐.(所以要自找苦吃, 自己找的苦是可控制的, 环境给的苦是不可控的)</li><li>不借助外部的获取快乐的方式更持久, 并且没有副作用.(副作用经常是非常可怕的)</li><li>信息可以直接与大脑边缘系统交互(通过引起本能反应的东西害怕&#x2F;恶心&#x2F;色情). 所以就算不信也要控制信息的摄入(因为广告&#x2F;公众号&#x2F;微博等经过演绎的文章都是利益驱动, 所以大部分都是害人的信息).</li></ul><p>下面来说说文章的内容.</p><h2 id="梦醒回到现实"><a href="#梦醒回到现实" class="headerlink" title="梦醒回到现实"></a>梦醒回到现实</h2><p>来说说程序员这个职业.</p><p>职业门槛说低, 工资不低足够证明是有门槛的.</p><p>职业门槛说高, 百分之80的程序员都是垃圾. (并且高级程序员还在不断给自己造护城河, 表现就是低级程序员门槛的降低, 但是更难达到中高级.)</p><p>程序员的目标也分两种, 一种是为了工资来的, 一种是为了好玩来的.</p><p>当然这是两个极端, 正确的模型应该是. 一部分为工资一部分为梦想, 每个人的比例不同.</p><h3 id="利润中心与成本中心"><a href="#利润中心与成本中心" class="headerlink" title="利润中心与成本中心"></a>利润中心与成本中心</h3><p>一个企业的员工都可以归到这两个部分中, 产生利润的是利润中心, 就是销售. 程序员是不产生利润的, 只是要付工资, 所以是成本中心. 这也是销售赚钱多的原因.</p><p>但程序员为什么工资偏高, 原因也很简单, 产生利润也是要有东西卖的. 其实真正做生产的还是程序员(前提是互联网公司). 这又要提到”有软件开发者的公司”的概念了. 很明显这些公司给程序员的钱是很少的, 当然也只能吸引到刚接触程序半年以内的员工.</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>在公司解散前, 我们也做了不少功能, 现在回头看, 这些功能都毫无意义. 这就是梦醒的过程, 文中有一句话很有道理, 公司雇你来不是让你写好看的代码, 没有bug的代码的, 是用来生产可以卖价钱的东西的. 而程序员一直被哄着(哄到某个精神状态才能写出好产品也是被哄的原因).</p><p>所以:</p><p><strong>做梦的原因:</strong> 程序员这个职业需要特殊的环境才能生产出更有价值的产品. 所以一般老板都会给提供一个看似不求利益只求技术的环境, (甚至还有技术马拉松这种看似纯亏欠让程序员开心的东西)但背后都是有利益驱动的.</p><p><strong>梦醒的原因:</strong> 当老板的计划出现问题, 那么开发的软件全部作废, 甚至需要换工作. 梦醒, 才会明白世界是利益驱动的, 不是漂亮代码驱动的, 任何东西最终要回到利益.</p><p><strong>什么是做梦:</strong> 接黑客与画家的例子: 与利益无关的地方就是做梦的地方, 现实应该是: 谁能生产价值和利益就有更高的地位, 而这些地方并不是: 学校, 贵妇圈.</p><h2 id="文章结论"><a href="#文章结论" class="headerlink" title="文章结论"></a>文章结论</h2><p>不要听信任何表面的东西, 时刻认清自己的价值.</p><p>表面的东西包括期权&#x2F;零食&#x2F;美女&#x2F;放松的环境&#x2F;标配高档生产资料.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>**生活方面: 健康 &gt; 发展 &gt; 钱. ** 因为发展会带来钱. 而健康是最重要的, 无需做任何比喻谁都明白.</li><li><strong>生活方面: 快乐是不需要追求的.</strong> 之前一直把快乐作为第二, 为什么快乐不需要追求, 因为快乐只是相对不快乐, 也就是每个人的快乐总和是一样的, 无论平穷富裕, 一个很久没喝水&#x2F;睡觉的人, 喝到一口水然后睡一觉. 这个快乐程度也许远超过一直有舒适环境的人. 快乐的秘诀其实是自寻较差的条件.</li><li><strong>生活方面: 要意识到你的行为是听从一个不聪明的大脑的.</strong> 像你有两个人格, 你要用聪明的人格来教育或是阻止不聪明的人格做出错误决定. 相对地, 你也可以使用一些话术来直接与其他人的大脑边缘系统对话来直接影响他人行为.</li><li><strong>如何调整状态:</strong> 尽量少依靠外界来获得快乐</li><li><strong>工作方面: 在浪漫之余不要忘记现实, 要做务实有生产的人.</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>六月流水账</title>
      <link href="/2018/07/05/diary-june/"/>
      <url>/2018/07/05/diary-june/</url>
      
        <content type="html"><![CDATA[<p>整个六月都没写博客, 其实可以写的东西有很多, 但是没有心情去写一份博客了, 因为最想写博客的时期是刚学的兴奋的时候, 会稍作整理简单描述.</p><p>六月的心情也不少. 昨天摩托摔了一下, 不轻不重, 产生了不少负面的情绪, 今天给自己调整了下心态, 整理了下想法. 一并记下.</p><span id="more"></span><h2 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h2><p>先说工作方面, 五月的博客有jenkins, chrome拓展, http协议研究. 其实五月最大的工程是做了博客样式的重写. 四月还研究了正则.</p><p>六月在单位项目上花了挺多功夫, 做了个图片弹出层的效果, 和改了很多布局样式. 本来想把图片弹出做一个vue的插件, 后来也烂尾了(项目都没开, 但是做的时候是有强烈的想法). 因为想api的能力和代码组织能力不到位吧.</p><p>另外一只想写2篇博客: 1. rn的总结. 2. vue源码中vdom相关的patch和compile to render的分析.</p><p>2018年初的时候我一只有关于移动端的尝试的博客, 但是没有一篇是rn的. 因为尝试到rn以后太顺了, 开发体验极好. 大概3, 4个月已经有个很像样的版本了, 可以达到web端80%的功能, 基本的开发打包流程也好, 进阶的各种功能的实现也好, 有非常多值得总结的, 懒了, 而且熟练度高的时候也不削写了. 另外vue的源码是没能力写, 每次仔细看源码, 先复习一下, 再继续看一会马上就人很累了. 当然这个事记在todo中, 一定要做的.</p><p>最后在月末, 做了3件事:</p><ol><li>个人项目展示页面, 点击博客上方的”项目”即可进入. (很多烂尾的项目没有写进去). </li><li>记录做了什么的chrome拓展, 名字叫did. (因为翻看博客, 回忆做了什么非常有感触, 然后想了下需求, 把did作为todo的补充, 我会一直使用这个拓展的, yosoro已经用了一年多了, 对我来说使用的项目就是成功的项目).</li><li>我的yosoro, did, vocabook(单词本软件)都是备份在本地或者chrome里的, 我通过调用github api, 做了一个使用gist的备份库, 这样可以使单机应用免费备份了. (看api的同时也对graph ql的印象更深了).</li></ol><p>接下来说感情方面, 六月发生了很多不开心的小事, 都是可以过去就忘掉的无关紧要的事, 但是我也尝试记录分析当时自己的心情.</p><h2 id="为什么设计稿反复改-为什么玩游戏会开心-为什么有的人总说”某某很有钱”"><a href="#为什么设计稿反复改-为什么玩游戏会开心-为什么有的人总说”某某很有钱”" class="headerlink" title="为什么设计稿反复改? 为什么玩游戏会开心? 为什么有的人总说”某某很有钱”?"></a>为什么设计稿反复改? 为什么玩游戏会开心? 为什么有的人总说”某某很有钱”?</h2><p>这个title我想谈的是马斯洛的需求层次理论.</p><p>我对这个理论一直有2个非常大的误解: </p><p>误解1: 只有有钱人(比如马云)才到金字塔顶, 也就是<code>自我实现</code>.  误解2: 人处于的层次是固定的.</p><p>这其实大大的错了, 我们几乎所有人都到达了<code>自我实现</code>这一层. 并且层次不是固定的. 下面来简单解释一下, 具体的也得靠体会.</p><p>误解1, 其实我们几乎都被满足了<code>尊重</code>和<code>社交</code>. 尊重不是别人舔你屁眼, 而是把你当成一个人. 举个不恰当的例子, 路上经常有被压扁的猫猫狗狗, 无人问津, 如果被压死的是人, 那么一定是大事, 这就是尊重. 我一直以为, 我几乎不和人说话, 我没有社交. 错, 上班就是社交, 哪怕一天不说一句话. 家里退休的人会出去找人集会说话, 他们才是缺社交的.</p><p>误解2, 人所处的需求层次是不固定的. 需求层次的意思是: 任何时刻, 达到了下面要求的才会去要求上面层次. 就像开车, 从1档加到5档, 才能在5档开. 刹过车还是得从1档加上来. 举个简单的例子: 突然生大病, 比如胃出血, 觉得头晕了, 去了医院马上输血, 医生开出了病危通知. 此时你的需求层次降到了<code>安全</code>层次, 此时也就对<code>社交</code>, <code>尊重</code>, <code>自我实现</code>都无所谓了. 最简单的解释: 你在病危的时候不会觉得”好无聊, 没事做”, 虽然你在病危的时候是躺在床上没事做的. (下面会提到我的观点: 感觉”无聊”就是在需求<code>自我实现</code>, 说明<code>自我实现</code>以下的需求都满足了.)</p><p>最后来谈谈我对标题问题的观点, 我觉得这些问题都处于这个心理机制: 满足<code>自我实现</code>, 不能<code>无为</code>, <strong>什么都做不了使我焦虑, 所以我必须做点什么.</strong> 但是让人不爽的地方是: <strong>因为do something是需要努力和付出的, 我又不想努力, 所以我选择做一些表面功夫或者归咎到别人身上来虚假地满足<code>自我实现</code>的需求</strong>.</p><p>案例分析:</p><ol><li>设计稿第一稿用不通过: 领导又没把心思真正放产品细节上(真正对的做法是授权给有精力专注细节的人), 又要克服”无为”的焦虑, 所以只能打回重做, 做了10板之后: <code>&quot;还是第一版好, 用第一版吧&quot;</code>.</li><li>玩游戏输了也开心? 游戏通过一些机制, 强行让玩家得到虚假的<code>自我实现</code>: 比如: 输了我kda高, kda低我输出高, 输出也低 都是垃圾队友害的. 游戏的”举报”机制又增加了归咎到他人的减少挫败感的机制, 游戏策划真的是非常厉害的人. 另外虚拟装备和虚拟比较(在游戏中比别人强, 或者装备厉害&#x2F;好看发光)都使人得到<code>自我实现</code>的满足感.</li><li>人总是仰视别人说”某某很有钱”: 其实还有下半句, 大多数人都会把别人的成功归功到运气, 其实很多事大多人都能做, 别人和自己当前水平的差距成了打消焦虑的工具, 也成了阻止自己进步的借口.</li></ol><p><strong>归纳结尾</strong>, 在我看来, 在自己可以忍受的范围内去通过努力做些事实, 而不是用形式欺骗自己满足<code>自我实现</code>的心理. 在痛苦后可以获得更真实更好的满足感.</p><p>顺带一提, <code>自我实现</code>的需求是人的本性, 而且是<strong>阶段性</strong>的, 也就人要时时保持有新的获得才能满足, 这也说明有钱人不一定开心, 这就是暴发户吸毒赌博的原因. 为了满足这个心理我们能做的是尽力去发现自己喜欢的东西并钻研. 用这真实的痛苦来换取避免泡沫破裂的痛苦.</p><h2 id="被别人指责了应该如何回应-如何表达自己的不满又不让气氛尴尬"><a href="#被别人指责了应该如何回应-如何表达自己的不满又不让气氛尴尬" class="headerlink" title="被别人指责了应该如何回应? 如何表达自己的不满又不让气氛尴尬?"></a>被别人指责了应该如何回应? 如何表达自己的不满又不让气氛尴尬?</h2><p>先来说一些场景:</p><p>一位平时关系较好的朋友或者你的领导&#x2F;老板(这个场景下他们三个是一个档次的)对你进行了指责, 内容也许是: 这次的工作你完成得不好, 或者是你的xx(某游戏中的人物)玩得真烂啊.</p><p>也许是出于关系的熟悉, 也许是出于从上往下的俯视, 他们说出了对你有攻击性的话, 也许他们还没注意.</p><p>那么从被指责的角度来看, 有两种普遍的错误回应:</p><ol><li>情况1, 不认识的人&#x2F;比自己地位低的人&#x2F;不重要的人: 直接怼回去: 操你妈的, 你行你上, 不服solo. 老子不干了, 找到这工资的工作轻而易举. 下次不和你一起玩了, 不看看你自己玩多垃圾是我在带你.</li><li>情况2, 是上面例子中的身份的人. 那么普遍的做法就是隐忍了, 要不呵呵苦笑, 要么表面认错心里是情况1的干了他祖宗. 做了这个决定的人也许还会认为, 自己素质不错, 或者是自己做得蛮对的, 避免了冲突.</li></ol><p>实则不然, 若是使用了隐忍, 对方对你的印象就是好欺负的, 你成为了”可以指责的对象”, 他下次会下意识地指责你, 这样做会降低自己的地位.</p><p>那么我就来说一下非暴力沟通的3要素. 我很久没写读后感了, 原因同上面不整理rn总结.</p><p>三要素每一条都非常重要:</p><ol><li><p>冷静, 去掉情绪. 被指责以后正常人都马上会产生很强烈的情绪, 也就是产生敌意, 一旦产生敌意, 就算再注意, 你的语言也会带有很多攻击性和指责, 那么对话会立马进入很糟糕的循环, 直到一方忍着不说或是打起来. 如果觉得情绪很强, 那就选择隐忍, 但往往一开始不会有很强的情绪, 只是经过一次次语言的恶意相加而变本加厉的.</p></li><li><p>向对方表达自己的感受&#x2F;描述自己处在的情况, 并指出对方这样的指责是有问题的. 比如: 这个项目我做得不差, 因为xx细节和xx细节, 我都仔细考虑过, 你这样闭着眼睛说我很过分. 或者这局游戏我这个位置本来就没有优势, 我已经尽量xxx, 你再来说我就没有意思了. 等</p><p>当然, 前提是自己没有错, 或者是说自己尽力了. 如果自己是存在问题的那就改正问题, 这是另一个话题, 这里不讨论.</p></li><li><p>明确告诉对方应该怎么做. 人有一个特点是懒. 你被指责了一生气, 你出口的话也是指责, 所以也只是宣泄情绪, 并没有明确的目的. 举个最简单的例子: 吃饭觉得菜不好吃, 对老婆说”菜做好吃点”. 正确说法: “多放点盐菜更好吃”. 从老婆的角度看问题: 听到了”做好吃点”, 并不知道应该如何做, 等于给我出了一个题目, 而人遇到做不出的题目就会感到焦虑. (如果做得出他也不会没有达到老公的要求了). 感到焦虑就会找焦虑的源头, 就是老公的一句话, 所以就对老公产生了不满, 接下来的情况可以想象. 若是听到”多放盐菜更好吃”, 有了努力的方向, 明确了要做什么, 就容易接受得多.</p></li></ol><h2 id="为什么不优秀的人经常高谈阔论-而优秀的人空闲都不谈工作"><a href="#为什么不优秀的人经常高谈阔论-而优秀的人空闲都不谈工作" class="headerlink" title="为什么不优秀的人经常高谈阔论, 而优秀的人空闲都不谈工作?"></a>为什么不优秀的人经常高谈阔论, 而优秀的人空闲都不谈工作?</h2><p>缘起是看到财务自由的大佬微博上在聊哪个vr好玩, 哪个漫画好看. 从而想到了一些事.</p><p>说一些例子: </p><ol><li>我以前会时而经过来福士前面一条路, 据说是某股票集会所, 每次门口的路都被聊股票的人占满, 个个聊得精通股市. 大人们聚头的时候也经常聊股票. 然后我爸经常说, 他同事股票非常厉害, 什么都懂. 我内心台词: 都懂都厉害来上班?</li><li>公园的老爷爷们都在讨论国家大事.</li><li>大家都在看世界杯. 而有很大部分人不是球迷却真的喜欢看.</li><li>新入职的时候, 空余时间会和别人讨论技术问题. (还是真心的想讨论)</li></ol><p>说我看这个问题的一个角度: 目的性. 结论是: <strong>绝大部分的行为和语言的目的和表面看起来的不同.</strong></p><p>另一个角度: 行为的迷惑性. 人在做什么就会以为自己在做什么. 那就产生了一个结论: <strong>很多人不知道自己正在做的事目的是什么.</strong> 那么再给一个推论: <strong>只要仔细思考自己的目的和方法, 就非常可能达到目标.</strong></p><p>下面就着这两个论点说几个例子.</p><p>关于’绝大部分的行为和语言的目的和表面看起来不同’:</p><ul><li><code>表面</code>有人问我: 你要不要喝奶茶? <code>实际</code>我想喝奶茶.</li><li><code>表面</code>妈妈: 天太冷了多穿点衣服. <code>实际</code>妈妈冷了. (我是个胖子, 经常被投射我根本就感受不到的东西)</li><li><code>表面</code>在吃饭时同事和我讨论技术. <code>实际</code>一起吃饭很尴尬, 找点可以聊的东西. (事实证明熟悉了以后都在聊游戏).</li><li><code>表面</code>老板来找聊天, 偶尔谈到工作. <code>实际</code>老板只是找个话题和我们聊聊天. (因为地位高低的关系, 有时会当真, 认真做了以后发现老板都忘记闲聊时候谈到的项目了)</li></ul><p>关于行为的迷惑性, 是我想重点说的.</p><p>这涉及到, 为什么有些人成功地升职加薪, 当老板发大财了. 而我们(大多数人)是感觉是: <strong>我明明在学习, 为什么没达到别人的成果?</strong></p><p>我来换一个情景说这句话: 我明明办了健身房的会员卡, 为什么没有变成健美男? 或者: 我明明参加了前端培训班, 为什么还没有找到一个好工作?</p><p>就着这个我来说说行为的目的性和迷惑性. </p><p>健身房和培训班的盈利模式如出一辙. 简单地说是: 100个会员, 1个成功, 99个送钱. 这不是我说的, 结果摆着: 健身房盈利巨大, 周围有很多办卡不去的人. 高端程序员永远缺, 按照道理培训班出来再工作2, 3年都是很厉害的人了.</p><p>一部分人带着错误的目的做事, 他们的目的是: <strong>在家睡觉挣大钱.</strong> 所以他们参加健身房培训班的期望是: 花3, 5万, 换得好身材&#x2F;换得2, 3万的工作. 这笔账谁都会算: 3-5万, 6个月, 之后获得2万的工作, 2~3个月回本. 这就是为什么培训班的广告都用超过50%页面写着大字: 挑战年薪30万. 事实证明, it works.</p><p>而成功的人的目的是什么: <strong>通过学习提高自己让自己有挣大钱的本事</strong>. 我一直在说目的不对, 其实有误, 是”思路不对”, 方法不对.</p><p>学生时代一直会有一部分人: 一直用功做作业, 却成绩不好. 那时我们也许觉得他不聪明. 现在回想, 他在搞形式. 上学的那些内容根本就不需要高智商, 所以才是普及教育. </p><p>这就是行为的迷惑性: <strong>我只要坐在书前面, 就在学习了</strong> 这种迷惑性让自己的焦虑和内疚都消除了. 然而也是你正在服下的毒药.</p><p>目的与行为不符, 一定是失败结尾的, 但是这些迷惑性的行为又让自己产生了’我在努力的’感觉. 这也是我为什么写了这个chrome插件<code>did</code>的原因, 整理自己所做的事, 是不是实事, 强调结果. 当总结每天所得之时发现没有什么可以总结的, 而只是在电脑前坐了一天. 那就给自己个告警, 明天不可以这样了.</p><p>小时候大家都相当”科学家”(虽然根本不知道这是个什么东西). 读书以后发现读书难, 都渐渐放弃了. 这是理智的行为. 而”整天坐在书前面就能当科学家”的人大量存在, 导致”想着不劳而获”而最终让另一部分人”不劳而获”的例子实在太多了.</p><p>那么如何应对, 说一下我的结论: 经常提醒自己, 1. 仔细思考别人行为的实际目的. 2. 仔细思考自己行为的真正目的. 方法是通过总结每天做了些什么获得了什么结果.</p><p>另外, <strong>看起来很划算的东西都是骗人的.</strong> 这是世界的铁律, 引用某著名动漫: <strong>等价交换</strong>是世界的规律. 价值是用血汗和痛苦进行生产而交换得到的. 再引用马化腾的表情包: <em>你赚了, 我亏得都想哭了.jpg</em>.</p><h2 id="如何处理负面情绪"><a href="#如何处理负面情绪" class="headerlink" title="如何处理负面情绪?"></a>如何处理负面情绪?</h2><p>人生在世难免有负面情绪, 道理很简单: <strong>我们的欲望是不可能实现的.</strong> 也就是: 我们都拥有错误的欲望.</p><p>我们来进行简单的推理: 我的目标是成为有钱人. 如果每个人都成为了有钱人, 没有差距, 也就不存在有钱人了. (现在的生活最低工资都能让一个人过得不错, 不存在没钱吃喝什么的).</p><p>以上推论的结果: 总有人有负面情绪, 那么确实有人满足了自己的欲望的, 但这些人会被别的人宣泄负面情绪. 就好像皇帝要时时放着下面的人背叛, 或者是第一实力的国家也要一直发展军事, 时时防范被打掉. 所以负面情绪是客观存在的.</p><p>先来说一下是什么引起我思考这些:</p><p><strong>我开着摩托(摩托自重超过300斤), 还是新的, 为了避让一个突然转弯而不该转的自行车摔倒了. 自行车扬长而去.  摔得很惨, 雨天, 300斤的车, 车是新车, 上周才买的厦德箱子, 3箱子2000人民币, 一个边箱摔烂了.</strong> 我当时的想法就是, 我为什么要让不遵守规则的, 应该撞死你们这群垃圾瘪三.</p><p>于是一堆负面情绪接踵而来. 总的来说就是: 责怪别人.</p><p>现在冷静下来, 做个比喻: 我确实没犯错. 但我对自己的标准是60分(及格), 而不是100分(做得更好). 一定有100分的人, 开车会避免这些事. 如果我告诉自己的是: 自己错了, 我应该做100分的人, 那就没这么愤怒了. 这涉及到内控人格和外控人格.</p><p>内控&#x2F;外控是指人的归咎倾向. 发生了一件事是归咎于外部还是内部. 比如考试成绩差, 他认为是自己水平不行, 还是考卷太难.</p><p>在大多情况下, 内控都是更好的. 内控使人有掌控感, 并知道如何行动. (知道如何行动是提高幸福感的事情). 许多时候我们愤怒和难过的根本原因是: 我不知道应该做些什么了. 而导致的焦虑. 因为知道干什么就会把精力放在做事上, 并且会对未来产生良好的预期, 心情就好了. 人是活在未来的动物.</p><p>内控在部分时候没有外控好, 部分是指不可抗力. (具体在我之前的”人格心理学”的读后感中有详细介绍).</p><p>另外, 对于我们对不良事件的态度, 有一个重要的认知需要记住: <strong>所有发生的事情都有形成的原因, 并且在一段时间内不会改变</strong>. 这个一段时间也许是你的一辈子. </p><p>也就是: 对于我们看不惯的事情, 我们是无力改变的, 比如自行车&#x2F;行人随意变道, 突然窜出来. 我们能做的是防御性驾驶.</p><p>我认识了一些人, 都因为事故放弃了开车. 因为外控: 他们的想法是, 道路太危险, 世界太乱, 开车不合适. 我却可以选择内控: 把60分的水平变成100分.</p><p>这个思路可以拓展到很多生活的部分, 因为人性是相同的. 对于人际关系的处理, 对于技术水平的进步(就是学习). </p><p><strong>接纳</strong>是最高级的心态. 接受所有发生的事, 去思考自己如何做可以更好地应对. 因为正在发生的事一定是有原因的, 这个原因也会推动同样的事继续发生, 我们要做的是接受这个事, 明白这些看起来不顺心的事是正常的, 是必然发生的. 那么就会有更好的心态去迎接接下来的生活.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http1.1科普</title>
      <link href="/2018/05/31/http-introduction/"/>
      <url>/2018/05/31/http-introduction/</url>
      
        <content type="html"><![CDATA[<p>因为工作碰到了一些疑惑所以看了<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">火狐的http文档</a>, 简单地看, 简单地总结了一下, 本文只介绍http1.1的概念, 不介绍具体让人心烦的细节(配置和行为).</p><span id="more"></span><h2 id="什么是http"><a href="#什么是http" class="headerlink" title="什么是http"></a>什么是http</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>全称是超文本传输协议. 何为超文本? 超文本就是文本(文本不一定是超文本).</p><p>http的本体是文本. 并且http2之前的版本(包含现在正在用的1.1)都是人类可读的文本.</p><p>再说一下什么是协议? 协议就是双方约定一些东西, 使用的时候大家都遵照规则执行.</p><p>我们来类比html, 超文本标记语言. 本身是文本(div, p, img). 放到浏览器里解析的时候就会被画成一个块, 一个图片等. 那么http也是如此, 普通的人类可读的文本, 进行了一系列约定, 协议双方根据一些关键词来执行某些约定的行为, 便是http了.</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>那么http到底是在哪里发生的, http的三个属性:</p><ul><li>http是<a href="https://en.wikipedia.org/wiki/Application_layer">应用层</a>协议.</li><li>http是基于<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">客户端&#x2F;服务端模型</a>.</li><li>http是<a href="https://en.wikipedia.org/wiki/Stateless_protocol">无状态协议</a>.</li></ul><p>高中就学过了osi七层协议, http是最上层的协议, 下面是基于传输层的(不仅限于tcp&#x2F;ip).</p><p>客户端指浏览器, 服务端指服务器. 顺序是浏览器的某些动作(比如输入url并敲回车)触发http请求, 服务器接到请求返回, 形成了一次完整的http请求. http请求每次都是独立的, 所以是无状态协议.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>http就是<strong>浏览器使用传输层协议向服务器发出一些文本</strong>, 这些文本带有约定的东西, 服务器根据约定的规则来分析内容并作出响应. 学习http就是学习这些约定.</p><h2 id="http消息"><a href="#http消息" class="headerlink" title="http消息"></a>http消息</h2><p>就像html是div, p, img一样, http长啥样, 平时使用浏览器的调试工具或是http抓包工具都能看到. (当然都是进行过可视化处理的).</p><p>http消息分为请求(request)消息和响应(response)消息. 即浏览器发出请求的消息和服务器响应的消息.</p><h3 id="消息组成"><a href="#消息组成" class="headerlink" title="消息组成"></a>消息组成</h3><p>request和response的消息组成是一样的.</p><ol><li>start-line: 请求&#x2F;响应的基本信息.</li><li>http header: 请求&#x2F;响应的头信息.</li><li>空行: 作为分隔符.</li><li>body: 请求&#x2F;响应的主体内容.</li></ol><p>request和response的每个部分的消息内容不同. 下面介绍每个部分的具体内容.</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ol><li><p>start-line: 方法(get&#x2F;post等), 目标(通常是url), 协议版本. 例: <code>GET /background.png HTTP/1.1</code></p></li><li><p>header, 用冒号&#x2F;换行隔开的键值对, request和response拥有不同的有效header键值, 详见文末链接.</p></li><li><p>大多数request的body为空, 比如get, delete, options方法. 一些需要上传数据的方法如post, put会有body. </p><p>body有两种情况: 单个资源: 此时header要定义<code>content-type</code>和<code>content-length</code>. 多个资源: 在<code>content-type</code>里定义<code>boundary</code>, 然后在body中用<code>boundary</code>来分隔多个资源. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#multipartform-data">例子链接</a></p></li></ol><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><ol><li>start-line: 协议版本, 状态码, 状态描述. 例: <code>HTTP/1.1 404 Not Found</code>.</li><li>header, 同request.</li><li>response的body也不是必须的, 与request类似, 也分为单个资源和多个资源. 多了一个情况, 不知道文件长度的时候可以把<code>transfer-encoding</code>设为<code>chunked</code>.</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>至此, http已经介绍完了. 我来举一个简单的http的例子.</p><p>我打开了浏览器, 敲入<code>yo-cwj.com</code>. 浏览器发出了http request.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET https://yo-cwj.com HTTP/1.1</span><br><span class="line">Host: yo-cwj.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>这个简单的get请求没有body, header都是浏览器默认带上的.</p><p>然后收到了回复:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line">Server: Apache/2.0.61 </span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application/xml</span><br><span class="line"></span><br><span class="line">&lt;html&gt;陈文俊的博客&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>200, ok 代表请求成功, 倒数第二行空行代表header和body的分隔, 具体返回内容是<code>&lt;html&gt;xxx&lt;/html&gt;</code>, 浏览器获得结果就可以去渲染页面啦, 完美.</p><p>是的, http就是这么简单, <strong>http的结构就是start-line, header, body三部分.</strong> 而协议复杂的地方大部分就在header了. header有一万个字段, 每个字段能研究一年. (所以要搞懂http需要一万年). 那么下面的章节简述一下经常接触的协议规则.</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>http是无状态协议, 但网站的登录状态&#x2F;购物车等是有状态的, 就要借助cookie来实现. cookie是储存在浏览器上的信息. 会在向服务器发起请求的时候带着, 以代表浏览器当前的状态.</p><p>cookie原先的作用除了登录&#x2F;购物车, 还有储存用户主题, 分析用户行为等. 但浏览器的行为会将cookie都带到http请求中, 所以现在推荐使用现代storage api来储存部分信息. </p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>两个关键点: cookie传输是通过http的header, cookie的储存的地方是浏览器.</p><p>response header可以设置cookie:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</span><br></pre></td></tr></table></figure><p>然后浏览器收到set-cookie头以后会储存cookie, 在发送请求时把对应的cookie带在request header的<code>Cookie</code>中, 格式是: <code>k=v; k2=v2</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>那么浏览器中会有很多cookie, 因为我们经常同时浏览不同的网页. 浏览器进行request的时候把所有cookie带上是不对的, 那么会带上哪些cookie呢, 就涉及到cookie的作用范围.</p><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>控制cookie作用范围的关键字是Domain和Path, 如果都没设置默认行为是<strong>只向当前路由发送cookie</strong>, 我的理解是什么路由接到set-cookie的就只向这个路由发送.</p><p>domain和path的语法是<code>Domain=mozilla.org</code>, <code>Path=/docs</code>. domain被设置的时候会向domain的所有子domain发送, 所以希望发送范围越小就要设置得越细. path相同.</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>cookie的生命周期是浏览器关闭, 也可以在response header里通过设置expire来改变cookie的过期时间.</p><h3 id="xss与csrf"><a href="#xss与csrf" class="headerlink" title="xss与csrf"></a>xss与csrf</h3><p>因为浏览器通过<code>document.cookie</code>可以获取自己的cookie. 通过一些手段发出一些请求并带上cookie就可以获取cookie来做不好的事情. 这也是http的特点: 无状态. 所以理论上一切请求都是可以模拟的. (只要获取了关键信息, 任何人都可以在他的电脑上模拟你正在登陆某网上银行甚至进行操作).</p><p>这些操作有: 让页面执行一段js, 让页面append一个img, src的target是恶意网站. 所以防止xss攻击只要做到控制用户可进行的操作或转移用户输入就可以了.</p><p>题外话, 因为js和css和html都是明文的, 所以安全必须通过加密手段来强化.</p><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p>跨域好像是每隔一段时间都会被问到的问题, 先来定义一下什么是跨域请求.</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>违反<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源策略</a>的请求就叫跨域. 同源策略一句话就能说完: <strong>协议, 主机, 端口都相同的url是同源url</strong>. 强调是<strong>都</strong>相同, 即使<code>http</code>和<code>https</code>的区别也算跨域. 左边的链接举了一些例子, 一看就明白. </p><p>那么从一个页面向一个非同源的target发起了http请求, 这个请求就是跨域请求了.</p><h3 id="触发对象"><a href="#触发对象" class="headerlink" title="触发对象"></a>触发对象</h3><p>那么什么情况下会发起跨域请求呢? 我的印象里百分之90的情况是js代码发起的, 也就是或经过框架包装的xmlhttprequest. 下面这些都会触发http请求:</p><ul><li>js代码发起的, xmlhttprequest, fetch. 因为fetch存在兼容问题, 基本所有的框架封装都是通过前者的.</li><li>web字体. 通过<code>@font-face</code>.</li><li>webgl texture.</li><li>canvas用<code>drawImage</code>画的Image或者Video.</li><li>css和script标签.</li></ul><h3 id="跨域请求需要做的事情"><a href="#跨域请求需要做的事情" class="headerlink" title="跨域请求需要做的事情"></a>跨域请求需要做的事情</h3><p>说了半天什么情况是跨域, 那么为什么要讨论跨域呢? 当然是报错了才会讨论了.</p><p>因为安全关系, http是默认阻止跨域请求的, 想要顺利地进行跨域请求, 必须在浏览器和服务器都进行一些header设置, 来确认这次跨域请求是双方都认同的. 就像你要删除社交工具的好友前会进行提示: 你是否要删除好友xxx.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">跨域相关的request和response的header</a>都在左边的链接里了, 这里只提一个作为例子:</p><p>(开始讲故事)</p><p>我的<strong>博客</strong>(<a href="https://yo-cwj.com)需要加载一些图片来丰富博客内容/">https://yo-cwj.com)需要加载一些图片来丰富博客内容</a>, 因为博客托管的服务器对博客大小有限制, 所以我把图片放在了另外一个<strong>图库</strong>(<a href="https://picture-cwj.com/">https://picture-cwj.com</a>). (下文就用<code>博客</code>和<code>图库</code>来代表2个地址).</p><p>博客使用了img标签来请求了图库的图片. 图库返回的图片response header 带有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://yo-cwj.com</span><br></pre></td></tr></table></figure><p>博客进行请求的request header带有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: https://yo-cwj.com</span><br></pre></td></tr></table></figure><p>图库的response header告诉所有过来的请求: 我只给<code>yo-cwj.com</code>跨域. 博客的request header带着表明身份的<code>Origin</code> header. 这样一次不被阻止的跨域就完成了.</p><p>(故事完)</p><p>故事讲完了, 博客是存在的, picture-cwj.com是不存在的. 简单的2个header就让浏览器放行了跨域请求. 别的header都在故事前贴出来的链接中.</p><h3 id="preflight-request"><a href="#preflight-request" class="headerlink" title="preflight request"></a>preflight request</h3><p>强行翻译: 跨域准备请求.</p><p>当跨域请求满足了某些条件以后, 浏览器在跨域请求前会发起一次preflight request, 用来确认即将发送的请求是否被允许.</p><p>preflight请求的method是options, 之前说的跨域相关的header大部分是和preflight相关的.</p><p>下面介绍发起preflight请求的触发条件:</p><ol><li>method不是<code>get</code>, <code>post</code>, <code>head</code>的.</li><li>request header 带有指定字段之外的. </li><li><code>cotent-type</code>头的值在指定范围之外的.</li></ol><p>只要满足任何一个条件就会发起preflight请求. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">具体条件</a>在左边的链接中.</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>关于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">缓存</a>暂时只做概念介绍, 缓存的控制也都是header控制的.</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>什么是缓存? 当同一个请求进行了2次以上, 浏览器不真正向浏览器发起请求而直接返回之前储存的结果.</p><h3 id="缓存哲学"><a href="#缓存哲学" class="headerlink" title="缓存哲学"></a>缓存哲学</h3><p>缓存的好处是: 提高浏览器响应速度, 节省服务器带宽. 因为没有与服务器真正数据交互, 也获得了期望里的数据.</p><p>缓存的问题也非常明显, 获得的数据是缓存里的, 而不是最新的. 所以缓存的关键就在于猜测哪些数据是不经常更新的. 猜测什么类型的数据的更新频率是多少, 并使用缓存相关的header来控制. 比如某门户网站的首页html是不经常更新的, 或者是每小时一更新, 而首页轮播的图片是十分钟更新的.</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><p>缓存类型分为本地缓存和共享缓存.</p><p>我们概念中的, 或者说我们经常使用的都是本地缓存.</p><p>共享缓存是指ISP对服务器的缓存, 之前听说淘宝怎么能让网速更快, 离用户最近的地方是ISP机房, 所以把淘宝首页放在ISP机房就行了.</p><h3 id="新鲜度检查"><a href="#新鲜度检查" class="headerlink" title="新鲜度检查"></a>新鲜度检查</h3><p>有一种缓存的机制是新鲜度检查. 之前说的缓存response是: 200 OK (from disk cache). 新鲜度检查是根据<code>cache-control: max-age=xxx</code>向服务器发起新鲜度检查. 如果返回结果是304(not modified), 服务器将不返回数据, 使用浏览器缓存的数据, 从而节省数据下载时间和带宽.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">http header</a></li><li>[request methods](&lt;<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a>)</li><li>[response status](&lt;<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome拓展应用bug修复记录</title>
      <link href="/2018/05/29/chrome-extension-issues/"/>
      <url>/2018/05/29/chrome-extension-issues/</url>
      
        <content type="html"><![CDATA[<p>好久之前写的<a href="https://github.com/cwj0417/yosoro">chrome拓展</a>我竟然自己一直在用, 常用的功能是字典, todo列表, 收集tab和笔记本. 用了那么久问题也出了不少, 今天在删笔记本和添加todo的时候出了大bug, 那么就来看看除了什么问题.</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我在向todolist添加一条todo的时候报错了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QUOTA_BYTES_PER_ITEM</span><br></pre></td></tr></table></figure><p>咋肥ser? 到<a href="https://developer.chrome.com/extensions/storage">文档</a>里看了下, 原来是chrome拓展对storage的大小有限制, 分别对总大小&#x2F;单条数据大小&#x2F;数据条数&#x2F;每小时操作次数&#x2F;每分钟操作次数有限制. 这个错误是超过了单条数据大小.</p><p>由于一开始对这些限制没有了解加入考虑, 我这个应用的数据结构存在问题并且已经定了. 我的todolist现在有80条左右, 那么限制80条todo一定是不合理的, 于是需要想一个办法.</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>经过了一番粗糙的思考, 我决定分批保存, 思路非常简单: <strong>在设置变量的时候判断item大小并分成n个, 在n大于1的时候在原本的键上加后缀, 取出的时候根据后缀规律拼接成一个item.</strong></p><p>幸好之前对storage进行了封装, 在这里改起来就非常方便, 并且所有使用storage的地方都可以应用这次修改.</p><p><a href="https://github.com/cwj0417/yosoro/blob/master/src/libs/storage.js">代码</a>在非常简单, 就简单地贴一下, 可以点近左侧连接仔细看.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> batches = <span class="title function_">getBatch</span>(key, value)</span><br><span class="line">    <span class="keyword">let</span> processes = []</span><br><span class="line">    batches.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        obj[index === <span class="number">0</span> ? key : <span class="string">`<span class="subst">$&#123;key&#125;</span>-p<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>`</span>] = item</span><br><span class="line">        processes.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(obj, <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">catchError</span>(reject)</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`ok<span class="subst">$&#123;callback&#125;</span>`</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(processes)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="title function_">merge</span>(res), <span class="function"><span class="params">reject</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(reject))</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> getFromStorage = <span class="keyword">function</span> (<span class="params">originKey, level = <span class="number">1</span></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> _key = level === <span class="number">1</span> ? originKey : <span class="string">`<span class="subst">$&#123;key&#125;</span>-p<span class="subst">$&#123;level&#125;</span>`</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">                chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(_key, <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(callback[_key])</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> level = <span class="number">1</span>, keepGoing = <span class="literal">true</span>, cache = []</span><br><span class="line">            <span class="keyword">while</span> (keepGoing) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = <span class="keyword">await</span> <span class="title function_">getFromStorage</span>(key, level++)</span><br><span class="line">                <span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">                    keepGoing = <span class="literal">false</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache.<span class="title function_">push</span>(temp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cache.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">merge</span>(cache)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span> failed`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客装饰笔记(2018五月)</title>
      <link href="/2018/05/28/blog-decoration-201805/"/>
      <url>/2018/05/28/blog-decoration-201805/</url>
      
        <content type="html"><![CDATA[<p>博客的样式已经近2年没有动过了, 最近老看到用这个主题的, 还是决定改一下博客的样式, 就邀请了设计师朋友帮忙进行了新一波博客改版.</p><span id="more"></span><h2 id="补坑"><a href="#补坑" class="headerlink" title="补坑"></a>补坑</h2><p>看了2年前的文章, 其实中间博客有许多改动的并没有记下来, 也许是懒也许是忙. 为了让<code>博客装饰</code>这个标签完整, 补一下我还记得的对博客的修改.</p><h3 id="博客目录"><a href="#博客目录" class="headerlink" title="博客目录"></a>博客目录</h3><p>上篇博客只写了用jquery获取<code>h</code>标签的内容来产生博客标题, 然后产生目录并append到侧边栏上. 很明显现在的目录已经不是这样了.</p><p><a href="https://github.com/cwj0417/fjonas.github.io/blob/source/themes/wwj/source/js/post.js">这里</a>是代码链接, 现在的思路是: </p><ol><li>在滚动目录滚动的时候增加一个操作: 根据上次滚动来判断当前滚动是向上还是向下, 向下滚展现目录, 向上滚并且离顶端较近的时候隐藏目录(因为离顶端较远的地方是空白, 离顶端近的地方有一些widget).</li><li>在目录过长的时候对目录进行缩放(缩).</li><li>使用throttle来节流事件.</li></ol><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>博客是托管在<code>github page</code>上的, github page本身做好了https, 但是要自己的域名就不支持啦, 所以选择了<a href="https://www.cloudflare.com/">cloudflare</a>来弄https. 方法也是非常简单, 把域名的dns改到cloudflare上, 把各个配置填到cloudflare上, 他就帮你把事情都做了. (这个做法使人感到很强的不安全感, 好不好暂不讨论). 并且防止了国家管制. (因为没交保护费, 博客备案已被注销, 有点点生气).</p><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>博客的评论由<code>多说</code>改成了<code>畅言</code>, 原因是多说倒闭了. (倒闭的原因同dota). 当时觉得畅言的卖点是敲图章, 现在出现一个巨大的问题:  不登陆不给评论, 而且用户体验极极差, 输入好评论再提示, 并且没有保存未发出的评论, 辣鸡, 有空把畅言换了.</p><p>另外, 最近评论也换成畅言, 并修改了一些样式, 并且鼠标悬浮头像会转动.</p><h2 id="本次博客改动总览"><a href="#本次博客改动总览" class="headerlink" title="本次博客改动总览"></a>本次博客改动总览</h2><p>先来列举一下本次博客改动的内容, 再来做细节的总结.</p><ul><li>整体布局改动: 把头部抽离container, 侧边栏与正文左右交换.</li><li>所有ui细节重写. 包含小屏页面ui.</li><li>去除widget: 搜索, 分类, 最近文章.</li><li>把分类作为tab添加在右边区域.</li><li>优化文章目录的手感.</li><li>调整博客持续集成, 使用token来替代ssh key.</li></ul><p>那么下面来写一些在实现过程中学到的粗浅的技术和感悟.</p><h2 id="Jade模板"><a href="#Jade模板" class="headerlink" title="Jade模板"></a>Jade模板</h2><p>jade的新名字是pug, 是一个node的html模板. 好像是因为jade这个名字早就被注册掉了. 一开始不太习惯, 其实用了还好. 简而言之, **jade用缩进来表现html结构, 去除了尖括号, 并提供了一些遍历和继承的语法. ** 可能ejs更让人舒服, 总的来说他们一类东西, 只是jade上手难一些(其实根本不难, 只是看起来不习惯).</p><p><a href="https://github.com/cwj0417/fjonas.github.io/blob/source/themes/wwj/layout/base.pug">这里</a>是代码链接, 下面说一下jade相关的功能实现.</p><h3 id="应用结构"><a href="#应用结构" class="headerlink" title="应用结构"></a>应用结构</h3><p>在主题的layout目录下都是模板文件. 首页对应的就是<code>index.pug</code>. 下面一边流水一边介绍几个关键词.</p><p><code>index.pug</code>开头就**<code>extend</code><strong>了<code>base.pug</code>. 到<code>base.pug</code>里看, 内容是最基础的html结构, doctype, html, body, script等这些. 另外一个关键词</strong><code>block</code>**. <code>base.pug</code>中的block部分由<code>index.pug</code>中的block部分替换.</p><p>另外一个语法**<code>include</code>**, 引入一些widget和partial, 效果就是引入的文件替代当前的include语句.</p><h3 id="业务逻辑语法"><a href="#业务逻辑语法" class="headerlink" title="业务逻辑语法"></a>业务逻辑语法</h3><p>说两个语法和对应的场景:</p><p>循环: 斜杠加for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- for (var i in theme.cats)</span><br><span class="line">.pure-u-1-4.pure-u-md-1-4.nav-wrap</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>这样可以遍历一个数组, 产生对应的元素, 不要忘记缩进, 失去缩进就会把内容写到循环外面.</p><p>判断: if, 不需要括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if is_category()</span><br><span class="line">.post</span><br><span class="line">else</span><br><span class="line">.archive</span><br></pre></td></tr></table></figure><p>如果满足条件就显示下面的, if-else 同样要注意缩进.</p><h2 id="hexo环境变量"><a href="#hexo环境变量" class="headerlink" title="hexo环境变量"></a>hexo环境变量</h2><p>接上, 循环也好, 判断也好, 循环什么, 判断什么. hexo把文章的内容, 当前的页面, 当前的页数等好多好多变量都作为了页面的环境变量, 可以在编译模板的时候被jade取到.</p><p><a href="https://hexo.io/docs/helpers.html">这里</a>有页面信息, <code>is_home()</code>判断是否在主页, <code>is_archive()</code>判断是否在归档页面等.</p><p><a href="https://hexo.io/docs/variables.html">这里</a>是环境变量, 文章的内容, 分类标签, 分页. 变量分作用域. 在不同地方可以取到的变量不同. (细想这是当然, 文章内容, 分页信息等都是对象相关的). 这些变量在jade变量里直接用就行了. (就类似在js代码里直接使用挂载在window下的变量).</p><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>本博客的响应式布局只是简单的对768屏幕做了media query. 头部在手机端做了较大的变化, 身体部分在手机端把侧边栏直接去除了.</p><p>没什么特别的, 这有一些些css哲学. 好的布局在css加载失败的时候也很好看, 好的css能突出重点渲染ui.</p><p>做媒体查询麻烦的地方是约等于设计&#x2F;实现双倍的页面.(如果设计差别大的话).</p><h2 id="目录手感修改"><a href="#目录手感修改" class="headerlink" title="目录手感修改"></a>目录手感修改</h2><p>之前博客的目录一直有一个时有时无的问题, 页面滑到顶端的时候有时候目录不会消失, 这次改版仔细分析了原理, 原来是我的throttle简单实现有问题.</p><p>先来简述一下debounce和throttle. 这两个都是节流的方法, 他们都有一个timeout属性.</p><p>我第一次接触到debounce是输入框提示, 在输入框中输入了一些字母会进行网络请求来获得可能结果并展示, 所以在输入过程中不断查询是错的, 要等用户输入停止一段时间再进行动作.</p><p>思路是每次触发动作就设置一个定时, 定时到了就执行, 如果在执行前再次触发, 就重新定时.</p><p>throttle的场景是页面滚动, 会非常频繁触发滚动时间, 所以做法是: 执行一次以后进行定时, 在定时内再次触发就阻止执行.</p><p>于是我找到了我的问题, throttle只做了阻止触发, 没有在定时后把本改执行的动作继续执行.</p><p>想到spy可能做了这些工作, 所以暂时把throttle去除了, 也没有出现卡顿, 那么暂时解决了问题.</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>之前用了ssh key来为ci提供身份验证, 但是好像会在会话关闭时过时, 于是去github上拿了一个api的token, 放到了travis ci上, 于是现在可以成功集成发布啦.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次使用jenkins来打包apk</title>
      <link href="/2018/05/23/record-a-use-of-jenkins-building-apk/"/>
      <url>/2018/05/23/record-a-use-of-jenkins-building-apk/</url>
      
        <content type="html"><![CDATA[<p>两年前我入职现在工作的地方后第一次knowledge share一位同事分享了jenkins. 两年后的现在他已经是老同事并且也成为了前同事. 为了纪念离开的他我想试试折腾一下jenkins.(炉石的火车王也叫jenkins哦).</p><span id="more"></span><h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><p>先来讲讲这次ci的需求. 这里有一个web项目一个安卓项目. web项目又被作为portal, 当时临时满足需求的做法是手动从mobile项目打包, 把包扔到web项目里提到git上. 很明显手动打包和把build结果扔进git是极为粗糙野蛮的. 那么我们就需要优雅地完成: <strong>在web项目build成功后拉取mobile项目源码打包并把打包结果放到web项目的相应位置, 再停起web服务.</strong></p><p>之前没有操作过jenkins, 只在build博客的时候用的travis.ci, 这次使用jenkins的体验非常好, 问题都出在运维方面, 没有出在jenkins上. 这归功于这位前同事的分享和无数后端同事的工作, 包含但不仅包含软件安装, 软件配置, 账户配置, 免密登录配置这些需要花很多精力的工作.</p><h2 id="jenkins项目介绍"><a href="#jenkins项目介绍" class="headerlink" title="jenkins项目介绍"></a>jenkins项目介绍</h2><p>我的理解非常浅, 我的使用体验是一个项目的核心就是<strong>配置</strong>, 配置好以后点一下<strong>立即构建</strong>就好了. 我们使用的都是git项目, jenkins触发构建以后会拉一次git的代码并放在对应的文件夹下(如果没有则创建). 然后根据配置在自己的工作空间里进行持续集成.</p><p>于是我新建了个项目, 选择完全自定义, 开始进入配置.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>jenkins的配置非常简单. 我们从头到尾全过一遍.</p><p>一开始是项目的名字描述什么的.</p><p>然后有一个github项目的复选项, 打上勾, 填上git地址, 每次触发构建jenkins就会把源码从这个地址pull到项目名对应的文件夹下了.</p><h3 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h3><p>在这里填写git地址, 还有一个svn选项. 填上地址, 然后当然项目是有权限的, 那么添加你的账号来获得权限.</p><h3 id="构建触发器与构建环境"><a href="#构建触发器与构建环境" class="headerlink" title="构建触发器与构建环境"></a>构建触发器与构建环境</h3><p>构建触发器: 选择一些触发的条件, 比如其他项目构建好&#x2F;git有新的提交&#x2F;周期构建. 我这里什么都没选, 也就是只有当在页面上点击<strong>立即构建</strong>的情况才会去构建.</p><p>构建环境: 提供了一些创造构建环境的快捷方式, 比如: 构建前清空工作区, 构建前ssh连上远程机器. 这些其实都可以在构建的时候操作.</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>这里是核心地方. 一般ci的功能: lint&#x2F;test&#x2F;build都在这里做吧. 可以分成n个步骤, 点击<strong>增加构建步骤</strong>来增加步骤, 步骤里可以直接执行shell, 也可以ssh到远程来执行shell, 或者执行lint等等常用的操作.</p><p>我的构建分2个步骤.</p><ol><li>本地执行shell: 走到这里的时候代码已经被pull到工作空间了, 只要执行<code>yarn</code>和打包apk的操作就行了. 执行好以后把打好的包<code>scp</code>到目标机器上.</li><li>远程执行shell: 设置远程机器的ip和用户并免密登录就可以了. 执行到这里顺利的话目标机器已经有了apk包了, 切到web应用的目录, 停止服务, 把apk拷到对应的目录, 启动服务.</li></ol><p>构建的过程就搞定了.</p><h3 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h3><p>这里是构建后执行的操作, 有发布文档&#x2F;发布git&#x2F;清空工作空间等. 有一个是我们要设置的: <em>Build other projects</em>. 不是在这里设置, 在web项目的构建后操作里点上这个, 构建完成触发我新写的这个项目就ok啦.</p><h2 id="遇到的非jenkins问题流水账"><a href="#遇到的非jenkins问题流水账" class="headerlink" title="遇到的非jenkins问题流水账"></a>遇到的非jenkins问题流水账</h2><p>本以为这个工作很快, 然后在apk打包的时候碰到问题卡了一整天, jenkins的机器是ubuntu14, 平时工作的是mac, 先不说os, build环境也是没装, 于是下了安卓sdk, 安卓sdk工具好像也推荐gui(android studio), cli还deprecated了. 安装好以后build一直报各种错. 本来在build的时候加<code>—debug</code>后缀, 毫无意义, 最后加了<code>—stacktrace</code>后缀终于得到了有用的信息, 见招拆招, 最后顺利地打包了~</p><h2 id="感想-jenkins与travis-ci比较"><a href="#感想-jenkins与travis-ci比较" class="headerlink" title="感想: jenkins与travis.ci比较"></a>感想: jenkins与travis.ci比较</h2><p>只说自己的感受: jenkins比travis.ci方便许多, 不排除有了travis.ci的经验的关系.</p><p>因为travis.ci是公有ci的关系, 每次环境都是新的, 所以调试和环境配置都成了麻烦. jenkins直接ssh到jenkins的机器上一顿操作就行了, travis.ci还要设置环境. 调试shell的时候也是直接敲就行了.</p><p>另一个jenkins的好处: 更小白化, 对于常用的操作进行封装, 只要点点就行了不用写shell.</p><p>travis.ci好处: ci过程可以放到git里. (所以无法避免对shell和os的要求更高)</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> ci </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则从零到简单分析html标签</title>
      <link href="/2018/04/28/regular-expression/"/>
      <url>/2018/04/28/regular-expression/</url>
      
        <content type="html"><![CDATA[<p>对于正则之前一直是一个”百度程序员”, 也许超过一半甚至更多的程序员也是, 那么这次来学习一下正则表达式.</p><span id="more"></span><h2 id="事出有因"><a href="#事出有因" class="headerlink" title="事出有因"></a>事出有因</h2><p>这部分介绍一下需求的由来, 与主要内容无关.</p><p>工作上有了这样的需求: </p><p>web端从ueditor来的数据格式是html, 也就是<code>&lt;p&gt;文章内容&lt;/p&gt;</code>, 并夹杂着诸多标签和嵌套. </p><p>然而正在开发的是react-native项目, rn的标签和html完全不兼容, 是<code>View, Text, Image</code>等. </p><p>那么把从web存入的数据读取到rn上就出了大麻烦, 甚至有些地方要进行跳转, 有些图片要显示, 那么怎么办呢.</p><p>通过百度”js如何验证邮箱”已经无法满足需求了, 只能学一下了.</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>万事有目标, 我们要把一下内容转换成rn的内容:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>嘿嘿嘿<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;currentImg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;currentImg&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1524647151050&amp;di=d488d0e93e72f13643d843066ef26836&amp;imgtype=0&amp;src=http%3A%2F%2Fimg02.imgcdc.com%2Fgame%2Fzh_cn%2Fpicnews%2F11128819%2F20160518%2F22678501_20160518152946632994008.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;201.33333333333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;302&quot;</span> <span class="attr">title</span>=<span class="string">&quot;点击查看源网页&quot;</span>/&gt;</span>拖过来的图片哦<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;currentImg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;currentImg&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1524647205890&amp;di=5bf77e1d35941def729d2059d91deba8&amp;imgtype=0&amp;src=http%3A%2F%2Fnds.tgbus.com%2FUploadFiles%2F201208%2F20120817142937519.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;201.17405063291&quot;</span> <span class="attr">height</span>=<span class="string">&quot;302&quot;</span> <span class="attr">title</span>=<span class="string">&quot;点击查看源网页&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>a<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">‘test1’</span> /&gt;</span>b<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">‘test2’</span> /&gt;</span>c<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">‘test3’</span> /&gt;</span>d<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转换结果是: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>嘿嘿嘿<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> &#x27;<span class="attr">https:</span>//<span class="attr">timgsa.baxxxx</span>&#x27;&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>拖过来的图片哦<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> &#x27;<span class="attr">https:</span>//<span class="attr">txx</span>&#x27;&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>a<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> &#x27;<span class="attr">test1</span>&#x27;&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>b<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>本文会从零基础出发达成这个目标.</p><p>讲解顺序: 正则介绍 &#x3D;&gt; 正则语法系统 &#x3D;&gt; 简单的例子讲解 &#x3D;&gt; 尝试实现目标以及碰到的问题 &#x3D;&gt; 实现目标</p><h2 id="什么是正则"><a href="#什么是正则" class="headerlink" title="什么是正则"></a>什么是正则</h2><p>初中时候学的通配符, 用<code>?</code>代表一个任意字符, 用<code>*</code>代表任意个任意字符来进行搜索, 正则也是如此. 比如:</p><p><code>123[abc]</code>匹配以下哪组字符?</p><ol><li>123c</li><li>123d</li><li>123e</li><li>123f</li></ol><p>选了1的朋友你已经知道正则是什么了. <code>123[abc]</code>就是正则, 代表匹配内容为: 前三个字符分别为123, 第四个字符是abc中的一个, 这个正则遇到<code>123a</code>, <code>123b</code>, <code>123c</code>都可以匹配成功, 其他任何都匹配失败.</p><h2 id="正则语法"><a href="#正则语法" class="headerlink" title="正则语法"></a>正则语法</h2><p>百度了正则表达式看到的东西都用了很多术语, 让人有点犯浑. 我经过学习把正则抽象为两个部分: <code>内容</code>和<code>修饰</code>.</p><p>看到一长串正则觉得稀里哗啦, 但是里面的每个符号一定都属于<code>内容</code>或是<code>修饰</code>.</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>内容的形式有3种: </p><ol><li>直接匹配: 举例就是刚才的<code>123[abc]</code>中的<code>123</code>, 这种匹配需要完全吻合才能匹配, <code>123</code>就唯一匹配<code>123</code>.</li><li>范围匹配: 用中括号表示, 也就是刚才例子中的<code>[abc]</code>. 这种情况也就是三选一. 任意匹配<code>a</code>或<code>b</code>或<code>c</code>, 而不是匹配<code>abc</code>. 还有两种形式: 加<code>-</code>来表示范围, 比如<code>[a-z]</code>; 表示排除范围内的<code>^</code>, 比如<code>[^abc]</code></li><li>匹配并选择缓存到子匹配: 用圆括号表示, 圆括号中的内容语法是”直接匹配”但会被记入缓存作为子匹配, 我记得我最初接触正则就是url rewrite, 写了url正则之后用<code>$1, $2</code>来重写url.</li></ol><p>在范围匹配中, 我们经常会用: 数字&#x2F;字母, 也就是<code>[0-9]</code>, <code>[a-zA-Z]</code>, 但是经常用到重复地写麻烦又看不能装逼了, 所以产生了一些快捷方式: <code>\d</code>代表<code>[0-9]</code>, <code>\w</code>代表<code>[0-9a-zA-Z_]</code>这正好是常用的用户名和密码的规则.</p><p>这里深入一下圆括号匹配的两个点. 作为拓展, 可以先不看一下的内容直接到下一部分.</p><p>因为圆括号中可以用<code>|</code>符号来表示或的关系, 但有时候又不想被加入缓存. 于是可以用<code>?:</code>来表示不需要缓存. 例子:<code>hello (?:world|regular expression)</code>, 用来匹配<code>hello world</code>或者<code>hello regular expression</code>, 但又不需要把<code>world</code>储存为缓存.</p><p>如果之前已经用圆括号, 那么期望之后出现同样的内容, 可以用<code>\1</code>这样<code>\</code>加数字来表示. 举个例子: 单引号和双引号, 我们要匹配<code>&#39;123&#39;</code>或者<code>&quot;123&quot;</code>, 但是要保持引号一致.  <code>(&#39;|&quot;)123\1</code>就可以解决问题.</p><h3 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h3><p>我把修饰部分分为数量修饰和边界修饰.</p><ol><li><p>数量修饰: 符号为{}, 想到了谷歌: <code>go&#123;2,4&#125;gle</code>这个正则可以匹配<code>google</code>, <code>gooogle</code>, <code>goooogle</code>, 代表这个<code>o</code>可以匹配2或者4次. 当然只是为了举例可以枚举, 因为<code>go&#123;2,&#125;gle</code>代表可以无限个<code>o</code>, 这样举例不方便.</p><p>与之前的范围匹配一样, 数量修饰也有快捷符号: <code>?</code>代表{0,1}, <code>*</code>代表{0,}, <code>+</code>代表{1,}. 都很形象, 不用死记, 就像刚才的d for digital, w for word. 看过一个例子: <code>colou?r</code> 这里的<code>?</code>表示可有可无, 美式和英式的拼写都可以匹配.</p><p>另外在”无上限”的数量的右边加<code>?</code>代表不贪婪匹配, 会匹配数量最少的内容. 举例: <code>a+</code>匹配<code>aaaaa</code>的结果为<code>aaaaa</code>, <code>a+?</code>匹配<code>aaaaa</code>的结果为<code>a</code>.</p></li><li><p>边界修饰: <code>^</code>表示字符串的头, <code>$</code>表示字符串的尾, <code>\b</code>表示字母与空格间的位置. 用来给匹配定位, 具体用法在实际中操作就会有具体感受了.</p><p>另外, 正则有一种匹配模式是<code>m</code>, 多行匹配模式, 这个情况里<code>^</code>和<code>$</code>也能匹配每一行的开头和结尾.</p></li></ol><h2 id="javascript相关函数"><a href="#javascript相关函数" class="headerlink" title="javascript相关函数"></a>javascript相关函数</h2><p>首先明确正则是”正则表达式”与”字符串”发生的匹配关系.</p><p>js有个对象是<code>RegExp</code>, 使用方法是<code>new RegExp(pattern, mode)</code>, 或者是用<code>/</code>包裹的字面量: <code>/pattern/mode</code>.</p><p>这里发现提到了<code>mode</code>匹配模式, 一共三种:</p><ol><li>g: 全局匹配, 匹配到一次不会停止, <code>/a/</code>匹配<code>aaa</code>, 如果没有g结果是一个<code>a</code>, 有g结果是3个<code>a</code>.</li><li>i: 忽略大小写.</li><li>m: 多行模式. 和之前提到的<code>\b</code>有联动.</li></ol><p>三个模式不互斥, 叠加的, 也就是可以<code>new RegExp(patter, &#39;gin&#39;)</code>.</p><p>正则的方法有:</p><ol><li><code>.test()</code>: 返回是否匹配成功, true或者false.</li><li><code>.exec()</code>: 失败返回null, 成功返回数组, 位置0是匹配内容, 之后是圆括号匹配的内容. 要注意的是exec是忽略’g’模式的.</li></ol><p>字符串的方法:</p><ol><li><code>.replace(pattern, replacement)</code>: replacement可以字符串或方法, 方法的话参数是匹配到的内容.</li><li><code>.match(pattern)</code>: 返回数组, 所有匹配到的内容.</li></ol><h2 id="分析一些简单常用的例子"><a href="#分析一些简单常用的例子" class="headerlink" title="分析一些简单常用的例子"></a>分析一些简单常用的例子</h2><h3 id="是否小数"><a href="#是否小数" class="headerlink" title="是否小数"></a>是否小数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isDecimal</span>(<span class="params">strValue </span>)  &#123;  </span><br><span class="line">   <span class="keyword">var</span>  objRegExp= <span class="regexp">/^\d+\.\d+$/</span>;</span><br><span class="line">   <span class="keyword">return</span>  objRegExp.<span class="title function_">test</span>(strValue);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>\d</code>代表数字, <code>+</code>代表至少有1个数字,  <code>\.</code>转移小数点.</p><p>连起来看就是: 至少一个数字(<code>\d+</code>) 小数点(<code>\.</code>) 至少一个数字(<code>\d+</code>) .</p><p><code>^</code>和<code>$</code>代表头尾, 真个字符串是小数的全部, 而不是包含小数.</p><h3 id="是否中文名"><a href="#是否中文名" class="headerlink" title="是否中文名"></a>是否中文名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ischina</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="regexp">/^[\u4E00-\u9FA5]&#123;2,4&#125;$/</span>;   <span class="comment">/*定义验证表达式*/</span></span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);     <span class="comment">/*进行验证*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个范围是中文的编码范围: <code>[\u4E00-\u9FA5]</code>, <code>&#123;2,4&#125;</code>匹配2<del>4个. 也就是匹配2</del>4个中文.</p><h3 id="是否八位数字"><a href="#是否八位数字" class="headerlink" title="是否八位数字"></a>是否八位数字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isStudentNo</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="regexp">/^\d&#123;8&#125;$/</span>;   <span class="comment">/*定义验证表达式*/</span></span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);     <span class="comment">/*进行验证*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否电话号码"><a href="#是否电话号码" class="headerlink" title="是否电话号码"></a>是否电话号码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isTelCode</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> reg= <span class="regexp">/^((0\d&#123;2,3&#125;-\d&#123;7,8&#125;)|(1[3584]\d&#123;9&#125;))$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分两个部分: 座机号和手机号, 用<code>|</code>隔开了.</p><p>座机号: 0开头的三位数或四位数 短杠 7~8位数字.</p><p>手机号: 第一位1, 第二位3584的一个, 剩下由9个数字凑满11位电话.</p><h3 id="邮箱地址"><a href="#邮箱地址" class="headerlink" title="邮箱地址"></a>邮箱地址</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsEmail</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迈向目标"><a href="#迈向目标" class="headerlink" title="迈向目标"></a>迈向目标</h2><p>这个章节开始整理实现需求的思路.</p><p>先回忆一下正则的规则, 其实很简单, 和加减乘除一样, 有各种符号: [], (), |, -, {}, +, *, ?. 当然也可以很复杂, 因为也和加减乘除一样, 可以嵌套, 而正则的符号本来就多, 嵌套起来更是晕, 有一些符号在不同地方有不同作用, 比如<code>\</code>和<code>^</code>.(思考题: 分析一下这两个符号有哪些作用, 在什么场景).</p><p>那么我们的目标是: 把一段html分析称rn的标签.</p><p>因为rn没有parse的功能, 所以不可以使用replace. (replace是代码高亮的常用手段).</p><p>所以我们必须把html分解成js对象, 再从js对象里去分析输出rn标签.</p><p>因为html标签分为多种, 为了保证完整性和可维护性, 要把各个标签的正则分开写, 也便于之后在分析每个片段的时候来取子匹配, 比如img标签的src, a标签的href.</p><p>经过研究, 正则是不可以拼接的, 只有字符串可以拼接. 所以我们要把不同标签的正则写成字符串, 再在需要的时候拼接. <code>new RegExp(pattern)</code>的pattern参数是可以接受字符串的.</p><h2 id="匹配text的难题与正则匹配的动作分析"><a href="#匹配text的难题与正则匹配的动作分析" class="headerlink" title="匹配text的难题与正则匹配的动作分析"></a>匹配text的难题与正则匹配的动作分析</h2><p>众所周知, 在html里的text是可以光秃秃的(在rn里必须加上Text标签). 那么如何匹配这光秃秃的东西呢, 我开始想了一个办法: 因为text都在标签之外, 也就是”夹在&gt;和&lt;中的字符”, 或者在开头(^)和&lt;间的, 或者&gt;和结尾($)间的. 结果标签全都匹配不到了.</p><p>原因是这样的, 如果有’g’的模式, 匹配的过程是这样的: </p><ol><li>进行第一次匹配, 匹配成功后把匹配部分排除待匹配内容.</li><li>进行第二次匹配, 匹配成功后把匹配部分排除待匹配内容.</li><li>直到匹配失败, 返回所有结果.</li></ol><p>举个例子: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;applebananaapple&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(apple|banana)/g</span>)</span><br></pre></td></tr></table></figure><p>结果是<code>[&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;]</code></p><p>如果把banana的最后一个字母和apple的第一个字母写成一个:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;applebananapple&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(apple|banana)/g</span>)</span><br></pre></td></tr></table></figure><p>那么结果就是<code>[&quot;apple&quot;, &quot;banana&quot;]</code>了.</p><p>反而利用了这个特点, 把text的正则写成: 不包含<code>&lt;&gt;/</code> (<code>[^&lt;&gt;/]+</code>), 并添加在最后一个匹配, 就能正确地匹配出text啦.</p><h2 id="揭晓答案"><a href="#揭晓答案" class="headerlink" title="揭晓答案"></a>揭晓答案</h2><p>写得急促也许有遗漏, 最后贴上完成需求的代码, 语言是rn, 在map输出的时候带着一些项目业务的逻辑请无视.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Text</span>, <span class="title class_">View</span>, <span class="title class_">Image</span>, <span class="title class_">Platform</span>, <span class="title class_">StyleSheet</span>, <span class="title class_">TouchableOpacity</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">ENVS</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;../../config/apiHost&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    必须props: @html: html内容</span></span><br><span class="line"><span class="comment">    可选props:  @style: 字体style; @magnifyImg: 显示大图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regex = &#123;  <span class="comment">// &#x27;_&#x27; for close tag</span></span><br><span class="line">    <span class="attr">p</span>: <span class="string">`&lt;p[^&gt;]*?&gt;`</span>,</span><br><span class="line">    <span class="attr">_p</span>: <span class="string">`&lt;\/p&gt;`</span>,</span><br><span class="line">    <span class="attr">span</span>: <span class="string">`&lt;span[^&gt;]*?&gt;`</span>,</span><br><span class="line">    <span class="attr">_span</span>: <span class="string">`&lt;\/span&gt;`</span>,</span><br><span class="line">    <span class="attr">br</span>: <span class="string">`&lt;br\/&gt;`</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="string">`&lt;a[^&gt;]*?href=(\&#x27;|&quot;)([^&gt;]+?)\\1[^&gt;]*?&gt;([^&lt;]+?)&lt;\\/a&gt;`</span>, <span class="comment">// $1 是标点符号用来处理匹配 $2 href的带引号的内容 $3 文件名(a标签的innerText),</span></span><br><span class="line">    <span class="attr">img</span>: <span class="string">`&lt;img[^&gt;]*?src=(&#x27;|&quot;)([^&gt;]+?)\\1[^&gt;]*?\\/&gt;`</span>, <span class="comment">// $1 标点符号 $2 src的内容</span></span><br><span class="line">    <span class="attr">text</span>: <span class="string">`[^&lt;&gt;/]+`</span>, <span class="comment">// 匹配剩下的, 一定要放在最后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tobeRemoved = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`(?:<span class="subst">$&#123;[regex.p, regex._p, regex.span, regex._span, regex.br].join(<span class="string">&#x27;|&#x27;</span>)&#125;</span>)`</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parseToAst = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`(?:<span class="subst">$&#123;[regex.a, regex.img, regex.text].join(<span class="string">&#x27;|&#x27;</span>)&#125;</span>)`</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parsed</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">html</span>.<span class="title function_">trim</span>()</span><br><span class="line">        <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>html attr not passed to component &#x27;parseHtml&#x27;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        matches = str.<span class="title function_">replace</span>(tobeRemoved, <span class="string">&#x27;&#x27;</span>).<span class="title function_">match</span>(parseToAst)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;matches.map((block, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    for (let [key, value] of Object.entries(regex)) &#123;</span></span><br><span class="line"><span class="language-xml">                        let res = new RegExp(value).exec(block)</span></span><br><span class="line"><span class="language-xml">                        if (res) &#123;</span></span><br><span class="line"><span class="language-xml">                            if (key === &#x27;text&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">                                return (</span></span><br><span class="line"><span class="language-xml">                                    <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;this.props.style&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;block&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                )</span></span><br><span class="line"><span class="language-xml">                            &#125;</span></span><br><span class="line"><span class="language-xml">                            if (key === &#x27;a&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">                                if (res[2].includes(&#x27;files&#x27;)) &#123; // 判断附件</span></span><br><span class="line"><span class="language-xml">                                    if (/[jpg|png|jpeg]/i.test(res[3])) &#123; // 判断图片</span></span><br><span class="line"><span class="language-xml">                                        let imgId = res[2].match(/\d+/)[0]</span></span><br><span class="line"><span class="language-xml">                                        return (</span></span><br><span class="line"><span class="language-xml">                                            <span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.props.magnifyImg &amp;&amp; this.props.magnifyImg(ENVS.production.api_base_url + &#x27;/files/&#x27; + imgId)&#125;&#125; &gt;</span></span><br><span class="line"><span class="language-xml">                                                <span class="tag">&lt;<span class="name">Image</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:</span> <span class="attr">100</span>, <span class="attr">height:</span> <span class="attr">100</span>, <span class="attr">margin:</span> <span class="attr">10</span>&#125;&#125; <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> <span class="attr">ENVS.production.api_base_url</span> + &#x27;/<span class="attr">files</span>/&#x27; + <span class="attr">imgId</span>&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                            <span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                        )</span></span><br><span class="line"><span class="language-xml">                                    &#125;</span></span><br><span class="line"><span class="language-xml">                                &#125;</span></span><br><span class="line"><span class="language-xml">                            &#125;</span></span><br><span class="line"><span class="language-xml">                            if (key === &#x27;img&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">                                return (</span></span><br><span class="line"><span class="language-xml">                                    <span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.props.magnifyImg &amp;&amp; this.props.magnifyImg(res[2])&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                                        <span class="tag">&lt;<span class="name">Image</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:</span> <span class="attr">100</span>, <span class="attr">height:</span> <span class="attr">100</span>, <span class="attr">margin:</span> <span class="attr">10</span>&#125;&#125; <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> <span class="attr">res</span>[<span class="attr">2</span>]&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                    <span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                )</span></span><br><span class="line"><span class="language-xml">                            &#125;</span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    &#125;</span></span><br><span class="line"><span class="language-xml">                &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>d3源码之d3-scale</title>
      <link href="/2018/04/23/d3-source-d3-scale/"/>
      <url>/2018/04/23/d3-source-d3-scale/</url>
      
        <content type="html"><![CDATA[<p>要尝试把之前用d3画的东西放到react-native上, 而rn是没有dom只有svg的lib, 那么就要研究下d3的实现了.</p><span id="more"></span><h2 id="背景-amp-目标"><a href="#背景-amp-目标" class="headerlink" title="背景&amp;目标"></a>背景&amp;目标</h2><p>之前用d3做了一个事件时间线, 用到了<code>d3-scale</code>, <code>d3-brush</code>, <code>d3-selection</code>. 那么在rn上无法对dom(其实是svg)进行<code>拿起来干</code>式的操作, 那么想在rn上模仿一个类似的时间线就要去了解一下d3的实现了.</p><p>所以决定从最简单的<code>d3-scale</code>开始, 这个lib算是个数学库, 不涉及dom操作, 在时间线的项目中使用到的api也不多, 那么目标就设为了解这几个api的运行流程.</p><ol><li><code>d3.scaleLinear()</code></li><li><code>.domain()</code>及<code>.range()</code></li><li><code>scale()</code>及<code>scale.invert()</code></li></ol><p>我也<a href="https://github.com/fjonas/d3-scale">fork</a>了一份代码用来写注释.</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>d3应该是从大而全拆成各个小module再互相引用的, 用了rollup, 从rollup.config看到入口是在根目录下的<code>index.js</code>, 而具体内容在<code>src</code>文件夹下, <code>index.js</code>的内容全是<code>export &#123;xx as xxx&#125; from &#39;./src/xx&#39;</code>. 这个目录结构相当简单, 适用于d3的所有小模块的.</p><h2 id="scaleLinear"><a href="#scaleLinear" class="headerlink" title="scaleLinear"></a>scaleLinear</h2><p>我们的目标是<code>d3.scaleLinear()</code>. 所以来到<code>src/linear.js</code>. <a href="https://github.com/fjonas/d3-scale/blob/master/src/linear.js">完整版</a>从这里看, 截取export的地方贴一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">linear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> scale = <span class="title function_">continuous</span>(deinterpolate, reinterpolate);</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">copy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 给scale添加copy方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">copy</span>(scale, <span class="title function_">linear</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">linearish</span>(scale); <span class="comment">// 给scale添加了些方法并返回scale, 所以核心还是第一句continuous()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个输出结构看出, 输出的是<code>scale</code>对象(应该是一个方法). 因为这里是linear, 所以对scale做了处理:<code>linearish</code>, 字面意思”线性化”, 所以结论是<strong>不同的scale的核心是同一个工厂, 再经过不同的包装重载一些方法来输出不同的scale</strong>.</p><p>那么我们要研究的就是: <strong><code>continuous(deinterpolate, reinterpolate)</code></strong>. 这三个变量何去何从都待我们一个个看过来.</p><h2 id="deinterpolate-reinterpolate"><a href="#deinterpolate-reinterpolate" class="headerlink" title="deinterpolate, reinterpolate"></a>deinterpolate, reinterpolate</h2><p>deinterpolate:</p><p>来源: countinous的<code>deinterpolateLinear</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deinterpolateLinear</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (b -= (a = +a)) <span class="comment">// b = b - a, 不知道为什么要花里胡哨</span></span><br><span class="line">      ? <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> (x - a) / b; &#125; <span class="comment">// 当a, b不相等, 返回 x 在 a, b中的比例. 也就是 x - a / b - a</span></span><br><span class="line">      : <span class="title function_">constant</span>(b); <span class="comment">// 当a, b相等 永远返回  0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reinterpolate:</p><p>来源: 另一个模块: <code>d3-interpolate</code>的<code>interpolateNumber</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a = +a, b -= a, <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b * t; <span class="comment">// return a + (b - a) * t</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单, 注释也写了, d3这个库有个特点就是花里胡哨, 而且各个小模块的花式还不同, 作者应该是在尝试各种招式~ 来总结一下:</p><p>这两个函数都接受两个参数, 是实际范围. 这两个函数都是在实际范围和x在范围内的位置做转换. 位置用数字来表示百分比.</p><p>deinterpolate返回的函数接收参数x: 实际点, 返回点在范围中的位置, 用0~1来表示.</p><p>reinterpolate返回的函数接收参数t: 位置, 返回这个位置对应的点.</p><p>后来发现在continuous的代码中有注释:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].</span></span><br><span class="line"><span class="comment">// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].</span></span><br></pre></td></tr></table></figure><h2 id="continuous"><a href="#continuous" class="headerlink" title="continuous"></a>continuous</h2><p><a href="https://github.com/fjonas/d3-scale/blob/master/src/continuous.js">完整版源码</a>在这里. 函数是下面这个样子的, 注释也贴上了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">continuous</span>(<span class="params">deinterpolate, reinterpolate</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> domain = unit,</span><br><span class="line">      range = unit,</span><br><span class="line">      interpolate = interpolateValue,</span><br><span class="line">      clamp = <span class="literal">false</span>,</span><br><span class="line">      piecewise,</span><br><span class="line">      output,</span><br><span class="line">      input;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    continuous返回值, 返回值调用任何方法的返回值都是这个.</span></span><br><span class="line"><span class="comment">    对piece wise做了处理, 把output和input置空,</span></span><br><span class="line"><span class="comment">    最后返回scale.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rescale</span>(<span class="params"></span>) &#123;</span><br><span class="line">    piecewise = <span class="title class_">Math</span>.<span class="title function_">min</span>(domain.<span class="property">length</span>, range.<span class="property">length</span>) &gt; <span class="number">2</span> ? polymap : bimap; <span class="comment">// 我们使用的都是length === 2的, 所以是bimap</span></span><br><span class="line">    output = input = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> scale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">scale</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (output || (output = <span class="title function_">piecewise</span>(domain, range, clamp ? <span class="title function_">deinterpolateClamp</span>(deinterpolate) : deinterpolate, interpolate)))(+x);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译:</span></span><br><span class="line"><span class="comment">        1. 输出: piecewise(domain, range, deinterpolate, interpolate)(x)</span></span><br><span class="line"><span class="comment">        2. clamp是通过scale.clamp()设置的, 超出范围是否纠正到范围内, 默认false, 如果是true会小小改写deinterpolate方法</span></span><br><span class="line"><span class="comment">        3. 在调用rescale()前都会保存当前输出(不重新计算, 因为结果肯定是一样的). rescale会在调用scale的任何方法时调用.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">invert</span> = <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (input || (input = <span class="title function_">piecewise</span>(range, domain, deinterpolateLinear, clamp ? <span class="title function_">reinterpolateClamp</span>(reinterpolate) : reinterpolate)))(+y);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        和上面scale一样, 调用了piecewise, 传了不同的参数~ 让我们到bimap里去研究吧.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">domain</span> = <span class="keyword">function</span>(<span class="params">_</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span> ? (domain = map.<span class="title function_">call</span>(_, number), <span class="title function_">rescale</span>()) : domain.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果不传参, 返回当前domain, 阻断链式操作</span></span><br><span class="line"><span class="comment">        如果传了, domain = _.map( a =&gt; +a), 然后返回rescale(), 也就是一顿操作再返回scale</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">range</span> = <span class="keyword">function</span>(<span class="params">_</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span> ? (range = slice.<span class="title function_">call</span>(_), <span class="title function_">rescale</span>()) : range.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        和domain一样, 可能range不一定要是数字.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">rangeRound</span> = <span class="keyword">function</span>(<span class="params">_</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> range = slice.<span class="title function_">call</span>(_), interpolate = interpolateRound, <span class="title function_">rescale</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">clamp</span> = <span class="keyword">function</span>(<span class="params">_</span>) &#123; <span class="comment">// 设置超出范围是否纠正到范围内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span> ? (clamp = !!_, <span class="title function_">rescale</span>()) : clamp;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">interpolate</span> = <span class="keyword">function</span>(<span class="params">_</span>) &#123; <span class="comment">// 这个本来是从d3-interpolate引入的, 修改这个会改变算法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span> ? (interpolate = _, <span class="title function_">rescale</span>()) : interpolate;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">rescale</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归纳:</p><ol><li>continuous()调用返回值是一个方法.</li><li>因为闭包, 所以返回的这个方法里保存了一些属性: domain, range, clamp等.</li><li>返回值是<code>scale()</code>, 就是我们使用的比例尺.</li><li>scale()相对的是scale.invert(), 使用的是同一个生成函数.</li><li>每次通过方法改变scale的属性(domain, range, clamp等)就会触发rescale().</li><li>rescale()的作用两个: 根据domain和range的维度来改变scale使用的函数; 重置缓存(因为属性不变输出是不变的所以不触发rescale()再次调用scale()不会重新计算).</li></ol><p>另外:</p><ul><li>我们使用场景domain和range维度都是2, 所以都用了<code>bimap</code>这个方法.</li><li>学到一个奇怪的用法: function还可以有自己的键值, 因为<code> (function () &#123;&#125;) instanceof Object === true</code>吧.</li></ul><h2 id="pow"><a href="#pow" class="headerlink" title="pow"></a>pow</h2><p>看完以后来看了一下scalePow()是如何实现的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">raise</span>(<span class="params">x, exponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -<span class="title class_">Math</span>.<span class="title function_">pow</span>(-x, exponent) : <span class="title class_">Math</span>.<span class="title function_">pow</span>(x, exponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> exponent = <span class="number">1</span>,</span><br><span class="line">      scale = <span class="title function_">continuous</span>(deinterpolate, reinterpolate),</span><br><span class="line">      domain = scale.<span class="property">domain</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">deinterpolate</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (b = <span class="title function_">raise</span>(b, exponent) - (a = <span class="title function_">raise</span>(a, exponent)))</span><br><span class="line">        ? <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> (<span class="title function_">raise</span>(x, exponent) - a) / b; &#125;</span><br><span class="line">        : <span class="title function_">constant</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reinterpolate</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    b = <span class="title function_">raise</span>(b, exponent) - (a = <span class="title function_">raise</span>(a, exponent));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">t</span>) &#123; <span class="keyword">return</span> <span class="title function_">raise</span>(a + b * t, <span class="number">1</span> / exponent); &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">exponent</span> = <span class="keyword">function</span>(<span class="params">_</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span> ? (exponent = +_, <span class="title function_">domain</span>(<span class="title function_">domain</span>())) : exponent;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scale.<span class="property">copy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">copy</span>(scale, <span class="title function_">pow</span>().<span class="title function_">exponent</span>(exponent));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">linearish</span>(scale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的返回值是<code>continuous(deinterpolate, reinterpolate)</code>.</p><p>只是重写了<code>deinterpolate</code>和<code>reinterpolate</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>d3-scale可以说是教科书式的工厂模式, 一个核心方法, 通过重写参数来提供不同api.</p><p>scaleLinear()的过程是:</p><ol><li>scaleLinear()返回值是一个带有内部属性的对象, 表面自己就是可以直接调用的方法.</li><li>通过一些方法来设置内部属性. domain和range默认是[0, 1].</li><li>核心算法就是加减乘除的比例尺. 通过domain和range和策略来输出结果.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> d3 </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue源码之virtual dom</title>
      <link href="/2018/04/03/vue-source-vnode/"/>
      <url>/2018/04/03/vue-source-vnode/</url>
      
        <content type="html"><![CDATA[<p>这次来看看vue的虚拟dom是咋肥色儿~</p><span id="more"></span><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>之前分析如何数据响应到视图最后发现是调用了<code>__patch()__</code>方法来生成&#x2F;diff<code>dom</code>的. 最后留下了2个问题~ 1. template或者el是如何被编译成render的. 2. patch的实现.</p><p>template或者el被编译成render差不多就是正则匹配~ 然后统一成render函数的格式, 所以我们直接用render函数套进patch可以知道patch的参数的样子, 可以先看patch的实现.</p><p>本文叙事方式为树藤摸瓜, 顺着看源码的逻辑走一遍, 查看的vue的版本为2.5.2. 我<a href="https://github.com/fjonas/vue">fork了一份</a>源码用来记录注释.</p><h2 id="开始了"><a href="#开始了" class="headerlink" title="开始了"></a>开始了</h2><p>先来承接上局的源码分析~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prevVnode) &#123; <span class="comment">// 初次加载, 只有_update方法更新vm._vnode, 初始化是null</span></span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>( <span class="comment">// patch创建新dom</span></span><br><span class="line">        vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">_parentElm</span>,</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">_refElm</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// no need for the ref nodes after initial patch</span></span><br><span class="line">      <span class="comment">// this prevents keeping a detached DOM tree in memory (#5851)</span></span><br><span class="line">      vm.<span class="property">$options</span>.<span class="property">_parentElm</span> = vm.<span class="property">$options</span>.<span class="property">_refElm</span> = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode) <span class="comment">// patch更新dom</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从这里看出~ 创建dom调用的时候传了6个参数, diff的时候传了2个参数. 那么就想一个例子来看创建和diff的过程.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render</span>: <span class="keyword">function</span> (<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="variable language_">this</span>.<span class="property">blogTitle</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是从vue文档的render function这里拿来的~ 现在我们就来看看这个例子的调用发生了什么~ (和之前一样是以web为例).</p><p>参数中的<code>_parentElm</code>和<code>_refElm</code>暂时没找到, 缓缓, 其中的<code>vnode</code>, <code>preVnode</code>, <code>vnode</code>都是<code>_render()</code>方法的返回值(上篇讲过了), 那么我们来看看<code>_render()</code>方法吧.</p><h2 id="render"><a href="#render" class="headerlink" title=" _render()"></a><code> _render()</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span> <span class="comment">// render是由template或el编译而来的, parentVnode是更新子component的</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// catch其实不需要看了, 都是做异常处理, _vnode是在vm._update的时候保存的, 也就是上次的状态或是null(init的时候给的)</span></span><br><span class="line">      <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">            vnode = vm.<span class="property">_vnode</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm.<span class="property">_vnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节选了一段代码, 这里做的事情就是: <code>render.call(vm._renderProxy, vm.$createElement)</code>, 或者在发生错误的时候尝试使用<code>renderError()</code>方法(好像之前也说过了), 如果再错误就避免系统崩溃创建一个空vnode<code>vnode = createEmptyVNode()</code>. 那么一切正常的话就是调用render方法, 我们把之前的例子套进去~</p><p><code>vm.renderProxy</code>之前说过就是<code>vm</code>. <code>$createElement</code>找到了在<code>src/core/vdom/create-element.js</code>. 代入例子结果为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$createElement(<span class="string">&#x27;h1&#x27;</span>, vm.<span class="property">blogTitle</span>)</span><br></pre></td></tr></table></figure><p>所以看一下<code>_createElement()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 对应例子的参数: context: vm, tag: &#x27;h1&#x27;, data: vm.blogTitle</span></span><br><span class="line">  ... <span class="comment">// 省略</span></span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag) <span class="comment">// 如果有旧的取旧的, 没得就获得, 用来判断svg或者math</span></span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// resolveAsset: 如果有 options.components[tag], 就返回他, 也就是返回了一个component</span></span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      <span class="comment">// 对这个情况在后面做处理~ 这里先正常返回</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    <span class="comment">// 另一种语法: 直接传component options的情况</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ns)) <span class="title function_">applyNS</span>(vnode, ns) <span class="comment">// 把ns放到vnode上</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) <span class="title function_">registerDeepBindings</span>(data) <span class="comment">// 对style和class做数据响应</span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>createElement里先判断了tag: 是否是字符串&#x2F;是否html标签&#x2F;是否自定义组件来调用<code>new VNode()</code>或是<code>createComponent()</code>.</p><p>VNode的构造函数啥都没做, 就保存下数据然后返回vnode. <code>createComponent()</code>又引入了好多, 子组件作为之后讨论的话题吧. </p><p>对于我们的例子~ 返回值就是<code>new VNode(&#39;h1&#39;, vm.blogTitle, undefined, undefined, undefined, vm)</code>. 也就是一个包含了这些信息的vnode对象.</p><p>那么来看<code>__patch__()</code>方法~</p><p><code>src/platforms/web/runtime/patch.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web/runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules <span class="keyword">from</span> <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the directive module should be applied last, after all</span></span><br><span class="line"><span class="comment">// built-in modules have been applied.</span></span><br><span class="line"><span class="keyword">const</span> modules = platformModules.<span class="title function_">concat</span>(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">patch</span>: <span class="title class_">Function</span> = <span class="title function_">createPatchFunction</span>(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>这里根据平台的node操作库和平台专有module来生成patch函数.</p><p>nodeOps在web中就是操作dom的动作了, document.createElement这种.</p><p>modules的值是各个声明周期调用的方法. 在<code>createPatchFunction()</code>里只有一小段代码关于调用的, 下面马上会贴. 下一节进入<code>createPatchFunction()</code>来看看<code>__patch__()</code>方法的面目.</p><h2 id="patch"><a href="#patch" class="headerlink" title="__patch__()"></a><code>__patch__()</code></h2><p>到核心了~ 先贴一下<code>createPatchFunction()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createPatchFunction</span> (backend) &#123;</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.<span class="property">length</span>; ++i) &#123; <span class="comment">// 把modules的各个生命周期执行的方法按照&quot;cbs.hookName = [function ()&#123;&#125;, function () &#123;&#125;]&quot;的格式推到cbs里.</span></span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.<span class="property">length</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(modules[j][hooks[i]])) &#123;</span><br><span class="line">        cbs[hooks[i]].<span class="title function_">push</span>(modules[j][hooks[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ... <span class="comment">// 省略大段方法</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) <span class="title function_">invokeDestroyHook</span>(oldVnode) <span class="comment">// 根据新旧vnode是否存在来判断是否要调用destroy钩子</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span> <span class="comment">// 是创建模式还是diff模式, 初始值diff模式</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123; <span class="comment">// 如果old vnode为空, 就是创建模式</span></span><br><span class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">createElm</span>(vnode, insertedVnodeQueue, parentElm, refElm) <span class="comment">// 创建dom, patch剩下所有代码都是diff</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ... <span class="comment">// diff dom的操作, 之后再贴</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下我们例子是怎么调用的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="title function_">__patch__</span>( <span class="comment">// patch创建新dom</span></span><br><span class="line">        vm.<span class="property">$el</span>, vnode, <span class="literal">false</span>, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">_parentElm</span>,</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">_refElm</span></span><br><span class="line">      )</span><br><span class="line">vm.<span class="title function_">__patch__</span>(prevVnode, vnode) <span class="comment">// diff的时候</span></span><br></pre></td></tr></table></figure><p>先来看创建, 创建dom的内容很简单: <code>createElm(vnode, insertedVnodeQueue, parentElm, refElm)</code>, 贴一下createElm的核心部分:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElm</span> (</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    parentElm,</span><br><span class="line">    refElm,</span><br><span class="line">    nested,</span><br><span class="line">    ownerArray,</span><br><span class="line">    index</span><br><span class="line">  ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">    <span class="keyword">const</span> children = vnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">const</span> tag = vnode.<span class="property">tag</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(tag)) &#123;</span><br><span class="line">      vnode.<span class="property">elm</span> = vnode.<span class="property">ns</span></span><br><span class="line">        ? nodeOps.<span class="title function_">createElementNS</span>(vnode.<span class="property">ns</span>, tag) <span class="comment">// 这个还是针对svg和math</span></span><br><span class="line">        : nodeOps.<span class="title function_">createElement</span>(tag, vnode) <span class="comment">// vnode.elm已经是dom了</span></span><br><span class="line">      <span class="title function_">setScope</span>(vnode) <span class="comment">// 如果有scoped的话给node的attr加上scope标识</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">createChildren</span>(vnode, children, insertedVnodeQueue) <span class="comment">// 处理子组件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">          <span class="title function_">invokeCreateHooks</span>(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm) <span class="comment">// 把dom插到父组件上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; data &amp;&amp; data.<span class="property">pre</span>) &#123;</span><br><span class="line">        creatingElmInVPre--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isComment</span>)) &#123;</span><br><span class="line">      vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createComment</span>(vnode.<span class="property">text</span>)</span><br><span class="line">      <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createTextNode</span>(vnode.<span class="property">text</span>)</span><br><span class="line">      <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的主要流程是: 判断是否有tag, 如果是的话, 创建tag的dom, 如果不是, 判断是否是注释来添加注释或文字节点.</p><p>创建dom:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vnode.<span class="property">elm</span> = vnode.<span class="property">ns</span></span><br><span class="line">        ? nodeOps.<span class="title function_">createElementNS</span>(vnode.<span class="property">ns</span>, tag) <span class="comment">// 这个还是针对svg和math</span></span><br><span class="line">        : nodeOps.<span class="title function_">createElement</span>(tag, vnode) <span class="comment">// vnode.elm已经是dom了</span></span><br></pre></td></tr></table></figure><p>贴上:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>这里的parentElm和refElm我竟然找了2小时没找到, 估摸着应该是父组件或是el. 之后再研究了.</p><p>createElemenNS的话就是针对svg和math~ 最后调用的就是<code>document.createElement(&#39;h1&#39;)</code>了(针对本文的例子), 然后调用<code>createChildren(vnode, children, insertedVnodeQueue)</code> 来把我们的<code>h1</code>创建文字子节点.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createChildren</span> (vnode, children, insertedVnodeQueue) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">checkDuplicateKeys</span>(children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="title function_">createElm</span>(children[i], insertedVnodeQueue, vnode.<span class="property">elm</span>, <span class="literal">null</span>, <span class="literal">true</span>, children, i) <span class="comment">// 递归调用createElm</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPrimitive</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    nodeOps.<span class="title function_">appendChild</span>(vnode.<span class="property">elm</span>, nodeOps.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(vnode.<span class="property">text</span>))) <span class="comment">// 是字的话简单地贴上就ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; diff dom的代码看不动了, vue的源码告一段落. 小总结: vnode是保存node信息的对象, 调用patch的时候调用平台专属的node操作来贴到真实dom上.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue源码之数据控制视图</title>
      <link href="/2018/03/26/vue-source-reactive-ui/"/>
      <url>/2018/03/26/vue-source-reactive-ui/</url>
      
        <content type="html"><![CDATA[<p>分析vue是如何实现数据改变更新视图的.</p><span id="more"></span><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>三个月前看了vue源码来分析如何做到响应式数据的, 文章名字叫<em>vue源码之响应式数据</em>, 最后分析到, 数据变化后会调用<code>Watcher</code>的<code>update()</code>方法. 那么时隔三月让我们继续看看<code>update()</code>做了什么. (这三个月用react-native做了个项目, 也无心总结了, 因为好像太简单了).</p><p>本文叙事方式为树藤摸瓜, 顺着看源码的逻辑走一遍, 查看的vue的版本为2.5.2. 我<a href="https://github.com/fjonas/vue">fork了一份</a>源码用来记录注释.</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>明确调查方向才能直至目标, 先说一下目标行为:  <strong>数据变化以后执行了什么方法来更新视图的.</strong> 那么准备开始以这个方向为目标从vue源码的入口开始找答案.</p><h2 id="从之前的结论开始"><a href="#从之前的结论开始" class="headerlink" title="从之前的结论开始"></a>从之前的结论开始</h2><p>先来复习一下之前的结论:</p><ul><li>vue构造的时候会在data(和一些别的字段)上建立Observer对象, getter和setter被做了拦截, getter触发依赖收集, setter触发notify.</li><li>另一个对象是Watcher, 注册watch的时候会调用一次watch的对象, 这样触发了watch对象的getter, 把依赖收集到当前Watcher的deps里, 当任何dep的setter被触发就会notify当前Watcher来调用Watcher的<code>update()</code>方法.</li></ul><p>那么这里就从注册渲染相关的Watcher开始.</p><p>找到了文件在<code>src/core/instance/lifecycle.js</code>中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br></pre></td></tr></table></figure><h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><p>渲染相关的Watcher是在<code>mountComponent()</code>这个方法中调用的, 那么我们搜一下这个方法是在哪里调用的. 只有2处, 分别是<code>src/platforms/web/runtime/index.js</code>和<code>src/platforms/weex/runtime/index.js</code>, 以web为例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此, 是<code>$mount()</code>方法调用了<code>mountComponent()</code>, (或者在vue构造时指定<code>el</code>字段也会自动调用<code>$mount()</code>方法), 因为web和weex(<a href="https://yo-cwj.com/2018/01/01/weex-quick-start/">什么是weex?之前别的文章介绍过</a>)渲染的标的物不同, 所以在发布的时候应该引入了不同的文件最后发不成不同的dist(这个问题留给之后来研究vue的整个流程).</p><p>下面是mountComponent方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el <span class="comment">// 放一份el到自己的属性里</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123; <span class="comment">// render应该经过处理了, 因为我们经常都是用template或者vue文件</span></span><br><span class="line">    <span class="comment">// 判断是否存在render函数, 如果没有就把render函数写成空VNode来避免红错, 并报出黄错</span></span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    <span class="comment">// 不看这里的代码了, 直接看else里的, 行为是一样的</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="comment">// 注册一个Watcher</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实只做了3件事:</p><ul><li>调用beforeMount钩子</li><li>建立Watcher</li><li>调用mounted钩子</li></ul><p>(哈哈哈)那么其实核心就是建立Watcher了.</p><p>看一下Watcher的参数: vm是this, updateComponent是一个函数, noop是空, null是空, true代表是RenderWatcher.</p><p>在Watcher里看了<code>isRenderWatcher</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>是的, 只是复制了一份用来在watcher第一次patch的时候判断一些东西(从注释里看的, 我现在还不知道是干嘛的).</p><p>那么只有一个问题没解决就是<code>updateComponent</code>是个什么东西.</p><h2 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h2><p>在Watcher的构造函数的第二个参数传了function, 那么这个函数就成了watcher的getter. 聪明的你应该已经猜到, 在这个<code>updateComponent</code>里一定调用了视图中所有的数据的getter, 才能在watcher中建立依赖从而让视图响应数据的变化.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么就去找<code>vm._update()</code>和<code>vm._render()</code>.</p><p>在<code>src/core/instance/render.js</code>找到了<code>._render()</code>方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span> <span class="comment">// todo: render和_parentVnode的由来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset _rendered flag on slots for duplicate slot check</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.<span class="property">$slots</span>) &#123;</span><br><span class="line">        <span class="comment">// $flow-disable-line</span></span><br><span class="line">        vm.<span class="property">$slots</span>[key].<span class="property">_rendered</span> = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.<span class="property">$scopedSlots</span> = _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span> || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// catch其实不需要看了, 都是做异常处理, _vnode是在vm._update的时候保存的, 也就是上次的状态或是null(init的时候给的)</span></span><br><span class="line">      <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">            vnode = vm.<span class="property">_vnode</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm.<span class="property">_vnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了:</p><ul><li>根据当前vm的render方法来生成VNode. (render方法可能是根据template或vue文件编译而来, 所以推论直接写render方法效率最高)</li><li>如果render方法有问题, 那么首先调用renderError方法, 再不行就读取上次的vnode或是null.</li><li>如果有父节点就放到自己的<code>.parent</code>属性里.</li><li>最后返回VNode</li></ul><p>所以核心是这句:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br></pre></td></tr></table></figure><p>其中的<code>render()</code>, <code>vm._renderProxy</code>, <code>vm.$createElement</code>都不知道是什么.</p><p>先看<code>vm._renderProxy</code>: 是<code>initMixin()</code>的时候设置的, 在生产环境返回vm, 开发环境返回代理, 那么我们认为他是一个可以debug的vm(就是vm), 细节之后再看.</p><p><code>vm.$createElement</code>的代码在vdom文件夹下, 看了下是一个方法, 返回值一个VNode.</p><p>render有点复杂, 能不能以后研究, 总之就是把template或者vue单文件和mount目标parse成render函数.</p><p><strong>小总结: vm._render()的返回值是VNode, 根据当前vm的render函数</strong></p><p>接下来看<code>vm._update()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">      <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录update之前的状态</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">    activeInstance = vm</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123; <span class="comment">// 初次加载, 只有_update方法更新vm._vnode, 初始化是null</span></span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>( <span class="comment">// patch创建新dom</span></span><br><span class="line">        vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">_parentElm</span>,</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">_refElm</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// no need for the ref nodes after initial patch</span></span><br><span class="line">      <span class="comment">// this prevents keeping a detached DOM tree in memory (#5851)</span></span><br><span class="line">      vm.<span class="property">$options</span>.<span class="property">_parentElm</span> = vm.<span class="property">$options</span>.<span class="property">_refElm</span> = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode) <span class="comment">// patch更新dom</span></span><br><span class="line">    &#125;</span><br><span class="line">    activeInstance = prevActiveInstance</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们关心的部分其实就是<code>__patch()</code>的部分, <code>__patch()</code>做了对dom的操作, 在<code>_update()</code>里判断了是否是初次调用, 如果是的话创建新dom, 不是的话传入新旧node进行比较再操作.</p><h2 id="vue的入口文件"><a href="#vue的入口文件" class="headerlink" title="vue的入口文件"></a>vue的入口文件</h2><p>现在<code>render()</code>方法和<code>__patch__()</code>方法都不在<code>core</code>文件夹中被定义, 那么现在来一起看看我们最终引用的<code>vue</code>对象的整体.</p><p>以webpack的vue项目为例, 用的是<code>vue.esm.js</code>, package.json的main字段不是他, 于是看build命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node scripts/build.js</span><br></pre></td></tr></table></figure><p>是用rollup把配置中的所有字段都对应地编译, 配置如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> builds = &#123;</span><br><span class="line">  <span class="comment">// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span></span><br><span class="line">  <span class="string">&#x27;web-runtime-cjs&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;web/entry-runtime.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;dist/vue.runtime.common.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;cjs&#x27;</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Runtime+compiler CommonJS build (CommonJS)</span></span><br><span class="line">  <span class="string">&#x27;web-full-cjs&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;dist/vue.common.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;cjs&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entity-decoder&#x27;</span> &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Runtime only (ES Modules). Used by bundlers that support ES Modules,</span></span><br><span class="line">  <span class="comment">// e.g. Rollup &amp; Webpack 2</span></span><br><span class="line">  <span class="string">&#x27;web-runtime-esm&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;web/entry-runtime.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;dist/vue.runtime.esm.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Runtime+compiler CommonJS build (ES Modules)</span></span><br><span class="line">  <span class="string">&#x27;web-full-esm&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;dist/vue.esm.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entity-decoder&#x27;</span> &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">    ... <span class="comment">// 以下省略, 还有很多...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找的文件<code>vue.esm.js</code>的入口文件找到啦, 是<code>web/entry-runtime-with-compiler.js</code>.</p><p>而在<code>web/entry-runtime-with-compiler.js</code>中, 又从<code>./runtime/index</code>引入了Vue, 最后才从<code>core/index</code>中引入Vue.</p><p>所以Vue的平台无关的内容放在<code>core</code>中, 最后打成dist的时候根据不同的发布平台(web, weex), 发布模式(browser, es-module)来给核心Vue对象挂载更多的方法和属性, 那么我们现在来看看web&#x2F;es-module这条路添加了些什么~</p><p>从<code>runtime/index</code>开始:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/index.js 部分代码</span></span><br><span class="line"><span class="comment">// install platform specific utils</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">mustUseProp</span> = mustUseProp</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">isReservedTag</span> = isReservedTag</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">isReservedAttr</span> = isReservedAttr</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">getTagNamespace</span> = getTagNamespace</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">isUnknownElement</span> = isUnknownElement</span><br><span class="line"></span><br><span class="line"><span class="comment">// install platform runtime directives &amp; components</span></span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">directives</span>, platformDirectives)</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">components</span>, platformComponents)</span><br><span class="line"></span><br><span class="line"><span class="comment">// install platform patch function</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__patch__</span> = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// public mount method</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载了一些常量和平台专属directive和component. 我们关心的<code>__patch__()</code>方法是在这里被挂上的, <code>$mount()</code>方法也是这个时候挂上的, 正是调用了<code>mountComponent()</code>.</p><p>然后看<code>web/entry-runtime-with-compiler.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// web/entry-runtime-with-compiler.js 部分代码</span></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123; <span class="comment">// 如果没有render方法就尝试把别的字段编译成render方法</span></span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123; <span class="comment">// 尝试template字段, 没有的话就获取el字段并编译成template</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="variable language_">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把template编译成render函数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        shouldDecodeNewlines, <span class="comment">// 检测浏览器的行为, 是否会把一些东西url-encode</span></span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>, <span class="comment">// 默认是双花括号 &#x27;&#123;&#123;&#x27; &#x27;&#125;&#125;&#x27;, 用来编译模板的</span></span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span> <span class="comment">// 默认是false, 如果true就不丢弃注释</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有if都没走到, 那么就没有render方法, 异常将在$mount的时候抛出. 这里没有做处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释都贴在上面的代码里了, 在这个文件里在<code>$mount()</code>方法里插入<code>render()</code>方法的注册, 总结为:</p><ul><li>如果有<code>render()</code>函数, 就用<code>render()</code>函数.</li><li>如果没有, 就用<code>template</code>属性编译成<code>render()</code>函数.</li><li>如果没有<code>template</code>属性, 就用找<code>el</code>属性所指的dom, 并把他编译成<code>template</code>.</li><li>最后用<code>template</code>(原来的<code>template</code>或是<code>el</code>编译成的)编译出<code>render()</code>函数.</li><li>如果是三无产品(<code>render()</code>, <code>template</code>, <code>el</code>都没有). 那么什么都不做, 这个Vue实例就没有<code>render()</code>函数, 但没有报错, 因为在<code>mountComponent()</code>的时候会报错.</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>vue的视图渲染是一种特殊的Watcher, watch的内容是一个函数, 函数运行的过程调用了render函数, render又是由template或者el的dom编译成的(template中含有一些被observe的数据). 所以template中被observe的数据有变化触发Watcher的update()方法就会重新渲染视图.</li><li>Vue的平台无关的内容在<code>core</code>中, 最后打成dist的时候根据不同的发布平台(web, weex), 发布模式(browser, es-module)来给核心Vue对象挂载更多的方法和属性(代码在platforms中). <code>render()</code>和<code>__patch__()</code>是在platforms里挂上的.</li></ul><h2 id="遗留"><a href="#遗留" class="headerlink" title="遗留"></a>遗留</h2><ul><li>template编译成render的实现</li><li><code>__patch__</code>和VNode的分析</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weex开发尝试</title>
      <link href="/2018/01/01/weex-quick-start/"/>
      <url>/2018/01/01/weex-quick-start/</url>
      
        <content type="html"><![CDATA[<p>经过尝试cordova, 发现一些不舒服的地方, 与预期又有比较大程度地违背了预期, 所以这次尝试使用weex.</p><span id="more"></span><h2 id="与cordova的区别"><a href="#与cordova的区别" class="headerlink" title="与cordova的区别"></a>与cordova的区别</h2><p>前一阵用过一次cordova来把web编译成app, 但是在进行http请求的时候因为是file协议, 所以无法发出http请求, 必须使用cordova插件, 而我们的目的是尽量复用web端的代码, 做到三端同构, 如果必须重写http问题还不大, 可是我们http里还包含拦截器等业务逻辑, 那么就有点难搞了.</p><p>另外一个区别是weex的性能和体验更接近原生, 这个之后会介绍. 那么就开始weex的开发环境试水.</p><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>先来说一下上次体验的<a href="/2017/11/09/use-cordova-distrubuting-a-web-to-an-app/">cordova</a>的流程:</p><ol><li>把vue的代码(项目源码)build成dist到cordova项目的www目录下</li><li>运行cordova build [平台]来把www下的文件build到platform&#x2F;[平台]下</li><li>用XCode IDE打开platform&#x2F;[平台]下的workspace文件</li><li>运行到虚拟机或真机上</li></ol><p>那么weex是如何的呢. 把1和2合并了, 其实不是合并, 是直接把vue语法的文件编译成平台相关的原生文件了. 所以可以把weex叫做vue native.</p><p>而之前cordova的做法其实是把整个项目都作为webview. 这样性能上是无法和weex比的.</p><p>我们知道vue使用了virtual dom, 实际已经把逻辑(数据&#x2F;js&#x2F;业务)和渲染分开了, 只要劫持vdom的render方法就能不把vdom渲染到dom上, 相应的, web里的bom也不存在, 相关的api也是不存在的, html便签也就不存在了. 后面的章节会来讲一下weex和vue的区别.</p><h2 id="项目的开发-x2F-发布流程"><a href="#项目的开发-x2F-发布流程" class="headerlink" title="项目的开发&#x2F;发布流程"></a>项目的开发&#x2F;发布流程</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>首先和<a href="/2017/11/09/use-cordova-distrubuting-a-web-to-an-app/">cordova</a>一样, 需要XCode IDE, cocoapod, node, npm等非常基础的东西. 然后要安装weex-toolkit和weexpack.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g weex-toolkit weexpack</span><br></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weexpack create projectName</span><br></pre></td></tr></table></figure><h3 id="添加平台"><a href="#添加平台" class="headerlink" title="添加平台"></a>添加平台</h3><p>(和corodova一样), 切到项目文件夹里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weexpack create platform ios</span><br></pre></td></tr></table></figure><h3 id="编译到平台"><a href="#编译到平台" class="headerlink" title="编译到平台"></a>编译到平台</h3><p>代码在src目录中(vue代码噢).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weex build ios // 编译</span><br><span class="line">weex run ios // 运行</span><br><span class="line">// (二选一)</span><br></pre></td></tr></table></figure><p>如果只进行了编译, 打开XCode IDE, 打开<code>platform/ios/xxx.workspace</code>, 就可以在虚拟机&#x2F;真机上运行了. (参考<a href="/2017/11/09/use-cordova-distrubuting-a-web-to-an-app/">cordova教程</a>)</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>之前一直以为开发<code>npm run serve</code>, 导致一直与实际不一致. 其实是<code>weex src/index.vue</code>, 然后在手机上安装<code>weex playground</code>, 保证手机电脑在同一局域网, 可以在手机上看效果.</p><h2 id="weex语法"><a href="#weex语法" class="headerlink" title="weex语法"></a>weex语法</h2><p>其实看似是vue语法, 其实完全不是web应用了. </p><ul><li>没有html标签, 只有一些内置标签. (其实是ios组件)</li><li>只支持部分css, 默认flex布局.</li></ul><p>还有一些内置的js方法. 总的来说, 其实是模拟vue语法的一个新的语法. 所以同样的也会遇到各种问题.</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>开发中会碰到一些与web开发不同的东西.</p><h3 id="text标签"><a href="#text标签" class="headerlink" title="text标签"></a>text标签</h3><p>因为没有html标签, weex中封装的div或a也不能有inner字, 是不显示的, 要加上text标签.</p><h3 id="icon-x2F-字体"><a href="#icon-x2F-字体" class="headerlink" title="icon&#x2F;字体"></a>icon&#x2F;字体</h3><p>weex(官方)推荐阿里的矢量图标库. <a href="iconfont.cn">iconfont</a>来加载icon.</p><p>把喜欢的icon加入购物车或者自己上传icon, 然后添加到自己的project(如果没有就创建). 然后查看<code>view the link</code>获得cdn地址, 我们选择ttf的地址来加载. 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> modal = weex.requireModule(<span class="string">&#x27;modal&#x27;</span>)</span><br></pre></td></tr></table></figure><p>并在<code>beforeCreate()</code>钩子里调用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> domModule = weex.requireModule(<span class="string">&#x27;dom&#x27;</span>);</span><br><span class="line">      domModule.<span class="title function_">addRule</span>(<span class="string">&#x27;fontFace&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;fontFamily&#x27;</span>: <span class="string">&quot;iconfont&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;src&#x27;</span>: <span class="string">&quot;url(&#x27;http://at.alicdn.com/t/xxxxx.ttf&#x27;)&quot;</span></span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>之后在你的节点使用<code>font-family: iconfont</code>就可以啦~ 例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;font-family: iconfont;&quot;</span>&gt;</span><span class="symbol">&amp;#xe602;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p>研究了一阵后, weex非常温柔, 我们只要把页面宽度设为750px. weex会帮我们适应设备噢~ 然后是css的阉割导致只能使用px不能使用rem啦.</p><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>之后当然还会碰到许多问题.</p><ul><li>statusbar如何改变.</li><li>如何解决请求&#x2F;跨域问题.</li><li>如何发布到安卓.</li><li>如何发包.</li><li>如何储存.(类似electron获取本地文件地址以及对应api)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> weex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue源码之响应式数据</title>
      <link href="/2017/12/22/vue-source-reactive-data/"/>
      <url>/2017/12/22/vue-source-reactive-data/</url>
      
        <content type="html"><![CDATA[<p>分析vue是如何实现数据响应的.</p><span id="more"></span><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>住了半个月院, 第一批90后已经痛风&#x2F;肝损&#x2F;腰突了. 腰突还很严重, 昨天做了核磁共振, 椎管已经压没了, 网上说1&#x2F;3就要手术, 害怕. 那么继续之前的工作.</p><p>现在回顾一下看数据响应的原因. 之前看了vuex和vue-i18n的源码, 他们都有自己内部的vm, 也就是vue实例. 使用的都是vue的响应式数据特性及<code>$watch</code>api. 所以决定看一下vue的源码, 了解vue是如何实现响应式数据.</p><p>本文叙事方式为树藤摸瓜, 顺着看源码的逻辑走一遍, 查看的vue的版本为2.5.2.</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>明确调查方向才能直至目标, 先说一下目标行为: </p><ol><li>vue中的数据改变, 视图层面就能获得到通知并进行渲染.</li><li><code>$watch</code>api监听表达式的值, 在表达式中任何一个元素变化以后获得通知并执行回调.</li></ol><p>那么准备开始以这个方向为目标从vue源码的入口开始找答案.</p><h2 id="入口开始"><a href="#入口开始" class="headerlink" title="入口开始"></a>入口开始</h2><p>来到<code>src/core/index.js</code>, 调了<code>initGlobalAPI()</code>, 其他代码是ssr相关, 暂不关心.</p><p>进入<code>initGlobalAPI</code>方法, 做了一些暴露全局属性和方法的事情, 最后有4个init, initUse是Vue的install方法, 前面vuex和vue-i18n的源码分析已经分析过了. initMixin是我们要深入的部分.</p><p>在<code>initMixin</code>前面部分依旧做了一些变量的处理, 具体的init动作为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">_self</span> = vm</span><br><span class="line"><span class="title function_">initLifecycle</span>(vm)</span><br><span class="line"><span class="title function_">initEvents</span>(vm)</span><br><span class="line"><span class="title function_">initRender</span>(vm)</span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line"><span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line"><span class="title function_">initState</span>(vm)</span><br><span class="line"><span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue启动的顺序已经看到了: 加载生命周期&#x2F;时间&#x2F;渲染的方法 &#x3D;&gt; beforeCreate钩子 &#x3D;&gt; 调用injection &#x3D;&gt; 初始化state &#x3D;&gt; 调用provide &#x3D;&gt; created钩子.</p><p>injection和provide都是比较新的api, 我还没用过. 我们要研究的东西在initState中.</p><p>来到initState:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>) <span class="comment">// 如果没有data, _data效果一样, 只是没做代理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做的事情很简单: 如果有props就处理props, 有methods就处理methods, …, 我们直接看<code>initData(vm)</code>. </p><h2 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h2><p>initData做了两件事: proxy, observe.</p><p>先贴代码, 前面做了小的事情写在注释里了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> <span class="comment">// 如果data是函数, 用vm作为this执行函数的结果作为data</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123; <span class="comment">// 过滤乱搞, data只接受对象, 如果乱搞会报警并且把data认为是空对象</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123; <span class="comment">// 遍历data</span></span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123; <span class="comment">// 判断是否和methods重名</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123; <span class="comment">// 判断是否和props重名</span></span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 判断key是否以_或$开头</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key) <span class="comment">// 代理data</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下proxy和observe是干嘛的.</p><p>proxy的参数: vue实例, <code>_data</code>, 键.</p><p>作用: 把vm.key的setter和getter都代理到vm._data.key, 效果就是vm.a实际实际是vm._data.a, 设置vm.a也是设置vm._data.a.</p><p>代码是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  <span class="attr">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">proxy</span> (<span class="attr">target</span>: <span class="title class_">Object</span>, <span class="attr">sourceKey</span>: string, <span class="attr">key</span>: string) &#123;</span><br><span class="line">  <span class="comment">// 在initData中调用: proxy(vm, `_data`, key)</span></span><br><span class="line">  <span class="comment">// target: vm, sourceKey: _data, key: key. 这里的key为遍历data的key</span></span><br><span class="line">  <span class="comment">// 举例: data为&#123;a: &#x27;a value&#x27;, b: &#x27;b value&#x27;&#125;</span></span><br><span class="line">  <span class="comment">// 那么这里执行的target: vm, sourceKey: _data, key: a</span></span><br><span class="line">  sharedPropertyDefinition.<span class="property">get</span> = <span class="keyword">function</span> <span class="title function_">proxyGetter</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[sourceKey][key] <span class="comment">// getter: vm._data.a</span></span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.<span class="property">set</span> = <span class="keyword">function</span> <span class="title function_">proxySetter</span> (val) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[sourceKey][key] = val <span class="comment">// setter: vm._data.a = val</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, sharedPropertyDefinition) <span class="comment">// 用Object.defineProperty来设置getter, setter</span></span><br><span class="line">  <span class="comment">// 第一个参数是vm, 也就是获取`vm.a`就获取到了`vm._data.a`, 设置也是如此.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理完成之后是本文的核心, initData最后调用了<code>observe(data, true)</code>,来实现数据的响应.</p><h2 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h2><p>observe方法其实是一个滤空和单例的入口, 最后行为是创建一个observe对象放到observe目标的<code>__ob__</code>属性里, 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span> (<span class="attr">value</span>: any, <span class="attr">asRootData</span>: ?boolean): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>) &#123; <span class="comment">// 只能是监察对象, 过滤非法参数</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">ob</span>: <span class="title class_">Observer</span> | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    ob = value.<span class="property">__ob__</span> <span class="comment">// 如果已被监察过, 返回存在的监察对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">// 符合下面条件就新建一个监察对象, 如果不符合就返回undefined</span></span><br><span class="line">    observerState.<span class="property">shouldConvert</span> &amp;&amp;</span><br><span class="line">    !<span class="title function_">isServerRendering</span>() &amp;&amp;</span><br><span class="line">    (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">_isVue</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.<span class="property">vmCount</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么关键是<code>new Observer(value)</code>了, 赶紧跳到Observe这个类看看是如何构造的.</p><p>以下是Observer的构造函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span> (<span class="attr">value</span>: any) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = value <span class="comment">// 保存值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>() <span class="comment">// dep对象</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">  <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// 自己的副本, 放到__ob__属性下, 作为单例依据的缓存</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123; <span class="comment">// 判断是否为数组, 如果是数组的话劫持一些数组的方法, 在调用这些方法的时候进行通知.</span></span><br><span class="line">    <span class="keyword">const</span> augment = hasProto</span><br><span class="line">      ? protoAugment</span><br><span class="line">      : copyAugment</span><br><span class="line">    <span class="title function_">augment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value) <span class="comment">// 遍历数组, 继续监察数组的每个元素</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value) <span class="comment">// 直到不再是数组(是对象了), 遍历对象, 劫持每个对象来发出通知</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了几件事:</p><ul><li>建立内部Dep对象. (作用是之后在watcher中递归的时候把自己添加到依赖中)</li><li>把目标的<code>__ob__</code>属性赋值成Observe对象, 作用是上面提过的单例.</li><li>如果目标是数组, 进行方法的劫持. (下面来看)</li><li>如果是数组就observeArray, 否则walk.</li></ul><p>那么我们来看看observeArray和walk方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment"> * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment"> * value type is Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(obj, keys[i], obj[keys[i]]) <span class="comment">// 用&#x27;obj[keys[i]]&#x27;这种方式是为了在函数中直接给这个赋值就行了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (<span class="attr">items</span>: <span class="title class_">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现, observeArray的作用是递归调用, 最后调用的方法是**<code>defineReactive</code>**, 可以说这个方法是最终的核心了.</p><p>下面我们先看一下数组方法劫持的目的和方法, 之后再看<code>defineReactive</code>的做法.</p><h2 id="array劫持"><a href="#array劫持" class="headerlink" title="array劫持"></a>array劫持</h2><p>之后会知道defineReactive的实现劫持的方法是<code>Object.defineProperty</code>来劫持对象的getter, setter, 那么数组的变化不会触发这些劫持器, 所以vue劫持了数组的一些方法, 代码比较零散就不贴了. </p><p>最后的结果就是: array.prototype.push &#x3D; function () {…}, 被劫持的方法有<code>[&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;]</code>, 也就是调用这些方法也会触发响应. 具体劫持以后的方法是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span> (...args) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args) <span class="comment">// 调用原生的数组方法</span></span><br><span class="line">   <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span> <span class="comment">// 获取observe对象</span></span><br><span class="line">   <span class="keyword">let</span> inserted</span><br><span class="line">   <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">       inserted = args</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">       inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted) <span class="comment">// 继续递归</span></span><br><span class="line">   <span class="comment">// notify change</span></span><br><span class="line">   ob.<span class="property">dep</span>.<span class="title function_">notify</span>() <span class="comment">// 出发notify</span></span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>做了两件事: </p><ol><li>递归调用</li><li>触发所属Dep的<code>notify()</code>方法.</li></ol><p>接下来就说最终的核心方法, defineReactive, 这个方法最后也调用了notify().</p><h2 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h2><p>这里先贴整个代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="comment">// 这个方法是劫持对象key的动作</span></span><br><span class="line">  <span class="comment">// 这里还是举例: 对象为 &#123;a: &#x27;value a&#x27;, b: &#x27;value b&#x27;&#125;, 当前遍历到a</span></span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>, <span class="comment">// &#123;a: &#x27;value a&#x27;, b: &#x27;value b&#x27;&#125;</span></span><br><span class="line">  <span class="attr">key</span>: string, <span class="comment">// a</span></span><br><span class="line">  <span class="attr">val</span>: any, <span class="comment">// value a</span></span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123; <span class="comment">// 判断当前key的操作权限</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="comment">// 获取对象本来的getter setter</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val) <span class="comment">// childOb是val的监察对象(就是new Observe(val), 也就是递归调用)</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val <span class="comment">// 如果本身有getter, 先调用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果有dep.target, 进行一些处理, 最后返回value, if里的代码我们之后去dep的代码中研究</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val <span class="comment">// 如果本身有getter, 先调用</span></span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; <span class="comment">// 如果值不变就不去做通知了, (或是某个值为Nan?)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>() <span class="comment">// 根据&quot;生产环境不执行&quot;这个行为来看, 这个方法可能作用是log, 可能是保留方法, 还没地方用?</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123; <span class="comment">// 如果本身有setter, 先调用, 没的话就直接赋值</span></span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal <span class="comment">// 因为传入参数的时候其实是&#x27;obj[keys[i]]&#x27;, 所以就等于是&#x27;obj[key] = newVal&#x27;了</span></span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal) <span class="comment">// 重新建立子监察</span></span><br><span class="line">      dep.<span class="title function_">notify</span>() <span class="comment">// 通知, 可以说是劫持的核心步骤</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释都在注释中了, 总结一下这个方法的做的几件重要的事:</p><ul><li>建立Dep对象. (下面会说调用的Dep的方法的具体作用)</li><li>递归调用. 可以说很大部分代码都在递归调用, 分别在创建子observe对象, setter, getter中.</li><li>getter中: 调用原来的getter, 收集依赖(Dep.depend(), 之后会解释收集的原理), 同样也是递归收集.</li><li>setter中: 调用原来的setter, 并判断是否需要通知, 最后调用<code>dep.notify()</code>.</li></ul><p>总结一下, 总的来说就是, 进入传入的data数据会被劫持, 在get的时候调用<code>Dep.depend()</code>, 在set的时候调用<code>Dep.notify()</code>. 那么Dep是什么, 这两个方法又干了什么, 带着疑问去看Dep对象.</p><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p>Dep应该是dependencies的意思. dep.js整个文件只有62行, 所以贴一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">target</span>: ?<span class="title class_">Watcher</span>;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line"><span class="comment">// 这是一个队列, 因为不允许有多个watcher的get方法同时调用</span></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="attr">_target</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">  <span class="comment">// 设置target, 把旧的放进stack</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) targetStack.<span class="title function_">push</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> () &#123;</span><br><span class="line">  <span class="comment">// 从stack拿一个作为当前的</span></span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来分析变量:</p><ul><li>全局Target. 这个其实是用来跟watcher交互的, 也保证了普通get的时候没有target就不设置依赖, 后面会解释.</li><li>id. 这是用来在watcher里依赖去重的, 也要到后面解释.</li><li>subs: 是一个watcher数组. sub应该是subscribe的意思, 也就是当前dep(依赖)的订阅者列表.</li></ul><p>再来看方法: </p><ul><li><p>构造: 设uid, subs. addSub: 添加wathcer, removeSub: 移除watcher. 这3个好无聊.</p></li><li><p>depend: 如果有Dep.target, 就把自己添加到Dep.target中(调用了<code>Dep.target.addDep(this)</code>).</p><p>那么什么时候有Dep.target呢, 就由<code>pushTarget()</code>和<code>popTarget()</code>来操作了, 这些方法在Dep中没有调用, 后面会分析是谁在操作Dep.target.(这个是重点)</p></li><li><p>notify: 这个是setter劫持以后调用的最终方法, 做了什么: 把当前Dep订阅中的每个watcher都调用<code>update()</code>方法.</p></li></ul><p>Dep看完了, 我们的疑问都转向了Watcher对象了. 现在看来有点糊涂, 看完Watcher就都明白了.</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>watcher非常大(而且打watcher这个单词也非常容易手误, 心烦), 我们先从构造看起:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: <span class="title class_">Object</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm <span class="comment">// 保存vm</span></span><br><span class="line">    vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>) <span class="comment">// 把watcher存到vm里</span></span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="comment">// 读取配置 或 设置默认值</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> <span class="comment">// 非生产环境就记录expOrFn</span></span><br><span class="line">      ? expOrFn.<span class="title function_">toString</span>()</span><br><span class="line">      : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="comment">// 设置getter, parse字符串, 并滤空滤错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用get获得值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注释都写了, 我来高度总结一下构造器做了什么事:</p><ul><li><p>处理传入的参数并设置成自己的属性.</p></li><li><p>parse表达式. watcher表达式接受2种: 方法&#x2F;字符串. 如果是方法就设为getter, 如果是字符串会进行处理:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse simple path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parsePath</span> (<span class="attr">path</span>: string): any &#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="comment">// 这里是vue如何分析watch的, 就是接受 &#x27;.&#x27; 分隔的变量.</span></span><br><span class="line">  <span class="comment">// 如果键是&#x27;a.b.c&#x27;, 也就等于function () &#123;return this.a.b.c&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理的效果写在上面代码的注释里.</p></li><li><p>调用<code>get()</code>方法.</p></li></ul><p>下面说一下get方法. <strong>get()方法是核心, 看完了就能把之前的碎片都串起来了</strong>. 贴get()的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">get () &#123;</span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// 进入队列, 把当前watcher设置为Dep.target</span></span><br><span class="line">  <span class="comment">// 这样下面调用getter的时候出发的dep.append() (最后调用Dep.target.addDep()) 就会调用这个watcher的addDep.</span></span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    <span class="comment">// 调用getter的时候会走一遍表达式,</span></span><br><span class="line">    <span class="comment">// 如果是 this.a + this.b , 会在a和b的getter中调用Dep.target.addDep(), 最后结果就调用了当前watcher的addDep,</span></span><br><span class="line">    <span class="comment">// 当前watcher就有了this.a的dep和this.b的dep</span></span><br><span class="line">    <span class="comment">// addDep把当前watcher加入了dep的sub(subscribe)里, dep的notify()调用就会运行本watcher的run()方法.</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">      <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="comment">// 走到这里已经通过了getter获得到了value, 或者失败为undefined, 这个值返回作为watcher的valule</span></span><br><span class="line">    <span class="comment">// 处理deep选项 (待看)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">      <span class="title function_">traverse</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">popTarget</span>() <span class="comment">// 移除队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>() <span class="comment">// 清理依赖(addDep加到newDep数组, 这步做整理动作)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释都在代码中了, 这段理解了就对整个响应系统理解了. </p><p>我来总结一下: (核心, 非常重要)</p><ul><li><p><strong>dep方面: 传入vue参数的data(实际是所有调用<code>defineReactive</code>的属性)都会产生自己的Dep对象.</strong></p></li><li><p><strong>Watcher方面: 在所有new Watcher的地方产生Watcher对象.</strong></p></li><li><p><strong>dep与Watcher关系: Watcher的get方法建立了双方关系:</strong></p><p><strong>把自己设为target, 运行watcher的表达式(即调用相关数据的getter), 因为getter有钩子, 调用了Watcher的addDep, addDep方法把dep和Watcher互相推入互相的属性数组(分别是deps和subs)</strong></p></li><li><p><strong>dep与Watcher建立了多对多的关系: dep含有订阅的watcher的数组, watcher含有所依赖的变量的数组</strong></p></li><li><p><strong>当dep的数据调动setter, 调用notify, 最终调用Watcher的update方法</strong>.</p></li><li><p>**前面提到dep与Watcher建立关系是通过<code>get()</code>方法, 这个方法在3个地方出现: 构造方法, run方法, evaluate方法. 也就是说, notify了以后会重新调用一次get()方法. (所以在lifycycle中调用的时候把依赖和触发方法都写到getter方法中了). **</p></li></ul><p>那么接下来要看一看watcher在什么地方调用的.</p><p>找了一下, 一共三处: </p><ul><li><p>initComputed的时候: (state.js) </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br></pre></td></tr></table></figure></li><li><p>$watch api: (state.js)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, expOrFn, cb, options)</span><br></pre></td></tr></table></figure></li><li><p>lifecycle的mount阶段: (lifecycle.js)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop)</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完源码就不神秘了, 写得也算很清楚了. 当然还有很多细节没写, 因为冲着目标来.</p><p>总结其实都在上一节的粗体里了.</p><h2 id="甜点"><a href="#甜点" class="headerlink" title="甜点"></a>甜点</h2><p>我们只从data看了, 那么props和computed应该也是这样的, 因为props应该与组建相关, 下回分解吧, 我们来看看computed是咋回事吧.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initComputed</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>, <span class="attr">computed</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm.<span class="property">_computedWatchers</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = <span class="title function_">isServerRendering</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="comment">// 循环每个computed</span></span><br><span class="line">    <span class="comment">// ------------</span></span><br><span class="line">    <span class="comment">// 格式滤错滤空</span></span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="property">get</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Getter is missing for computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot;.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      <span class="comment">// 为computed建立wathcer</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="comment">// 因为没有被代理, computed属性是不能通过vm.xx获得的, 如果可以获得说明重复定义, 抛出异常.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">defineComputed</span>(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">props</span> &amp;&amp; key <span class="keyword">in</span> vm.<span class="property">$options</span>.<span class="property">props</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已注释, 总结为:</p><ul><li>遍历每个computed键值, 过滤错误语法.</li><li>遍历每个computed键值, 为他们建立watcher, options为<code>&#123; lazy: true&#125;</code>.</li><li>遍历每个computed键值, 调用defineComputed.</li></ul><p>那么继续看defineComputed.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineComputed</span> (</span><br><span class="line">  <span class="attr">target</span>: any,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">userDef</span>: <span class="title class_">Object</span> | <span class="title class_">Function</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !<span class="title function_">isServerRendering</span>()</span><br><span class="line">  <span class="comment">// 因为computed除了function还有get set 字段的语法, 下面的代码是做api的兼容</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = shouldCache</span><br><span class="line">      ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">      : userDef</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = userDef.<span class="property">get</span></span><br><span class="line">      ? shouldCache &amp;&amp; userDef.<span class="property">cache</span> !== <span class="literal">false</span></span><br><span class="line">        ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">        : userDef.<span class="property">get</span></span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = userDef.<span class="property">set</span></span><br><span class="line">      ? userDef.<span class="property">set</span></span><br><span class="line">      : noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 除非设置setter, computed属性是不能被修改的, 抛出异常 (evan说改变了自由哲学, 要控制低级用户)</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.<span class="property">set</span> === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="variable language_">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其实核心就下面这步... 上面步骤的作用是和data一样添加一个getter, 增加append动作. 现在通过vm.xxx可以获取到computed属性啦!</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComputedGetter</span> (key) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">computedGetter</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        watcher.<span class="title function_">depend</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为computed可以设置getter, setter, 所以computed的值不一定是function, 可以为set和get的function, 很大部分代码是做这些处理, 核心的事情有2件:</p><ul><li>使用Object.defineProperty在vm上挂载computed属性.</li><li>为属性设置getter, getter做了和data一样的事: depend. 但是多了一步: <code>watcher.evalueate()</code>.</li></ul><p>看到这里, computed注册核心一共做了两件事:</p><ol><li>为每个computed建立watcher(lazy: true)</li><li>建立一个getter来depend, 并挂到vm上.</li></ol><p>那么dirty成了疑问, 我们回到watcher的代码中去看, lazy和dirty和evaluate是干什么的.</p><p>精选相关代码:</p><ul><li><p>(构造函数中) <code>this.dirty = this.lazy</code></p></li><li><p>(构造函数中) <code>this.value = this.lazy  ? undefined  : this.get()</code></p></li><li><p>(evaluate函数) </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evaluate () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>到这里已经很清楚了. 因为还没设置getter, 所以在建立watcher的时候不立即调用getter, 所以构造函数没有马上调用get, 在设置好getter以后调用evaluate来进行依赖注册.</p><p>总结: computed是watch+把属性挂到vm上的行为组合.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue源码 </tag>
            
            <tag> vue </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用cordova来为web应用做app壳</title>
      <link href="/2017/11/09/use-cordova-distrubuting-a-web-to-an-app/"/>
      <url>/2017/11/09/use-cordova-distrubuting-a-web-to-an-app/</url>
      
        <content type="html"><![CDATA[<p>想把一个网页发布成app要怎么做, 经过一番调研: phonegap, cordova, react native, weex. 这些可能是根据时间来的, apache买下了phonegap重命名成cordova, rn和weex的爹分别是fb和阿里, 推的web框架是react和vue. 目前weex不成熟, rn又强制用react, 所以决定先用cordova来做个皮包app.</p><span id="more"></span><p><a href="http://cordova.apache.org/">cordova</a>可以把web发布到很多平台, 安卓, 黑莓, iOS, winPhone, ubuntu, windos, OS X. (没错, 电脑平台也可以发布, 然而有什么意义, 应该没有native api).</p><p>那么现在先走第一步, 把一个网页发布成iOS应用(因为我用的是iPhone5s). <strong>本文的内容都是ios步骤, 安卓暂没研究, 这句话适用全文</strong>, 另外, 本文<strong>以构建<a href="https://github.com/fjonas/abandon">abandon</a>为例</strong>.</p><h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><p>参考了<a href="http://cordova.apache.org/docs/en/latest/guide/cli/index.html">如何创建cordova应用</a>和<a href="http://cordova.apache.org/docs/en/latest/guide/platforms/ios/index.html">iOS平台发布方法</a>, 成功地在自己的破烂手机上装上了你好世界. 下面记录一边流程, 因为我认为这个框架是不应该放在版本控制中的, 所以这个架子要记一下的.</p><h3 id="基础需求"><a href="#基础需求" class="headerlink" title="基础需求"></a>基础需求</h3><p>硬件上:</p><ul><li>一台苹果系统电脑</li><li>一台苹果系统手机</li><li>Xcode(并不硬, 为什么要写在这里)</li></ul><p>软件上:</p><ul><li>cordova: <code>npm i -g cordova</code></li><li>xcode-select: <code>xcode-select —install</code></li><li>ios-deploy: <code>npm i -g ios-deploy</code></li><li>cocoapods: <code>sudo gem install cocoapods</code></li></ul><p>软件的话都会在下面的步骤里写到的.</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>首先安装cordova, xcode-select, ios-deploy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g cordova ios-deploy</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>选择你的工作目录, 开始创建cordova目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cordova create cordova abandon.fjonas abandon</span><br><span class="line">// cordova create [路径] [id] [name]</span><br></pre></td></tr></table></figure><p>创建成功以后进入目录并添加发布的平台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd cordova</span><br><span class="line">cordova platform add ios</span><br><span class="line">cordova platform ls // 查看而已, 可选</span><br></pre></td></tr></table></figure><p>然后如果没有安装过上面所述的软件, 在这里就可以安装了. 执行检查命令, 根据检查命令的提示安装软件. 安装好再运行检查命令, 直到通过检查.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova requirements</span><br></pre></td></tr></table></figure><p>cordova的原理好像是把整个网页扔到webview里吧, web根目录是www, 里面已经放好了<code>index.html</code>了, 这次的实验项目用的是vue, 那么把项目的webpack输出改到这里就可以了, 当然真正的项目也要在这里进行<code>git clone</code>.</p><p>现在暂时用初始的网页来构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova build ios // 或者 cordova build 来构建全部平台</span><br></pre></td></tr></table></figure><p>然后运行模拟器来看效果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova emulate android</span><br></pre></td></tr></table></figure><p>现在用Xcode打开<code>platforms/ios/abandon.xcworkspace</code>, 选中根目录”abandon”, 在”signing”里选择一个team. 如果有错误按照提示就可以. 至于如何产生team certificate, 因为我之前弄electron的时候已经弄过了, 好像是在<code>Xcode=&gt;refrecens=&gt;acoount</code>里操作一下就可以了.</p><h3 id="模拟与安装"><a href="#模拟与安装" class="headerlink" title="模拟与安装"></a>模拟与安装</h3><p>Xcode左上有个三角的”播放”按钮, 右边有个下拉列表, 选择设备型号, 把自己手机连上USB, 自己的手机也会出现在列表里.</p><p>选择设备, 按”播放”(run), 就会开启模拟器.</p><p>选择自己的设备, 按播放, 就会把app装到自己手机里了. 就是这么简单.</p><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><h3 id="vue项目构建"><a href="#vue项目构建" class="headerlink" title="vue项目构建"></a>vue项目构建</h3><p>在cordova目录下跑<code>git clone https://github.com/fjonas/abandon.git —depth 1</code>把项目拉下来, 改一下webpack配置把输出放到<code>www</code>目录下就可以了. <a href="https://github.com/fjonas/abandon">代码</a>在这里.</p><h3 id="app图标"><a href="#app图标" class="headerlink" title="app图标"></a>app图标</h3><p><a href="http://cordova.apache.org/docs/en/7.x/config_ref/images.html#ios">cordova文档</a>中也有说如何添加自定义图标, <a href="https://developer.apple.com/library/content/qa/qa1686/_index.html">苹果开发文档</a>说了一些具体尺寸, 因为我暂时只考虑iPhone端, 那么很简单了.</p><p>我从网上随便找了个图片, 调整了一下, 然后分别导出为60, 120, 180, 40, 80, 29, 58七种大小的<strong>png</strong> (苹果开发文档说明一定要带透明通道的png), 并放到对应的目录下. 然后在<code>config.xml</code>里配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">platform</span> <span class="attr">name</span>=<span class="string">&quot;ios&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;60&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-60.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;120&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-60@2x.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;120&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-60@3x.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;180&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-40.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;80&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-40@2x.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;29&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-29.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;29&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">icon</span> <span class="attr">height</span>=<span class="string">&quot;58&quot;</span> <span class="attr">src</span>=<span class="string">&quot;res/icon/ios/Icon-29@2x.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;58&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allow-intent</span> <span class="attr">href</span>=<span class="string">&quot;itms:*&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allow-intent</span> <span class="attr">href</span>=<span class="string">&quot;itms-apps:*&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">platform</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小插曲, 60是图标, 29是任务界面的缩略图, 这都是用血试出来的.</p><p>然后运行<code>cordova build ios</code>, 在Xcode里run起来, app图标就变啦.</p><h3 id="图标工具"><a href="#图标工具" class="headerlink" title="图标工具"></a>图标工具</h3><p>因为适配各个图标太累, 想自己写个工具, 想在npm找注册名字的时候发现已经有小哥哥写好了工具, 名字叫<code>cordova-icon</code>和<code>cordova-splash</code>, 轮子可以造, 但不是在现在这种紧急的时候, 所以推荐使用噢, 很方便.</p><h2 id="trouble-shooting"><a href="#trouble-shooting" class="headerlink" title="trouble shooting"></a>trouble shooting</h2><h3 id="cordova-create-失败"><a href="#cordova-create-失败" class="headerlink" title="cordova create 失败"></a>cordova create 失败</h3><p>在cordova create的时候报了254错, 如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error: Uncaught, unspecified &quot;error&quot; event. (  Error from Cordova Fetch: Error: npm: Command failed with exit code 254 Error output:</span><br><span class="line">npm ERR! not a package /usr/local/lib/node_modules/.cordova_npminstall/node_modules/.7.1.0@cordova/node_modules/cordova-lib/node_modules/cordova-create/node_modules/cordova-app-hello-world/index.js</span><br><span class="line">npm ERR! addLocal Could not install /usr/local/lib/node_modules/.cordova_npminstall/node_modules/.7.1.0@cordova/node_modules/cordova-lib/node_modules/cordova-create/node_modules/cordova-app-hello-world/index.js</span><br><span class="line">npm ERR! Darwin 16.7.0</span><br><span class="line">npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;/usr/local/lib/node_modules/.cordova_npminstall/node_modules/.7.1.0@cordova/node_modules/cordova-lib/node_modules/cordova-create/node_modules/cordova-app-hello-world/index.js&quot;</span><br><span class="line">npm ERR! node v6.1.0</span><br><span class="line">npm ERR! npm  v3.8.6</span><br><span class="line">npm ERR! path /var/folders/81/f_57f26j30zcrgzy5pc2n0rc0000gn/T/npm-733-4cc4760b/unpack-99633e40/package.json</span><br><span class="line">npm ERR! code ENOENT</span><br><span class="line">npm ERR! errno -2</span><br><span class="line">npm ER</span><br></pre></td></tr></table></figure><p>原因是没装好, 我一开始用cpmn装的, 卸了重新用npm或者yarn装就行了. (实测是用npm装的).</p><h3 id="build失败"><a href="#build失败" class="headerlink" title="build失败"></a>build失败</h3><p>在运行<code>cordova build ios</code>以后报错, 签名错误, 只要在Xcode里设置好签名再运行就可以了.</p><h3 id="选择签名失败"><a href="#选择签名失败" class="headerlink" title="选择签名失败"></a>选择签名失败</h3><p>在cordova官网例子中的项目id<code>com.example.HelloWorld</code>选择签名的时候会报错, 原因不知道, 把名字改了就可以了, 我这里改成了<code>abandon.fjonas</code>, 是git地址的反写.</p><h3 id="连接手机失败"><a href="#连接手机失败" class="headerlink" title="连接手机失败"></a>连接手机失败</h3><p>在安装到手机的过程中, Xcode提示手机正忙. 这个是Xcode9的bug? 解决方案是重启Xcode, 重启手机, 也许只要重启一个就可以了, 我重启了2个, 问题解决了.</p><h3 id="构建以后白屏"><a href="#构建以后白屏" class="headerlink" title="构建以后白屏"></a>构建以后白屏</h3><p>这个问题非常大, cordova构建了vue的dist文件以后进去是白屏, 最后发现原因是cordova构建的时候js引入的目录错误了. 最后查到原因是webpack配置里<code>assetsPublicPath</code>设成了<code>/</code>, build的时候把这个杠加进去所以路径错了.</p><h3 id="状态栏设置失效"><a href="#状态栏设置失效" class="headerlink" title="状态栏设置失效"></a>状态栏设置失效</h3><p>cordova的<a href="http://cordova.apache.org/docs/en/7.x/reference/cordova-plugin-statusbar/index.html">官方状态栏插件</a>不管如何调用都无效, 经过一番调查, 因为cordova没跟上ios11(看起来cordova也已经deprecated了), 于是安装<code>cordova-plugin-disable-ios11-statusbar</code>这个插件就搞定了. 以后官方应该会更新官方插件吧. 这个作为暂时解决方案.</p><h3 id="fontawesome在手机上无效"><a href="#fontawesome在手机上无效" class="headerlink" title="fontawesome在手机上无效"></a>fontawesome在手机上无效</h3><p>我判断是<code>@font-face</code>在webview上无效, 那么就把配置里url-loader的limit参数加了3个0, 搞定了.</p><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>把网页弄到移动设备上会产生许多问题, 设计不同&#x2F;适配是小事, 前后端分离, 本地起server, 可能用到ssr等. 眼前最大的问题可能是数据储存到哪.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人本主义流派介绍</title>
      <link href="/2017/11/05/humanity-psychology/"/>
      <url>/2017/11/05/humanity-psychology/</url>
      
        <content type="html"><![CDATA[<p>人本主义流派从一个与之前相反的角度研究心理学, 在自我可控性上是心理学流派中最高的.</p><span id="more"></span><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>之前的学派多以客观存在的事分析心理, 人本学派强调”自由意志”与”人的尊严”. 例如, 一个人吸毒喝酒, 在前面的心理学派会分析他的经历, 出生等来分析行为的原因, 人本主义会把人的行为归因到意志, 也就是他想吸毒, 想喝酒. 所以人本主义是一门积极的心理学, 强调可以通过努力, 意志是可以做到许多困难的事的.</p><h3 id="人本主义基本要素"><a href="#人本主义基本要素" class="headerlink" title="人本主义基本要素"></a>人本主义基本要素</h3><p>人本主义有四个核心观点:</p><ul><li>个人责任: 人一定会为自己做的决定负责. 人做的每个决定, 今天娱乐还是工作, 接送孩子还是在家休息, 与朋友交往还是独自在家. 人最终会为所有自己的行为负责. <strong>每个人都有能力做自己想做的事, 成为想成为的人</strong>. 核心就是把行为归因为自身.</li><li>此时此地: 过去的已经过去, <strong>“今天是你余生中最年轻的一天”</strong>, 不管什么造就了你的过去, 你的未来都可以由自己决定.</li><li>个体的现象学: 每个个体都是特殊的, 别人为你提供的建议都极有可能是无效的. 只有自己救得了自己.</li><li>个人成长: 人的快感只来自于个人成长, 即完成困难的任务. 假设你拥有用不完的钱并和喜欢的人在一起, 你还是不会快乐. 诗人想要快乐就写诗, 作曲家想要快乐就作曲.</li></ul><h3 id="卡尔-罗杰斯"><a href="#卡尔-罗杰斯" class="headerlink" title="卡尔 罗杰斯"></a>卡尔 罗杰斯</h3><blockquote><p>理想的人生是一个过程, 而不是一种生活状态. 他是一个方向, 而不是一个终点. — 卡尔 罗杰斯</p></blockquote><p>这是上面刚提到的”个人成长”理论, 罗杰斯把”尝试通过努力争取获得满意生活”的人称为<strong>充分发挥功能的人</strong>.(下文简称为充发人).</p><h4 id="充分发挥功能的人的特点"><a href="#充分发挥功能的人的特点" class="headerlink" title="充分发挥功能的人的特点"></a>充分发挥功能的人的特点</h4><ul><li>充发人对过去的经历持开放态度. 不喜欢陷入熟悉的生活方式, 会寻求新体验, 而不是消极度日.</li><li>充发人相信自己的感觉. 不会在意其他人的看法, 一个充发的女性准备去剪发或是离职, 他不会因为任何他人的看法而不做准备做的事.</li><li>充发人更深刻的体验情感. 不论是积极情感还是消极情感, 充发人都体验得更深.</li></ul><h4 id="焦虑和防御"><a href="#焦虑和防御" class="headerlink" title="焦虑和防御"></a>焦虑和防御</h4><p>罗杰斯认为焦虑产生来自于自己对自己的看法与获得的信息不符. 例如, 我自我感觉是一个很漂亮的人, 当听到有人说我难看的时候我就可能会产生焦虑. 罗杰斯认为<strong>潜知觉</strong>会在收到有威胁的信息(如有人说我难看)的时候进行防御, 使信息不能流入意识, 以此来应对焦虑.</p><p>最普遍的防御是<strong>扭曲</strong>. 以上面的故事为例, 当听到有人说我难看, 我的反应可能是: 他是一个粗鲁的人, 或是他心情不好. 甚至断然的否定: 他在说的只是与我同名同姓的人.</p><p>扭曲和否认可以减轻焦虑, 但这种缓解是有代价的. 每一次扭曲都使我们离成为一个充发人越来越远. 一个人可能认为他是世上最令人满意的男士, 但没有任何证据说明这一点. 一个成绩很差的女生可能认为, 他是个天才, 只是因为他的思维太复杂, 他的老师无法理解. 如果一直这样, 人最后会走到<strong>混乱</strong>状态, 结果是更加焦虑.</p><h4 id="有条件的赞赏和无条件积极关注"><a href="#有条件的赞赏和无条件积极关注" class="headerlink" title="有条件的赞赏和无条件积极关注"></a>有条件的赞赏和无条件积极关注</h4><p>罗杰斯认为源头来自于父母对孩子的<strong>有条件的积极关注</strong>. 即孩子表现好就表现对孩子的爱, 在孩子犯错或表现不佳的时候就屏蔽对孩子的爱. 这使孩子从小学会防御, <strong>放弃真实情感和愿望, 只接受他们身上被父母赞许的部分</strong>. 换言之, 他们学会了拒绝自己的弱点和错误, 变得越来越不了解自己.</p><p>对于病人的治疗, 罗杰斯推荐使用本小标题的方式: 在病人告诉自己犯的错误时也表现出爱和接纳, 并在表现好的时候赞赏, 让病人接纳自己的错误.</p><h3 id="亚伯拉罕-马斯洛"><a href="#亚伯拉罕-马斯洛" class="headerlink" title="亚伯拉罕 马斯洛"></a>亚伯拉罕 马斯洛</h3><h4 id="需求层次理论"><a href="#需求层次理论" class="headerlink" title="需求层次理论"></a>需求层次理论</h4><p>马斯洛的需要层次理论大学上课就学过, 简而言之思路是: 当低层次的需要没被实现, 人就不会有高层次的需要. 另外, 当低层次的需要实现, 人就会有高层次需要. 这也是解释”人的欲望是无穷的”的一个角度. 来说一下需要层次:</p><ol><li>生理需要: 食物, 水, 空气.</li><li>安全需要: 安全, 稳定, 被保护, 组织, 秩序, 回避恐惧和慌乱.</li><li>归属和爱的需要: 与家人, 朋友的交往. 分为2种爱的类型: D型: 获得型的爱, B型: 付出型的爱.</li><li>自尊需要: 感觉自己有能力, 有成就, 被人实至名归的赞赏.</li><li>自我实现需要: 确认自我, 充分挖掘自我潜能.</li></ol><p>很明显第五个需要是不需要钱的, 这也是马云经常说”我不喜欢钱”的原因吧-v-.</p><h4 id="需求层次理论的补充"><a href="#需求层次理论的补充" class="headerlink" title="需求层次理论的补充"></a>需求层次理论的补充</h4><p>举些例子, 在一个不安全动荡的时代, 人可能忍受一段不幸福的婚姻或者一个军事独裁政权, 因为能带来稳定和安全感. 所以每个人都可能停留在需要的某个阶段而在保留这个阶段状态的基础上追求上一个层次的需要的状态.</p><p>另外其实一部分情况是不符合从低到高的. 例如:</p><ul><li>一些人在建立爱的需求前需要先满足自尊需求.</li><li>艺术家会放弃和亲友朋友交往来满足自己的创作欲望.</li><li>一些有理想的战士牺牲自己的生命.</li></ul><p>所以有时候需求不是按照层次来的, 也有时候一个行为会包含多个需求, 比如性行为.</p><h4 id="对心理健康的人的研究"><a href="#对心理健康的人的研究" class="headerlink" title="对心理健康的人的研究"></a>对心理健康的人的研究</h4><p>马斯洛研究了一些成功的人, 看看这些人身上有什么特质.</p><ul><li>接纳自己的缺点, 对自己的现状感觉良好.</li><li>受文化规范和习俗的约束少. 他们知道自己”应该”怎么做, 正是对自己的判断有信心, 所以不会受环境影响.</li><li>有自己领域的创造性.</li><li>朋友不多, 但友谊深厚.</li><li>有独处的强烈需要.</li><li>有较多的”高峰体验”.</li></ul><p>什么是高峰体验呢, 下一章会讲.</p><h3 id="最佳体验的心理"><a href="#最佳体验的心理" class="headerlink" title="最佳体验的心理"></a>最佳体验的心理</h3><p>那么什么会给人带来快乐, 如果一个好的工作, 一部好车, 或一个令人羡慕的家庭并没有持续地给我们带来快感, 那么带来快感的东西是什么.</p><h4 id="最佳体验"><a href="#最佳体验" class="headerlink" title="最佳体验"></a>最佳体验</h4><p>谈到最佳体验, 有人谈到爬山, 有人谈到打网球, 有人谈到做手术. 在描述最佳体验的时候人们的语言惊人的相似: <strong>任务具有挑战性, 必须全神贯注, 达到目的后可以带来掌控感, 真正的快乐来自于过程.</strong> 下面是最佳体验的8个特征:</p><ul><li>活动具有挑战性且需要技能: 任务具有很大的挑战性, 需要全神贯注, 但尚未困难到无法完成.</li><li>人的注意力完全被活动吸引: 人已经察觉不到自己和正在做的事情是分离的, 而这是自发和自动的.</li><li>活动有明确目标: 有志向工作的方向和逻辑要点.</li><li>有明确的反馈: 知道自己是否已经达到目的, 哪怕只是一种自我认定.</li><li>人的注意力全部急冲在正在干的工作上: 在产生涌流时, 人会忘记生活中不愉快的事情.</li><li>人获得一种个人控制感: 人在涌流中享受着令人激动的控制环境的体验.</li><li>人失去了自我意识: 因注意力集中于活动目标, 已无暇考虑关于自己的事.</li><li>人失去了时间感: 几小时往往像几分钟一样地过去, 但是相反的情况也会发生.</li></ul><h4 id="日常活动中的最佳体验"><a href="#日常活动中的最佳体验" class="headerlink" title="日常活动中的最佳体验"></a>日常活动中的最佳体验</h4><p>要对做的事情有兴趣, 喜欢做的事情而不是注重结果.</p><h3 id="治疗"><a href="#治疗" class="headerlink" title="治疗"></a>治疗</h3><p>罗杰斯提出了一种治疗方式.</p><p>因为罗杰斯认为只有病人自己最了解自己, 所以不像别的学派的心理咨询, 咨询师告诉病人他认为的病人的想法, 而是提供病人一个可以放松的, 可以看清自己的环境. 他的方法是: 重复病人的提问.</p><h2 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h2><h3 id="自我表露"><a href="#自我表露" class="headerlink" title="自我表露"></a>自我表露</h3><p>当两个陌生的人在一起聊天时, 其中一方会向另一方说一些自己的信息, 然后也会得到对方的回复, 这些交流就叫做自我表露, 自我表露涉及到私密程度的高低. 自我表露与心理健康有着双向因果关系.</p><h4 id="自我表露的相互性"><a href="#自我表露的相互性" class="headerlink" title="自我表露的相互性"></a>自我表露的相互性</h4><p>人和人的交往存在这一个规则: 自我表露的互相性, 即表露的隐私内容的互相性. 如果一方表露了比较隐私的话题, 对方也会用表露隐私程度相当的话题来回复. 表露互相性的原因是可以表现信任感从而产生人与人间交往的快感.</p><h4 id="朋友与恋人间的自我表露"><a href="#朋友与恋人间的自我表露" class="headerlink" title="朋友与恋人间的自我表露"></a>朋友与恋人间的自我表露</h4><p>朋友与恋人间的自我表露与陌生人间的自我表露有所不同, 是不需要相互性的.</p><p>研究表明自我表露程度高的恋人间关系越好, 当然表露的时候也不需要相互性, 并且恋人间的表露与陌生人的不同点是: 他们会用一些亲密语言, 并且知道表露的时机更合适, 也在更合适的时候结束对话.</p><h4 id="自我表露的性别差异"><a href="#自我表露的性别差异" class="headerlink" title="自我表露的性别差异"></a>自我表露的性别差异</h4><p>女性会进行更多的自我表露, 原因是因为男女社会角色关系, 男性与女性都在他们选择的亲密程度上轻松交流.</p><h4 id="表露创伤经历"><a href="#表露创伤经历" class="headerlink" title="表露创伤经历"></a>表露创伤经历</h4><p>表露创伤经历会在短期造成不适, 但长期来说对健康有利.</p><h3 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h3><p>孤独与孤立不同, 身边的人的多少不能说明人是否孤独. 虽然孤独是根据情境产生的, 但孤独的易感性也有跨时间的相对稳定性.</p><h4 id="长期孤独的人"><a href="#长期孤独的人" class="headerlink" title="长期孤独的人"></a>长期孤独的人</h4><p>高孤独程度与社交焦虑, 自我意识的高分以及自尊和果断性的低分相关. 孤独者可能性格内向, 焦虑, 对拒绝敏感, 更可能出现抑郁. 孤独的高分还跟悲观及消极情绪相关.</p><p>孤独者还会有健康危险. 社交性越高的人队疾病的抵抗力越好. 孤独对健康不利的原因孤独影响了人的身体活动, 压力, 和应对压力的方法.</p><h4 id="孤独的原因"><a href="#孤独的原因" class="headerlink" title="孤独的原因"></a>孤独的原因</h4><p>孤独者在与人交往时有被评价的低预期, 会更容易认为别人对自己评价较低. 孤独者谈话更多谈论自己, 并转入一个与谈伴兴趣无关的话题. 另外, 孤独者掌握不了自我表露的互相性原则, 对别人的表露做出不适合的反应.</p><h3 id="自尊"><a href="#自尊" class="headerlink" title="自尊"></a>自尊</h3><p>首先要区分自尊与自我概念, 自我概念是指自己认为自己是什么样的人, 自尊是指自己是不是喜欢自己. 自尊与其他人格变量一样, 有跨时间空间的稳定性. 虽然人在各个情况下对自己的评价不同, 但自尊高的人会更多自我欣赏和感觉良好.</p><h4 id="自尊与对失败的反应"><a href="#自尊与对失败的反应" class="headerlink" title="自尊与对失败的反应"></a>自尊与对失败的反应</h4><p>高自尊的人对失败更不在意, 因为自我感觉良好, 所以更不容易放弃. 是因为高自尊者靠一种个人策略来渐弱消极反馈的影响, 这个策略是通过关注自己的优点而不是所犯的错误, 对失败做出反应. 负面反馈会使低自尊者想到他们的错误与失败, 而相同反馈缺使高自尊者想到他们的能力和成就.</p><h4 id="自尊与文化"><a href="#自尊与文化" class="headerlink" title="自尊与文化"></a>自尊与文化</h4><p>亚裔文化的人比西方文化的人自尊低许多, 并且亚裔文化的人出国越多自尊越高. 原因当然是从小长大的环境, 价值观的培养.</p><h3 id="独处"><a href="#独处" class="headerlink" title="独处"></a>独处</h3><p>人有时候希望独处, 并不是因为内向或神经症, 也没有逃避人群的想法, 独处是人的需要.</p><h4 id="独处的时间"><a href="#独处的时间" class="headerlink" title="独处的时间"></a>独处的时间</h4><p>随着年龄增大, 人的独处时间越来越多, 独处可以剥离社交, 重建自我感觉.</p><p>另外有一部分人通过独处来发展自己的精神, 智力和创造力, 许多人通过隐居达到了很高的成就.</p><h4 id="独处偏好的个体差异"><a href="#独处偏好的个体差异" class="headerlink" title="独处偏好的个体差异"></a>独处偏好的个体差异</h4><p>独处偏好也是一种人格变量, 独处偏好高的人更能从独处中获得快乐与心理健康. 独处有7点精神好处:</p><ul><li>问题解决: 面临特殊问题或决策时提供了思考的机会.</li><li>内心平静: 感觉冷静和放松, 摆脱了日常生活压力.</li><li>自我发现: 获得对基本价值观和目标的启发, 认识到自己独特的优缺点.</li><li>创造性: 激发了表现自己的新想法和新方式的动机.</li><li>隐秘性: 在此期间以自己喜欢的任何方式行动, 不用担心社会约束和别人怎样看你.</li><li>灵性: 一种超越日常关切, 变成比个人更宽广的世界的一部分的感觉.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人格心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物学流派介绍</title>
      <link href="/2017/11/02/biological-psychology/"/>
      <url>/2017/11/02/biological-psychology/</url>
      
        <content type="html"><![CDATA[<p>生物流派心理学笔记</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>生物流派的主要思想是, 人的性格是基于物质基础的. </p><p>意识是如何存在的一直是人类未解的东西, 可能原因是我们用大脑来研究大脑是不可行的. 而可以确定的是意识是由大脑发出的, 所以大脑结构可以部分决定意识, 反过来说意识的改变, 性格的改变也可能是由改变神经结构导致的, 这也证明了性格的改变与健身减肥一样不是看了什么一下子变化, 而是持续锻炼的结果.</p><p>生物流派中有一个术语叫”气质”, 是指与生俱来的行为倾向, 也就是否定了”白纸”假设, 每个孩子都是一张白纸, 如何发展是看如何教育. 孩子天生就有抑制倾向或非抑制倾向.</p><h2 id="相关研究与结论"><a href="#相关研究与结论" class="headerlink" title="相关研究与结论"></a>相关研究与结论</h2><h3 id="大脑活动的不对称性"><a href="#大脑活动的不对称性" class="headerlink" title="大脑活动的不对称性"></a>大脑活动的不对称性</h3><p>研究发现大脑在感到快乐时左半球活动性更高, 在感到厌恶时右半球活动性更高. 也得到一个推测: 右撇子在思考问题时下意识向右看代表心情是开心的, 向左是厌恶.</p><p>而每个人的左右脑活动高低天生地不同. 所以有了个概念叫<strong>心境阈限</strong>, 因为左右脑活动高低不同, 一些人因为小事就难过, 一些人因为一些小事就开心.</p><h3 id="外向与内向"><a href="#外向与内向" class="headerlink" title="外向与内向"></a>外向与内向</h3><p>经过研究, 外向性是研究过的人格变量中遗传性最强的变量之一. 外向性和第2, 3, 8, 12对染色体有关系.</p><h4 id="外向性与偏好唤醒水平"><a href="#外向性与偏好唤醒水平" class="headerlink" title="外向性与偏好唤醒水平"></a>外向性与偏好唤醒水平</h4><p>人脑在安静的时候大脑具有一定唤醒水平, 根据人不同而高低不同. 外向的人唤醒水平低, 内向的人唤醒水平高, 我们的行为都试图把唤醒水平调整到达某个程度. 做以下比较:</p><p>内向者唤醒水平足够, 喜欢安静; 外向者唤醒水平不足, 喜欢喧闹来刺激大脑的唤醒水平.</p><p>内向者在喧闹的房间无法学习, 因为唤醒水平过高; 外向者在安静的房间无法学习, 会环顾四周可以分心的事物, 难以集中心思到学习上.</p><p>外向者在听力练习时如果速度突然变慢, 难度下降, 他们的成绩会突然降低, 内向者则不会.</p><h4 id="外向性与快乐"><a href="#外向性与快乐" class="headerlink" title="外向性与快乐"></a>外向性与快乐</h4><p>结论是外向者快乐. 原因是外向者喜欢社交, 社交使人快乐.</p><p>调查结果是外向者的积极心境得分是内向者的2倍.</p><p>外向者在获得信息时候的处理也会更积极. 如peace&#x2F;piece, mourning&#x2F;morning.</p><p>内向者唯一的好处是: 可以避免判断失误付出的代价. 因为他们不会冲动执行.</p><h3 id="进化人格心理学"><a href="#进化人格心理学" class="headerlink" title="进化人格心理学"></a>进化人格心理学</h3><p>进化心理学的核心思想是: <strong>现在存在的人格都是没有被淘汰顺利进化的</strong>. 也就是存在的人格都是优秀的, 合理的, 因为不合理的人格已经灭亡, 比如现在的人都贪吃, 只是因为不贪吃的人已经死光了. 但现在社会环境变化, 不贪吃已经死不掉, 现在还贪吃的反而导致死亡. 环境变化, 我们的被遗传的人格仍没变, 所以改变一些人格也是适应环境的表现. 这个结论可以推广至各个方面的普遍存在的人格如攻击性(有不爽就攻击), 择偶观念(男性的多偶倾向).</p><h4 id="焦虑与社会排斥"><a href="#焦虑与社会排斥" class="headerlink" title="焦虑与社会排斥"></a>焦虑与社会排斥</h4><p>人会因为认为自己想做的事会遭到社会(别人)的排斥而焦虑. 比如通奸, 侵害和掠夺他人财产. 焦虑导致人不做出不利于群居生活的行为, 群居生活更有利个人存活发展.</p><h4 id="选择配偶"><a href="#选择配偶" class="headerlink" title="选择配偶"></a>选择配偶</h4><p>先说基于进化心理学的根本解释, 之后再说推论, 因为生理不同, 男人可以试图与更多女人留下后代, 女人的生育代价高, 所以希望找到长期能对自己和后代负责的男人. <strong>所以男人的根本目的是留下自己的后代, 女人的目的稳定的家庭</strong>.</p><p>基于原因的推论:</p><ul><li>男人喜欢健康的女人(健康可以保证生育), 健康的表现是脸好看, 胸大, 头发长. (不健康的人不会拥有这些特征).</li><li>男人喜欢生育期的女人. 十几岁的男孩称喜欢比自己大的女性. 五十岁的男性称自己喜欢二十岁的女性. (专一的男性).</li><li>女性在排卵期会穿更暴露的衣服. (下意识选择, 这个时期会认为暴露的衣服好看).</li><li>男性喜欢比自己小的, 女性喜欢比自己大的.</li><li>女性需要的男性特征: 可依靠, 能挣钱, 有抱负, 事业心强.</li><li>男人在想获得配偶的时候会炫耀自己的经济, 房子, 车子. (与女性暴露对应)</li><li>女性对男性的喜欢与幽默感无关, 在可靠的前提下, 女性更喜欢支配性的男人.</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>关于人的性格, 脾气的结论是: 找到自己的节奏, 适合自己, 能让自己感觉最舒服, 最能发挥实力的状态最好, 不要学别人.</p><p>另外, 要明白时代的变迁. 自己自带的一些脾气也许是不利的, 能适应环境改变脾气(吃, 攻击, 性), 完成进化是优秀的有适应性的人的表现. 若不适应那么就会被淘汰. 也许以后的人都是不喜欢吃的人. 所以喜欢吃的人是无法留下后代的.(扯)</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人格心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理特质流派介绍</title>
      <link href="/2017/10/28/trait-psychology/"/>
      <url>/2017/10/28/trait-psychology/</url>
      
        <content type="html"><![CDATA[<p>特质流派是一个心理学的流派, 不同于弗洛伊德的精神分析流派, 特质流派从另一个角度分析人的心理.</p><span id="more"></span><h2 id="特质流派简介"><a href="#特质流派简介" class="headerlink" title="特质流派简介"></a>特质流派简介</h2><p><strong>特质</strong>是指一个人格维度, 依据是一个人在某一特征上表现的程度, 人格由不同特质维度构成. 人格特质具有跨时间和跨情境的稳定性. 最简单的例子就是试想象我们认识的某个人, 我们会相信他在各个情境下会做出某种表现, 也相信他一年以后或者几年以后的人格也是类似的. 说类似是因为特质流派认为人格可能缓慢发展.</p><p>**特质是连续的, 心理学家经常会描述特质的两端是什么, 例如愤怒-平静, 人在每个特质上都是成正态分布的(因为个体无联系性质一般成正态分布).**这是特质的基本特点, (剧透)之后的分析都会将一些特点分到几个特质维度上, <strong>每个人在各个维度都有自己的程度高低, 并不是指二选一</strong>.</p><h2 id="特质流派相关研究"><a href="#特质流派相关研究" class="headerlink" title="特质流派相关研究"></a>特质流派相关研究</h2><h3 id="成就动机"><a href="#成就动机" class="headerlink" title="成就动机"></a>成就动机</h3><p>成就需要是指”完成艰难任务; 通过掌握, 操纵或组织…来克服困难, 达到高标准; 超我自我”. 心理学者提出了成就动机的两种类型: <strong>内隐动机</strong>指我们没意识到的动机, 比如一个晚会上对投掷飞镖挑战的反应, 和<strong>自我归因动机</strong>或<strong>外显动机</strong>指意识到的动机, 比如我们在思考关于成就的选择和决定.</p><h4 id="高成就动机者的特点"><a href="#高成就动机者的特点" class="headerlink" title="高成就动机者的特点"></a>高成就动机者的特点</h4><p>他们是稳健的冒险者, 会做自己有较大把握的事情. 若别人看来风险大的事成就动机强的人还去尝试是因为他们认为他们做的决定是正确的.</p><p>他们把大量精力投入可能带来个人成就的工作上, 并且对琐碎的工作兴趣不大.</p><p>他们喜欢那些对结果负责的工作, 有反馈的工作, 这样能实现个人成就.</p><h4 id="对成功行为的预测"><a href="#对成功行为的预测" class="headerlink" title="对成功行为的预测"></a>对成功行为的预测</h4><p>成就的养成需要培养人的个人能力感. 父母要培养孩子的高成就动机要给支持与鼓励, 在过分干预和放任自流间找到平衡点, 并在孩子取得好成绩的时候给予奖励, 对这些成绩表现出热情.</p><p>对高成就需要者的预测: 他们比别人更可能取得经济上的成功. 缺点在于因为注重细节, 所以只能做好基层管理, 不擅长高层管理.</p><h4 id="归因"><a href="#归因" class="headerlink" title="归因"></a>归因</h4><p>归因指的是人在事情发生之后总结原因的内心戏, 比如重要的考试不及格, 人会认为考试太难或者自己没有认真学习等原因的心里动作.</p><p>归因有三个维度: </p><ul><li>稳定性: 人可以把自己表现归结为”稳定”的因素, 如智力, 另一端是归结为”不稳定”的理由, 如运气.</li><li>控制点: 归因来自内部, 如努力程度, 另一端是来自外部, 如考试难度.</li><li>可控性: 人能掌握导致成功和失败原因的程度.</li></ul><p>因为这部分比较重要, 画个表格:</p><table><thead><tr><th>稳定性</th><th>稳定归因</th><th>不稳定归因</th></tr></thead><tbody><tr><td></td><td>协调能力好</td><td>运气好</td></tr><tr><td></td><td>数学学习态度差</td><td>生病(如感冒)</td></tr><tr><td>控制点</td><td>内部归因</td><td>外部归因</td></tr><tr><td></td><td>格外努力</td><td>考试容易</td></tr><tr><td></td><td>学习技能差</td><td>竞争激烈</td></tr><tr><td>可控性</td><td>可控归因</td><td>不可控归因</td></tr><tr><td></td><td>动机强</td><td>家里富裕</td></tr><tr><td></td><td>学习不够</td><td>国家经济萧条</td></tr></tbody></table><p>每个人的归因在这三个维度上都有自己的程度.</p><p><strong>如何获得更高成就动机</strong>的结论是: 在好的结果时归因到内部会获得更多幸福感. 在坏的结果时归因到外部让下次有希望.</p><h4 id="成就目标"><a href="#成就目标" class="headerlink" title="成就目标"></a>成就目标</h4><p>成就目标指人们在成就情境中渴望达到的目标. 例如, 一个人可能想获得月度最佳销售奖, 另一个人可能把目标定位熟练地演奏一首钢琴曲.</p><p>成就目标分为<strong>掌握目标</strong>和<strong>成绩目标</strong>. 用一个例子来说明: 学一门课程的时候以对教材的理解和精通感来获得满足感为掌握目标, 以获得一个好成绩获得赞扬来获得满足感为成绩目标.</p><p>书里还提到另外一个维度: 害怕失败的维度, 分为趋近成功与避免失败.</p><p>来说一下<strong>结论</strong>: 研究者一致发现, 掌握目标会带来更高的成就. 掌握目标达成的效果更好, 更持久, 事后也更持久. (成绩目标在成绩发布或被赞扬之后就失去了持久力).</p><p>但是成绩目标也不是没有可取之处, 成绩目标同样是能获得成就动机的, 如何合理结合能使人获得更高的成就动机, 但仅限于<strong>成绩接近目标</strong>的情况, 这样会避免害怕失败而放弃目标.</p><p>同事会讨论上学和工作的区别, 哪个累 我认为成就目标就是一个方面, 总体来说, 大部分人上学更多的是成绩目标, 工作了更多的是掌握目标(可能行业也有差别). 概括来讲, 成绩目标是满分100, 目标60, 掌握目标满分100, 目标120, 事后能不断突破极限, 行业的创新就是从这里来的吧.</p><h3 id="A型性格-敌意与健康"><a href="#A型性格-敌意与健康" class="headerlink" title="A型性格, 敌意与健康"></a>A型性格, 敌意与健康</h3><p>A型性格是”心脏病易感行为方式”的人格维度. 另一端称作B型. A型者有克服困难的强烈动机, 会努力取得成就. 他们喜欢竞争, 权力和受赞赏, 也容易愤怒和好斗. 不喜欢浪费时间, 而喜欢以有激情的高效方式做事.</p><h4 id="A型性格表现"><a href="#A型性格表现" class="headerlink" title="A型性格表现"></a>A型性格表现</h4><ul><li>A型比B型有更强的获取成就的竞争性. 不管有没有最后期限这样的外部压力, A型都会为了成就努力工作.</li><li>A型有时间紧迫感. 他们感到时间宝贵, 不能浪费. 当B型者还在拖拖沓沓时, A型者已经急迫地投入工作</li><li>A型对挫折情境更易产生愤怒和敌意反应.</li><li>A型比B型成就更出色, 原因是A给自己设置了更高的目标.</li><li>A型对竞争更感兴趣更兴奋.</li><li>A型在学校选修课程更多, 奖学金更多, 课外活动和社会活动更多.</li></ul><h4 id="敌意与健康"><a href="#敌意与健康" class="headerlink" title="敌意与健康"></a>敌意与健康</h4><p>又经过一些研究, A型并不总是与心脏病易感有关, 而是A型由许多别的原因构成, 其中导致心脏病易感的原因是敌意, 没有敌意的A型人并没有心脏病易感倾向.</p><h3 id="社交焦虑"><a href="#社交焦虑" class="headerlink" title="社交焦虑"></a>社交焦虑</h3><p>一个例子说明定义: 在一个陌生人活动中, 一个女子见到任何人都能大方地自我介绍并聊起来, 一个男子来回走动, 好不容易说上话, 在几分钟内也结束谈话了. 这是社交焦虑的两个极端(焦虑与不焦虑).</p><p>社交焦虑与羞怯有极大联系, 而与内向无关. 社交焦虑的人一般不内向, 正因为不内向而向往社交才导致了社交焦虑, 内向的人是不想社交, 并不会产生焦虑.</p><h4 id="社交焦虑者的特征"><a href="#社交焦虑者的特征" class="headerlink" title="社交焦虑者的特征"></a>社交焦虑者的特征</h4><ul><li>在与不认识的人打交道时会感到尴尬和紧张.</li><li>认为自己蠢</li><li>认为别人不友好</li></ul><h4 id="对社交焦虑的解释"><a href="#对社交焦虑的解释" class="headerlink" title="对社交焦虑的解释"></a>对社交焦虑的解释</h4><p>研究者认为<strong>评价恐惧</strong>是社交焦虑的源头, 害怕别人对自己负面评价, 所以避免参加活动或通过沉默来减少对话时间.</p><p>回避目光也是一种策略, 目光是交流的开始, 社交焦虑者一直回避目光来回避交流来避免社交, 达到避免被评论的目的.</p><p>社交焦虑的人会尽量使对话变得<strong>简短</strong>和<strong>不具威胁性</strong>. 具体表现为他们在交流时会更多地赞同对方的观点, 并在轮到自己说的时候重复和解释对方的观点.</p><p>在个体主义文化中的人更多把注意力放在自己身上, 所以社交焦虑较少, 而集体主义文化中的人更羞怯, 因为更在乎集体中其他人对自己的看法.</p><h3 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h3><p>人的情绪就不用解释定义了, 特质流派的研究者找到了情绪的三个特征, 算是三个维度的特质: <strong>敏感性</strong>, <strong>强度</strong>和<strong>表达</strong>. </p><h4 id="敏感性"><a href="#敏感性" class="headerlink" title="敏感性"></a>敏感性</h4><p>敏感性又分为两个维度, 分别是积极情感与消极情感. 意思就是每个人在积极情感上有高低, 在消极情感上也有高低. 下面的表用一些词汇描述了这些情感的强弱:</p><table><thead><tr><th>强积极情感</th><th>强消极情感</th></tr></thead><tbody><tr><td>活跃</td><td>悲伤</td></tr><tr><td>兴高采烈</td><td>害怕</td></tr><tr><td>热情</td><td>敌意</td></tr><tr><td>兴奋</td><td>神经过敏</td></tr><tr><td>精神饱满</td><td>紧张</td></tr><tr><td>坚强</td><td>轻蔑</td></tr></tbody></table><table><thead><tr><th align="left">弱积极情感</th><th>弱消极情感</th></tr></thead><tbody><tr><td align="left">昏昏欲睡</td><td>休息</td></tr><tr><td align="left">无精打采</td><td>平静</td></tr><tr><td align="left">困乏</td><td>平缓</td></tr><tr><td align="left">懒散</td><td>放松</td></tr></tbody></table><p>来从几个角度分析:</p><p><strong>独立性</strong>: 两个维度的情感是否独立, 有时有联系: 积极情感强的时候一般消极情感弱: 例如, 感到高兴, 热情的人, 在消极的时候感到的是平静, 放松. 反之亦然: 例如, 积极情感弱的人, 表现为懒散困乏, 在消极的时候感到悲伤, 害怕的程度会更高.</p><p>这对我们的启发是, 把积极情感提高是一种让消极情感变弱的方法.</p><p>但事实更复杂, 两个维度的情感可能是独立的, 因为我们在看小说的时候可能同时体会很强的积极情感和很强的消极情感, 例如, 又高兴又悲伤的状况.</p><p><strong>各个情感与行为的联系</strong>: 积极情感与社交有联系, 消极情感与抱怨&#x2F;健康有联系. 但验证不了因果方向, 也就是不知道是社交导致积极情感高还是积极情感高导致社交好. 同样的是消极情感导致抱怨&#x2F;健康还是反过来, 暂时无法证实.</p><h4 id="情绪的强度"><a href="#情绪的强度" class="headerlink" title="情绪的强度"></a>情绪的强度</h4><p>这个定义也可以不解释, 来说一个例子: 两个人经历了相同的一天, 经历了相同的好事与坏事, 但是一个人的情绪波动较小, 另一个较大. 就称为情绪的强度.</p><p>说三个结论:</p><ul><li>情绪强度是固有人格, 与经历的环境无关, 上面的例子里两个人经历的事情相同, 但感受的情绪强度不同.</li><li>虽然情绪强度不同, 他们的快乐和幸福感是相同的. 只是强度高的人能体验更多积极情感, 但又被较强的消极情感抵消.</li><li>情绪的强度<strong>没有好坏之分</strong>, 只是<strong>体验快乐的方式不同</strong>. 比如艺术家情绪强度高, 情绪波动大, 科学家情绪强度低, 情绪波动小, 但是他们在快乐和失望的时候感受到的幸福感和挫折感是相同的.</li></ul><h4 id="情绪表达"><a href="#情绪表达" class="headerlink" title="情绪表达"></a>情绪表达</h4><p>有的人”情感外露”, 我们可以从走路, 说话感受他当时的情绪, 有的人一直不能被看出情绪怎么样, 这成为情绪表达.</p><p>情绪表达强有助于人际关系的和谐与满意.</p><p>情绪表达对心理健康有益.</p><h3 id="乐观主义与悲观主义"><a href="#乐观主义与悲观主义" class="headerlink" title="乐观主义与悲观主义"></a>乐观主义与悲观主义</h3><h4 id="素质性乐观主义"><a href="#素质性乐观主义" class="headerlink" title="素质性乐观主义"></a>素质性乐观主义</h4><p>对事情的评价有相对稳定的程度, 研究者把这个人格变量成为<strong>素质性乐观主义</strong>.</p><p>乐观程度高的人在对应逆境有更好的结果.</p><p>乐观主义的人更健康.</p><h4 id="防御性悲观主义"><a href="#防御性悲观主义" class="headerlink" title="防御性悲观主义"></a>防御性悲观主义</h4><p>来举个例子: 一个人在面临一个即将到来的事情前一直在想可能发生的错误.</p><p>防御性悲观主义有两个原因:</p><ul><li>这些人应对失败的方式之一就是提前定一个较低的预期. 对于他们来说, 一直预期失败, 失败刺激就会渐弱. 如果这样预期, 成功到来时, 体验的可能是更加甜蜜.</li><li>真正的失败的可能性会促使防御性悲观主义者更努力. 成功的喜悦似乎不足以激励这些人.</li></ul><p>提问: 防御性悲观主义和乐观主义的人完成工作的效果如何?</p><p>回答: 经过大量研究, 不管对自己预期如何, 相同水平的防御性悲观主义者和乐观主义者表现出了相同的工作结果.</p><p>又做了一个有意思的实验: 做一个算数测试, 逼防御性悲观者在测试前10分钟思考别的事情, 不给他机会思考失败的可能; 逼乐观主义者在测试前10分钟列举可能失败的原因. 也就是让两个性格的人分别做自己不愿意的事.</p><p>结果是: 表现都很差. 焦虑都很高.</p><p>所以结论可能是, 预测失败或是事前不去想, 分别是两种性格的人减少自己焦虑的方法, 焦虑是导致发挥失常的原因. 性格没有好坏, 只有舒适, 让自己舒适是最好的.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人格心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用charles进行https抓包</title>
      <link href="/2017/10/25/man-in-the-middle-https-proxy-with-charles/"/>
      <url>/2017/10/25/man-in-the-middle-https-proxy-with-charles/</url>
      
        <content type="html"><![CDATA[<p>之前用charles抓手机上的包做过一些小事情, 但是碰到https就停手了, 今天经同事指导成功地抓到了https的包.</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>为什么网上的教程不完全可用, 因为环境不同, 我使用的是iPhone5s with iOS 11.x, mbp with macOS 10.12.5, Charles 4.0.1.</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>http抓包的原理是手机和电脑在同一个局域网, 手机查看电脑的ip以后通过电脑的代理来上网, 电脑在代理的时候把包抓下来了.</p><p>https原理是, 本来你浏览器直接拿到服务器的证书, charles动态为服务器生成证书, 并用自己的跟证书对他签名. 结果就是: charles接受到服务器的证书, 同时你的浏览器接收到charles的证书, 所以你的浏览器通过ssl与charles交互, charles通过ssl与服务器交互, 你的整个流程仍然都是ssl的.</p><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>先说下http代理的操作过程, 可能有遗漏, 因为是太久前用的了.</p><ol><li>电脑手机连同一个网, 在电脑上敲shell<code>ifconfig|grep 192.168</code>查看电脑ip.</li><li>手机连上wifi, 设置手动代理, 填上ip和端口8888.</li><li>在charles的<code>proxy=&gt;proxy settings</code>里设置相关的内容.</li></ol><p>然后要弄ssl证书来抓https的包.</p><ol><li>charles:<code>help=&gt;ssl proxy=&gt;install charles root certificate</code>, 然后会弹出来keychain access, 看到<code>Charles Proxy</code>是红色的, 说明一下点了charles的菜单以后证书就已经生成好了, 弹出这个界面是要你手动改一下证书的权限, 双击证书把权限改成always trust然后关闭就可以了.</li><li>在手机浏览器打开<code>chls.pro/ssl</code>一路同意就可以了.</li><li>这个步骤是iOS10+多出来的, <a href="https://support.apple.com/en-nz/HT204477">看链接</a>.</li><li>charles<code>proxy=&gt;ssl proxy settings</code>在ssl proxy里add一个host<code>*</code>, port<code>443</code>就可以了. 也可以根据情况配置, 现在https越来越多, 几乎都是, 所以配这个问题不大.</li></ol><p>好了, 事情已经搞定. 附上<a href="https://www.charlesproxy.com/documentation/proxying/ssl-proxying/">文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新弗洛伊德理论介绍</title>
      <link href="/2017/10/21/freud-extension/"/>
      <url>/2017/10/21/freud-extension/</url>
      
        <content type="html"><![CDATA[<p>弗洛伊德引领了一大波心理学派, 当时这些学派都认为自己是否认弗洛伊德的, 但在后人看来这些学派都是以弗洛伊德理论的核心”无意识”为基础继续细化的, 与弗洛伊德体系没有矛盾, 所以这些学派称作为”新弗洛伊德主义”, 这些学派与弗洛伊德理论都属于精神分析流派.</p><span id="more"></span><h2 id="各个学派简介"><a href="#各个学派简介" class="headerlink" title="各个学派简介"></a>各个学派简介</h2><h3 id="阿尔弗雷德-阿德勒"><a href="#阿尔弗雷德-阿德勒" class="headerlink" title="阿尔弗雷德 阿德勒"></a>阿尔弗雷德 阿德勒</h3><p>阿德勒认为只有一种动机推动着人们, 称之为<strong>寻求优越</strong>. 阿德勒认为每个人从出生就带有自卑感, 起因是从小被爸妈照顾, 或是有兄弟, 从而推论出生顺序也影响人的自卑程度, 出生排行老二的孩子会尽力追赶他们的哥哥姐姐.</p><p>阿德勒还认为父母对孩子的爱护程度会引起孩子的不同性格, 溺爱会加重自卑感, 使孩子成人后难以独立, 忽视会导致孩子成人后难以拥有亲密关系.</p><h3 id="卡尔-荣格"><a href="#卡尔-荣格" class="headerlink" title="卡尔 荣格"></a>卡尔 荣格</h3><p>荣格的研究集中于<strong>集体无意识</strong>. 我们出生就会吸吮, 就依恋母亲, 之后会害怕黑暗, 相信存在一些掌控自然的神等. 仔细分析这些都属于无意识, 而并没有意识输入就存在了这些无意识, 荣格认为<strong>每个人都从祖先那里继承了无意识形象</strong>. 比如母亲, 父亲, 智慧老人, 太阳, 月亮, 英雄, 上帝和死亡.</p><p>有意思的是荣格认为”情人眼里出西施”并非结果而是原因, 因为每个人天生已经存在了无意识的形象, 也就是我们的情人本来就是我们心里的标准.</p><h3 id="埃里克-埃里克森"><a href="#埃里克-埃里克森" class="headerlink" title="埃里克 埃里克森"></a>埃里克 埃里克森</h3><p>埃里克建立了一个<strong>人格毕生发展模型</strong>. 他认为人格发展不是在儿童阶段的, 而是毕生的, 分为8个阶段, 每个阶段的发展结果分为两种, 一种是适应性的, 一种是非适应性的, 并会影响之后的人格. 下面是8个阶段:</p><h4 id="基本信任感-x2F-不信任感"><a href="#基本信任感-x2F-不信任感" class="headerlink" title="基本信任感&#x2F;不信任感"></a>基本信任感&#x2F;不信任感</h4><p>是出生一岁左右, 有没有获得足够的关爱导致的结果.</p><h4 id="自主性-x2F-羞怯和怀疑"><a href="#自主性-x2F-羞怯和怀疑" class="headerlink" title="自主性&#x2F;羞怯和怀疑"></a>自主性&#x2F;羞怯和怀疑</h4><p>一岁以后, 儿童会尝试操纵周围的环境和东西, 如果父母不组织他, 儿童就会形成自主性, 反之不让儿童探索环境会导致羞怯.</p><h4 id="主动性-x2F-内疚感"><a href="#主动性-x2F-内疚感" class="headerlink" title="主动性&#x2F;内疚感"></a>主动性&#x2F;内疚感</h4><p>随着儿童开始与其他儿童一起玩, 儿童开始寻找玩伴, 编排游戏, 和其他社交活动, 这使儿童产生主动性, 如果没有这样的经历就会形成内疚感.</p><h4 id="勤奋感-x2F-自卑感"><a href="#勤奋感-x2F-自卑感" class="headerlink" title="勤奋感&#x2F;自卑感"></a>勤奋感&#x2F;自卑感</h4><p>儿童进入了小学, 如果在成绩&#x2F;体育等方面获得了名次, 在于同龄人的比较中觉得自己是优秀的, 孩子就获得了成就感, 导致勤奋感. 比较下自己较差的孩子形成了无能感, 导致自卑感.</p><h4 id="同一性-x2F-角色混乱"><a href="#同一性-x2F-角色混乱" class="headerlink" title="同一性&#x2F;角色混乱"></a>同一性&#x2F;角色混乱</h4><p>青少年会产生一个问题: “我是谁?”, 如果通过提问&#x2F;宗教等方式解决了这个问题, 青少年就产生了同一性, 否则产生角色混乱</p><h4 id="亲密感-x2F-孤独感"><a href="#亲密感-x2F-孤独感" class="headerlink" title="亲密感&#x2F;孤独感"></a>亲密感&#x2F;孤独感</h4><p>成年初期人会面对的是建立亲密关系的问题, 这个问题一般是结婚. 如果能结婚并建立亲密的关系, 人就有了亲密感. 就算结婚, 没有建立亲密的关系, 人也会产生孤独感.</p><h4 id="繁衍感-x2F-停滞感"><a href="#繁衍感-x2F-停滞感" class="headerlink" title="繁衍感&#x2F;停滞感"></a>繁衍感&#x2F;停滞感</h4><p>繁衍感总的来说是教育下一代, 让自己影响年轻人的感觉, 这个人格阶段持续的时间非常久. 没有成功影响年轻人的就会产生停滞感.</p><h4 id="自我完整感-x2F-绝望感"><a href="#自我完整感-x2F-绝望感" class="headerlink" title="自我完整感&#x2F;绝望感"></a>自我完整感&#x2F;绝望感</h4><p>对过去经历的总结和对生命必然性的反思, 使老年人进入了这两种感受的其中一种.</p><h3 id="卡伦-霍尼"><a href="#卡伦-霍尼" class="headerlink" title="卡伦 霍尼"></a>卡伦 霍尼</h3><p>有三种人: </p><ul><li>看起来很友善, 热情. 不善独处, 与人保持不了长久关系.</li><li>几乎所有人都不喜欢他, 对别人说尖刻伤人的话, 现在是个残酷无情的商人.</li><li>他很少参加同事的社交活动, 因此再有活动人们都不叫他来参加.</li></ul><p>霍尼把这三个行为成为<strong>神经症</strong>. 特点是他们陷入了自我挫败的人际关系方式. 讽刺的是, 他们破坏性的人际交往方式正是他们避免由无能让人际关系变好产生的焦虑的一种防御机制.</p><p>上面三种神经症患者的交往方式分别称为:</p><ul><li><strong>接近人群</strong>: 彰显自己的无助感来应对焦虑. 他们接近别人不是爱别人, 而是依赖&#x2F;依附于人. 他们不是分享感情, 只是得到感情. 所以每段关系都不会长久.</li><li><strong>反对人群</strong>: 这种应对焦虑的方式是和他人战斗. 攻击或伤害其他人对自己的安全感和无能感进行补偿, 这种神经症方式以<strong>外化</strong>为特征, 很像弗洛伊德提出的投射概念. 只有在得到好处的时候才与别人建立关系. 与这些人交往一定是肤浅的.</li><li><strong>脱离人群</strong>: 他们以置身于人群外的方式应对焦虑. 他们把回避情感, 爱和友谊当做处世之道. 爱上这类人肯定是一个错误, 因为感情将得不到回应.</li></ul><h2 id="焦虑和应对策略"><a href="#焦虑和应对策略" class="headerlink" title="焦虑和应对策略"></a>焦虑和应对策略</h2><p>焦虑分为几种, <strong>现实焦虑</strong>指被陌生人跟踪或经历了车祸, 这些自己意识到焦虑原因的焦虑. 弗洛伊德研究的是无意识的焦虑: 当不被接受的本我冲动快要逼近意识的时候, 人们体验到了<strong>神经性焦虑</strong>. 这是导致自我启用防御机制的那种焦虑. 而违背了超我的时候产生的叫<strong>道德焦虑</strong>, 也就是一种内疚体验.</p><h3 id="应对焦虑"><a href="#应对焦虑" class="headerlink" title="应对焦虑"></a>应对焦虑</h3><p>比如看一场关于工业事故的纪录片, 人们看到了电锯穿过工人的肚子, 一部分人会说这是部电影, 不是真实的, 另一部分人在分析电影的特效是如何做的. 这两种应对焦虑的方式听起来像弗洛伊德的两种防御机制: 拒绝和理智化.</p><p>而每个人在应对焦虑的时候会采取不同的方式, 这个方式叫做<strong>对应风格</strong>.</p><h3 id="应对策略的类型"><a href="#应对策略的类型" class="headerlink" title="应对策略的类型"></a>应对策略的类型</h3><p>应对策略类型分为三种: </p><ul><li><strong>问题中心策略</strong>: 直接关注问题, 解决问题来克服焦虑.</li><li><strong>情绪中心策略</strong>: 减轻伴随问题而来的情绪压力来克服焦虑. 比如认为挫折对人也是有好处的.</li><li><strong>回避策略</strong>: 使用回避策略的人不让自己去想产生焦虑的事情, 或者戒酒消愁转移自己的焦虑.</li></ul><h3 id="应对策略的效果"><a href="#应对策略的效果" class="headerlink" title="应对策略的效果"></a>应对策略的效果</h3><p>研究表明问题中心策略是最有效的应对策略. 比如一个学生数学不好, 努力学习与向别人请教是最有效应对焦虑的方法.</p><p>但是另一种情况, 无法挽回的情况, 比如被劫机, 或是婴儿死亡. 这些引起焦虑的问题是我们的能力范围之外的, 此时问题中心策略的减少焦虑的效果比情绪中心策略的效果差.</p><p>所以最后结论是看情况使用不同的应对策略才能有效缓解焦虑.</p><h2 id="精神分析概念和攻击"><a href="#精神分析概念和攻击" class="headerlink" title="精神分析概念和攻击"></a>精神分析概念和攻击</h2><p>人的生的本能”力比多”, 即寻求快乐的冲动受到阻碍的时候, 就会体验到一种想要攻击障碍物的”原始反应”. 而产生了攻击性的人并不一定对阻碍的源头进行攻击, 就像开快车被警察阻止他们不能攻击警察, 只能攻击朋友或家人.</p><p>挫折-攻击假说的内容是, <strong>挫折必导致攻击性, 攻击性一定来自于挫折</strong>. 按精神分析的理论, 受挫导致心理能量被使用, 直到进行了释放紧张的<strong>宣泄</strong>, 攻击才会停止. </p><p>尝试在排第三和排第十二的人前插队, 排第三的人被插队受挫时表现出更强的攻击性. 再比如舍友在周末把你周一考试复习需要的书带回家了, 你在是否直到他是故意的以后表现的攻击性是不同的. 结论是攻击性是根据受挫程度产生的.</p><p>之后研究又认为, 攻击性产生的原因是消极情绪, 受挫只是消极情绪中的一种.</p><p>攻击有一个现象叫做<strong>替代性攻击</strong>, 有一种测试, 分为两部分被试者, 让一部分被试者受到更大的挫折, 然后对另外一组人进行电击, 受到更大挫折的人电击强度明显较大. 这说明有攻击性的人就会找地方发泄, 而并非对受挫源头发泄. 并且发泄完以后攻击性并没有消失, 只是传递到下一层, 比如老板到领导, 领导到员工, 员工到家人, 家人到小孩. </p><p>在<strong>宣泄</strong>以后攻击性才得以释放. 但并不完全是, 如果让一个人打吊袋并骂人, 比让他静坐更使他的攻击性加剧, 而不是减轻. 原因是自我本来压抑着人的攻击性, 而打吊袋释放了这层防御.</p><h2 id="依恋类型和成人的人际关系"><a href="#依恋类型和成人的人际关系" class="headerlink" title="依恋类型和成人的人际关系"></a>依恋类型和成人的人际关系</h2><p>新弗洛伊德学派认为人的人际关系是基于儿童时期的与妈妈的关系类型, 分为<strong>安全型</strong>, <strong>焦虑-矛盾型</strong>, <strong>回避型</strong>. 待儿童成人以后也分为这三种人际关系. </p><p>这三种类型在孩子对妈妈的表现分别为: </p><ul><li>安全型: 妈妈在孩子开心, 妈妈离开孩子不害怕, 相信妈妈会回来.</li><li>焦虑-矛盾型: 妈妈在孩子开心, 妈妈离开孩子焦虑, 害怕妈妈不回来.</li><li>回避型: 妈妈在孩子没有开心, 妈妈离开孩子也没焦虑, 无所谓妈妈回不回来.</li></ul><p>这三个类型的出现都是由妈妈对孩子的态度, 关心程度导致的. 孩子成人之后对人际, 对恋人的关系也会偏向儿童时的类型. </p><p>只有又有了另外一个衍生的模型, 以害怕被抛弃程度与害怕亲密程度为两个维度, 而分为4个类型.</p><table><thead><tr><th></th><th>害怕被抛弃程度低</th><th>害怕被抛弃程度高</th></tr></thead><tbody><tr><td>害怕亲密程度低</td><td>安全型</td><td>焦虑—矛盾型&#x2F;矛盾-依附型</td></tr><tr><td>害怕亲密程度高</td><td>回避型&#x2F;背离型</td><td>无定向型&#x2F;恐惧型.</td></tr></tbody></table><p>心理学家对这些性格的人做了研究, 在54岁时安全型的人结婚率为90%, 离婚率10%, 是婚姻最稳定的. 那么原因是什么呢, 安全型的人是最能在亲密关系中感受亲密的, 焦虑-矛盾型虽然亲密程度高, 但因为害怕被抛弃会造成更多的矛盾.</p><p>总结是: 能投入真心, 并不害怕被抛弃的人能获得更好的亲密关系(也就是说越傻越快乐).</p><p>顺便说一下, 害怕被抛弃程度高是因为自卑, 认为自己不值得被爱, 是一种否定自我的行为.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人格心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-i18n是如何工作的</title>
      <link href="/2017/10/19/how-vue-i18n-work/"/>
      <url>/2017/10/19/how-vue-i18n-work/</url>
      
        <content type="html"><![CDATA[<p>vue-i18n是vue代码贡献量第二的vue core team的一位日本小哥写的, 虽是第三方插件, 用起来心里也舒服. github里搜了vue i18n, 结果有不少, 有一些很粗糙的, 甚至用jquery的lib都有六七十个star. (阻断吐槽). 厉害的人明显在设计上代码上都高很多档次吧.</p><span id="more"></span><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>今天的故事的主角repo是: <a href="https://github.com/kazupon/vue-i18n">vue-i18n</a>与<a href="https://github.com/iview/iview">iView</a>. 在使用他们的时候报错了, 查看了<a href="https://github.com/kazupon/vue-i18n/issues/222">issue</a>,  在issue中获得到一段代码, 不明真相地解决了问题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(iView, &#123;</span><br><span class="line"><span class="attr">i18n</span>: <span class="function">(<span class="params">key, value</span>) =&gt;</span> i18n.<span class="property">vm</span>.<span class="title function_">_t</span>(key, value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这可能是我第一次知道<code>Vue.use</code>可以传第二个参数, 所以想知道发生了什么.</p><p>先说结果: 是因为<code>iView</code>做了对<code>vue-i18n</code>的集成, 是没有仔细看文档而使用不当导致的问题. 研究期间又看了element ui的代码. 发现<code>iView</code>的对<code>vue-i18n</code>的集成是抄他们的. (阻断吐槽). </p><p>来说一下看完这篇文章能明白哪些几点:</p><ul><li><p><code>Vue.use()</code>做了些什么</p></li><li><p>上面的代码为什么避免了<code>iView</code>和<code>vue-i18n</code>集成使用的错误</p></li><li><p><code>Vue.mixin()</code>做了些什么</p></li><li><p>vue-i18n的差值表达式<code>$t</code>方法是哪里来的(因为我只用了这个方法)</p><p>下面开始我们的故事.</p></li></ul><h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><p>(接文章开头的故事), 以前使用<code>Vue.use()</code>的场景都是<code>Vue.use(vuex)</code>, <code>Vue.use(router)</code>等. 那么这次在第二个参数传入了<code>i18n: (key, value) =&gt; i18n.vm._t(key, value)</code>以后发生了什么事组织了程序报错呢.</p><p>首先要明白<code>Vue.use()</code>是干什么用的, 接受的各个参数是干嘛的. 开始看vue的代码, 本文看的<strong>Vue的版本为2.5.2</strong>, 贴个代码, 文件位置: <code>src/core/global-api/use.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initUse</span> (<span class="title class_">Vue</span>: <span class="title class_">GlobalAPI</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 以下4行: 判断这个插件是否已经被加载, 防止重复加载</span></span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="variable language_">this</span>.<span class="property">_installedPlugins</span> || (<span class="variable language_">this</span>.<span class="property">_installedPlugins</span> = []))</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.<span class="title function_">indexOf</span>(plugin) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="comment">// 以下2行: 制造一串参数等待调用, 制造结果为: 把Vue代替接收到的第一个参数</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="title function_">toArray</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.<span class="title function_">unshift</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 以下4行: 兼容两种api, 然后调用插件中的安装方法.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.<span class="property">install</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.<span class="property">install</span>.<span class="title function_">apply</span>(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把插件记录在内部, 以便下次判断重复加载</span></span><br><span class="line">    installedPlugins.<span class="title function_">push</span>(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的语法解释已经写在注释中, 现在来直白的解释一下, 假设插件名字为<code>Cwj</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Cwj</span>)</span><br><span class="line"><span class="comment">// 内部实际执行</span></span><br><span class="line"><span class="title class_">Cwj</span>.<span class="title function_">install</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="comment">// 另一种api, 不推荐, 因为正规的lib中都有install方法</span></span><br><span class="line"><span class="title class_">Cwj</span>(<span class="title class_">Vue</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的使用:</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Cwj</span>, &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="function">() =&gt;</span> bar</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 内部实际执行</span></span><br><span class="line"><span class="title class_">Cwj</span>.<span class="title function_">install</span>(<span class="title class_">Vue</span>, &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="function">() =&gt;</span> bar</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>总结</strong>: <code>Vue.use()</code>的行为: 执行插件的<code>install()</code>方法, 第一个参数为Vue, 剩余的参数为<code>Vue.use()</code>接受的第二个及以后的参数.</p><p>另外, 大部分ui组件的install方法大部分都在执行<code>Vue.component()</code>, 哈哈.</p><h2 id="分析避免集成发生错误的原理"><a href="#分析避免集成发生错误的原理" class="headerlink" title="分析避免集成发生错误的原理"></a>分析避免集成发生错误的原理</h2><p>知道了<code>Vue.use()</code>干了什么, 那么我们要到<code>iView</code>的代码里去找<code>install()</code>方法了. 我这里看的<strong>iView的版本为2.5.0-beta.1</strong>, 在<code>src/index.js</code>中找到了install方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> install = <span class="keyword">function</span>(<span class="params">Vue, opts = &#123;&#125;</span>) &#123;</span><br><span class="line">    locale.<span class="title function_">use</span>(opts.<span class="property">locale</span>);</span><br><span class="line">    locale.<span class="title function_">i18n</span>(opts.<span class="property">i18n</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(iview).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">component</span>(key, iview[key]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Loading</span> = <span class="title class_">LoadingBar</span>;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Message</span> = <span class="title class_">Message</span>;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Modal</span> = <span class="title class_">Modal</span>;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Notice</span> = <span class="title class_">Notice</span>;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Spin</span> = <span class="title class_">Spin</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明是第二行和第三行进行了第二个参数的操作, 那么看一下<code>src/locale/index.js</code>, </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> use = <span class="keyword">function</span>(<span class="params">l</span>) &#123;</span><br><span class="line">    lang = l || lang;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> i18n = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    i18nHandler = fn || i18nHandler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哇, 原来如此, 如果传了<code>i18n</code>方法, 就会在iView组件里调用传入的方法, 而不是预定义的i18n处理方法, 怪不到不按照文档的规定来也不会报错了.</p><h2 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h2><p>那么我们传入的方法是<code>(key, value) =&gt; i18n.vm._t(key, value)</code>, 这里的<code>i18n.vm._t</code>是哪里来的, 看一下在我的项目中<a href="https://github.com/fjonas/lock-on/blob/master/src/renderer/main.js">出现问题的文件</a>是如何加载他们的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueI18</span>n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> <span class="title class_">VueI18</span>n(&#123;</span><br><span class="line">    <span class="attr">locale</span>: <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    messages</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(iView, &#123;</span><br><span class="line">    <span class="attr">i18n</span>: <span class="function">(<span class="params">key, value</span>) =&gt;</span> i18n.<span class="property">vm</span>.<span class="title function_">_t</span>(key, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;<span class="title class_">App</span>&#125;,</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    i18n,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原来如此, 这个<code>i18n</code>正是被传入Vue跟组件的<code>VueI18n</code>的实例, 实例里带着了语言包的信息, 以此推断翻译的时候也是调用了<code>i18n.vm._t</code>方法, 那么就忍不住要看一下<code>vue-i18n</code>的代码了, 我查看的<strong>vue-i18n的版本为7.3.1</strong>, 看一下<code>src/install.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;./util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> extend <span class="keyword">from</span> <span class="string">&#x27;./extend&#x27;</span></span><br><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">&#x27;./mixin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">&#x27;./component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; bind, update &#125; <span class="keyword">from</span> <span class="string">&#x27;./directive&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">install</span> (_Vue) &#123;</span><br><span class="line">  <span class="title class_">Vue</span> = _Vue</span><br><span class="line">  <span class="comment">// 下面都是做一些必要的判断, 不是我们要看的运行机制</span></span><br><span class="line">  <span class="keyword">const</span> version = (<span class="title class_">Vue</span>.<span class="property">version</span> &amp;&amp; <span class="title class_">Number</span>(<span class="title class_">Vue</span>.<span class="property">version</span>.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])) || -<span class="number">1</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; install.<span class="property">installed</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;already installed.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  install.<span class="property">installed</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; version &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">`vue-i18n (<span class="subst">$&#123;install.version&#125;</span>) need to use Vue 2.0 or later (Vue: <span class="subst">$&#123;Vue.version&#125;</span>).`</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里开始业务逻辑, 下面把_i18n赋给Vue.$i18n</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$i18n&#x27;</span>, &#123;</span><br><span class="line">    get () &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_i18n</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 下面4句是加载核心</span></span><br><span class="line">  <span class="title function_">extend</span>(<span class="title class_">Vue</span>)</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(mixin)</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;t&#x27;</span>, &#123; bind, update &#125;)</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(component.<span class="property">name</span>, component)</span><br><span class="line">  <span class="comment">// 下面是配置merge策略</span></span><br><span class="line">  <span class="comment">// use object-based merge strategy</span></span><br><span class="line">  <span class="keyword">const</span> strats = <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">optionMergeStrategies</span></span><br><span class="line">  strats.<span class="property">i18n</span> = strats.<span class="property">methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地, 解释也都写在注释中了, 那么4句install的核心里我的mixin方法不熟悉, 接下来我们来了解一下<code>Vue.mixin()</code>方法做了些什么:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initMixin</span> (<span class="title class_">Vue</span>: <span class="title class_">GlobalAPI</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">mixin</span> = <span class="keyword">function</span> (<span class="params">mixin: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(<span class="variable language_">this</span>.<span class="property">options</span>, mixin)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字面意思就merge配置, options也就是<code>new Vue()</code>的时候传入的参数, 所以在mixin里传入的会被所有Vue的子组件作为options. (这个逻辑没有看代码, 看的是<a href="https://vuejs.org/v2/guide/mixins.html#Global-Mixin">文档</a>).</p><h2 id="t是如何运作的"><a href="#t是如何运作的" class="headerlink" title="$t是如何运作的"></a>$t是如何运作的</h2><p>进行了加载以后, 只需要在dom的插值表达中调用就可以翻译, 类似: <code>$t(&#39;hello&#39;)</code>, 那么<code>$t</code>方法是如何被加载到所有Vue的子组件中的呢. 我们需要重新开始理一下.</p><p>之前的章节对于一些加载的方法有了了解, 那么现在从<code>vue-i18n</code>安装的时候开始分析, 以查出<code>$t</code>是如何进行翻译为目的来跟着<code>vue-i18n</code>的源码兜一圈.</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>先看vue-i18n是如何被加载进来的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueI18</span>n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> <span class="title class_">VueI18</span>n(&#123;</span><br><span class="line">    <span class="attr">locale</span>: <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    messages</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;<span class="title class_">App</span>&#125;,</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    i18n,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里分成两块:</p><ul><li><code>Vue.use(VueI18n)</code>, 上面说过, 这里是执行了install方法</li><li><code>new Vue(&#123; i18n: new VueI18n(options)&#125;)</code>, 这里是把一个<code>vue-i18n</code>的实例设为了我们跟组件的options, 我们需要分析这个实例有些什么东西, 并在什么地方什么时候调用了他.</li></ul><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p>上文已经提到过, install里的核心四个方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$i18n&#x27;</span>, &#123;</span><br><span class="line">  get () &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_i18n</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(mixin)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;t&#x27;</span>, &#123; bind, update &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(component.<span class="property">name</span>, component)</span><br></pre></td></tr></table></figure><p>directive与component分别是注册指令和注册组件, 这里先不展开, 我们的目标是分析<code>$t</code>.</p><p>来看extend.js中关于<code>$t</code>的代码: (文件中其他代码没有贴出来)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">extend</span> (<span class="title class_">Vue</span>: any): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$t</span> = <span class="keyword">function</span> (<span class="params">key: Path, ...values: any</span>): <span class="title class_">TranslateResult</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> i18n = <span class="variable language_">this</span>.<span class="property">$i18n</span></span><br><span class="line">    <span class="keyword">return</span> i18n.<span class="title function_">_t</span>(key, i18n.<span class="property">locale</span>, i18n.<span class="title function_">_getMessages</span>(), <span class="variable language_">this</span>, ...values)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此, 我们调用的<code>$t(&#39;hello&#39;)</code>的来源是<code>Vue.$t</code>, 并且调用了<code>Vue.$i18n._t</code>方法. 对比文章开头的<code>i18n.vm._t</code>, i18n是<code>VueI18n</code>的实例, 被注册到Vue的options的<code>i18n</code>这个字段里, 调用了同样的<code>_t()</code>方法, 那么现在浮现的问题是:</p><ul><li><code>i18n.vm._t</code>是如何被加载成为<code>Vue.$i18n._t</code>的</li><li>_t方法是写在哪里被加载进Vue的</li></ul><p>带着问题, 我们继续看mixin.js. 在mixin.js里只有两个方法, 是beforeCreate和beforeDestroy, 我大致看了下beforeCreate, 作用是建立当前component的Vue._i18n变量, 这个变量就是Vue.$i18n的getter的指向, 为什么要写getter原因也出来了, 因为i18n-loader允许在单文件里写本地语言包, 所以要merge一下, 产生本地的语言环境. </p><p>那么在mixin中是如何获取初始语言包的呢, 源码里: <code>const options: any = this.$options</code>, 也就是取了Vue.$options, 那么下一章来讲一讲Vue实例构建的时候是如何把vue-i18n实例加载进入Vue实例的.</p><h3 id="Vue实例构造过程中加载的VueI18n实例"><a href="#Vue实例构造过程中加载的VueI18n实例" class="headerlink" title="Vue实例构造过程中加载的VueI18n实例"></a>Vue实例构造过程中加载的VueI18n实例</h3><p>切取一段来自<code>src/core/instance/init.js</code>的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">      vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(粗糙地一看), 就是Vue吧参数判断了一下然后塞进了自己的<code>.$options</code>属性. 也就是<code>Vue.$options.i18n</code> 现在是一个VueI18n实例.</p><p>准备看一下VueI18n的构造吧. 代码有600行, 初始化的时候还是执行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> silent = <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span> = <span class="literal">true</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; data &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span> = silent</span><br></pre></td></tr></table></figure><p>好像vuex也是这么写的, _t方法就写在这个文件里, 但是如何加载的还得看vue源码, 只能下回分解了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弗洛伊德理论介绍</title>
      <link href="/2017/10/15/freud-brief/"/>
      <url>/2017/10/15/freud-brief/</url>
      
        <content type="html"><![CDATA[<p>⟪人格心理学⟫中指出, 心理学家对人格的分析有如”盲人摸象”, 十九世纪西方产生了大量心理学派, 各个学派是看这个世界的各个角度, 没有对错, 在看书过程难免遗忘, 本文记录一下弗洛伊德学派的主要理论. 在书中的对应章节为第三章与第四章.</p><span id="more"></span><h2 id="弗洛伊德简介"><a href="#弗洛伊德简介" class="headerlink" title="弗洛伊德简介"></a>弗洛伊德简介</h2><p>弗洛伊德是十九世纪伟大的神经学家, 他引领了一场重大的精神运动, 改变了之后各个领域的人多年来对人的看法, 之后西方的许多心理学派都是以弗洛伊德理论为基础展开或修整的.</p><p>弗洛伊德原本是医生, 在治疗一种”歇斯底里症”的病的首个成功案例以后开始慢慢对心理研究产生兴趣, 这种病症在一开始被当做外科病, 而弗洛伊德通过心理角度治好了一例患者从而走上了精神分析的道路.</p><h2 id="弗洛伊德理论"><a href="#弗洛伊德理论" class="headerlink" title="弗洛伊德理论"></a>弗洛伊德理论</h2><h3 id="人格模型"><a href="#人格模型" class="headerlink" title="人格模型"></a>人格模型</h3><p>弗洛伊德的人格模型分为解剖模型和结构模型.</p><p>解剖模型分为<strong>意识</strong>, <strong>前意识</strong>, <strong>无意识</strong>. 分别代表: 正在想的内容, 可以想起来的内容, 想不起来的内容. 无意识, 也就是”想不起来的内容”是弗洛伊德的发现, 无意识会操纵人的行为.</p><p>结构模型分为<strong>本我</strong>, <strong>自我</strong>, <strong>超我</strong>. 分别代表: 原始欲望的意识, <em>现实原则</em>处理后的意识, 道德规范(社会规范)后的意识. 举例来说是在朋友家看到桌上有5元钱, <em>本我</em>是想拿走的, 而<em>自我</em>意识到拿走可能会导致问题, 于是试图寻找拿走钱也不为人知的办法. 但即使有拿走且不为人知的方法, <em>超我</em>也将阻止这一行为, 因为拿走不属于自己的东西是违反社会规范的, 有人把超我直译为<em>良心</em>.</p><p>两种模型是基于不同角度, 两种模型之间是互相有交集的, 比如我们在朋友家看到钱不会想要拿走, 也就是<em>本我</em>处于<em>无意识</em>中. 人的一生自己的<em>本我</em>, <em>自我</em>, <em>超我</em>都在不断斗争, 而本我几乎全藏在<em>无意识</em>中, <em>自我</em>和<em>超我</em>在三中解剖模型中都存在, 这是两个模型的关系.</p><h3 id="人的本能"><a href="#人的本能" class="headerlink" title="人的本能"></a>人的本能</h3><p>人的本能分为<strong>生的本能</strong>和<strong>死的本能</strong>. 生的本能也叫性本能, 是指以获得快乐为目的的行为. 人有死去回归大地的愿望, 而死的愿望一直在无意识中, 大多会转化为外部表现为对他人的攻击, 所以攻击性也是人的本能.</p><p>弗洛伊德认为人的心理能量是有限的, 如果一个人的自我必须耗费大量的精力来控制本我, 那么他的其他心理机能就会因为没有能量而受损. 所以弗洛伊德的治疗方法是发现患者的无意识并释放无意识冲动, 来释放能量用于日常心理功能的发挥.</p><h3 id="防御机制"><a href="#防御机制" class="headerlink" title="防御机制"></a>防御机制</h3><p>人在生活中会产生许多不好的无意识主题, 比如对父母的憎恨, 对配偶的攻击性, 乱伦年头, 对儿时创伤经历的回忆, 以及类似的对<em>意识</em>具威胁性的想法. <em>自我</em>会试图把这些内容排除在<em>意识</em>之外, 从而<em>自我</em>有许多处理非期望想法和欲望的方法, 成为<strong>防御机制</strong>. </p><p>这些<strong>防御机制</strong>大部分是在<em>无意识</em>中的, 只有一些<em>防御机制</em>我们自己可以意识到.</p><p>另外除了下面要说的<strong>升华</strong>, 所有<em>防御机制</em>都是不同程度消耗心理能量的.</p><p>为了快速解释, 下面的防御机制都通过”例子+定义”的方式来介绍.</p><h4 id="压抑"><a href="#压抑" class="headerlink" title="压抑"></a>压抑</h4><p><strong>压抑</strong>是一种积极的努力, 自我通过这种努力, 把那些有威胁的内容排除在意识之外, 或者使这些内容不能接近意识. 例如一个男孩看见父亲殴打母亲, 事后被询问这次经历时, 男孩称从未见过这样的事情. (男孩自己也这么认为的).</p><p>关于压抑这种防御机制要稍微多介绍一下, 因为压抑是”整个精神分析理论结构的基石”, 压抑是一个稳定, 主动的过程, 他需要自我持续地消耗能量, 压抑大量的想法和冲动使自我没有剩余能量可以运作.</p><h4 id="升华"><a href="#升华" class="headerlink" title="升华"></a>升华</h4><p><strong>升华</strong>是把危险的无意识冲动转化为社会认可的行为. 例如橄榄球, 冰球这些运动, 运动员把对方运动员推倒是社会承认和赞赏的.</p><h4 id="替代"><a href="#替代" class="headerlink" title="替代"></a>替代</h4><p><strong>替代</strong>是将冲动导入一个无威胁的目标物. 例如一个女人遭虐待后, 无意识中会非常愤怒. 如果向施虐者发泄会有危险, 他就将怒气指向同事或孩子.</p><p>弗洛伊德认为, <strong>人们的许多不合理的害怕或恐惧, 都不过是象征性替代</strong>. 例如一位患者的儿子害怕马. 他推测孩子是用害怕马来替代对父亲的害怕.</p><h4 id="否认"><a href="#否认" class="headerlink" title="否认"></a>否认</h4><p><strong>否认</strong>是否认接受某些事实的存在. 与<em>压抑</em>不同, 否认没有忘记事实, 而是认为某些事实是不真实的, 在旁人看来是患者的逻辑有问题. 例如一位深爱妻子的丈夫, 在妻子死后一直表现为妻子还活着的样子. 自我使用否认不让某些想法达到意识.</p><h4 id="反向作用"><a href="#反向作用" class="headerlink" title="反向作用"></a>反向作用</h4><p><strong>反向作用</strong>指我们会按照无意识欲望相反的方式行动, 以躲开可怕的念头或欲望. 例如一个女人反复告诉别人他多爱他自己的母亲, 其实他在隐藏无意识中对母亲的强烈憎恨.</p><h4 id="理智化"><a href="#理智化" class="headerlink" title="理智化"></a>理智化</h4><p>对可怕的无意识念头进行自我控制的一种方法是, 在他进入意识之前, 先从中去掉感情的内容. 这样进入意识以后就不会感到焦虑. 例如一个女人装作思考系安全带的重要性, 也许是在想象她的丈夫会遭遇可怕的车祸. 弗洛伊德认为她对丈夫怀有某种无意识的敌意.</p><h4 id="投射"><a href="#投射" class="headerlink" title="投射"></a>投射</h4><p><strong>投射</strong>是指我们把一种无意识冲动归于别人, 而非自己, 就可以摆脱”我自己就这样想”的观念. 例如一个认为她周围的邻居私生活都不检点的女人, 也许对隔壁的已婚男人怀有性欲望. 宣称世界充满猜疑和欺骗的人, 其实在无意识中承认他自己就是不可信的人和骗子.</p><h3 id="心里性欲发展阶段"><a href="#心里性欲发展阶段" class="headerlink" title="心里性欲发展阶段"></a>心里性欲发展阶段</h3><p>弗洛伊德描述人在儿童阶段经历各个心理性欲阶段而发展了人格. 如果儿童在某个阶段遇到困难, 或者某个阶段非常满足, 使他们想停留在这个阶段, 就造成了<strong>固着</strong>, 即心理能量被绑定, 这些人成人后还会表现其心理能量被固着阶段的行为特征.</p><p><strong>口唇期</strong>在0~18个月, 固着结果是嗜酒, 嗜烟, 咬手指.</p><p><strong>肛门期</strong>在18个月以后, 性格是很强的秩序感, 固执或过于慷慨.</p><p><strong>性器器</strong>, 大约发生于3~6岁,  儿童将经历恋母情结. 弗洛伊德提示人们, 恋母欲望永远不会完全消失. 只是被压抑了, 以后的生活中还会以各种方式对人的行为造成影响.</p><h3 id="研究无意识内容"><a href="#研究无意识内容" class="headerlink" title="研究无意识内容"></a>研究无意识内容</h3><p>那么弗洛伊德认为最重要的心理材料在无意识中, 那么如何分析无意识呢.</p><h4 id="梦"><a href="#梦" class="headerlink" title="梦"></a>梦</h4><p>弗洛伊德认为梦看似奇怪无聊的内容, 但每个出现的东西都代表了一些东西. 弗洛伊德说睡眠如此重要, 我们是不会让对自己不重要的东西打扰他的.</p><h4 id="投射测试"><a href="#投射测试" class="headerlink" title="投射测试"></a>投射测试</h4><p>投射测试的原理是用<strong>模糊</strong>的图像让患者描述. 就像我们小时候看云朵来说像什么东西一样.</p><h4 id="自由联想"><a href="#自由联想" class="headerlink" title="自由联想"></a>自由联想</h4><p>花一点时间把自己脑子里的念头都清理干净, 然后开始纵情畅想, 畅所欲言, 哪怕说出来的话出乎意料. 因为人能想出的东西都是脑子里的, 和梦一样, 再以为离奇的东西其实都是无意识中存在的东西.</p><h4 id="弗洛伊德口误"><a href="#弗洛伊德口误" class="headerlink" title="弗洛伊德口误"></a>弗洛伊德口误</h4><p>所有人都难免会口误. 丈夫在提到妻子时, 用的是他婚前的姓. 在弗洛伊德眼里, 这代表一时脱口而出的无意识内容. 用婚前姓称呼妻子的丈夫, 或许在无意识里希望自己从未娶过这个女人. 我们把这种错误陈述成为<strong>弗洛伊德口误</strong>.</p><h4 id="催眠"><a href="#催眠" class="headerlink" title="催眠"></a>催眠</h4><p>在深度催眠的状态下, <em>自我</em>会进入暂停状态, 从而直接达到无意识.</p><h4 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h4><p>例如你和一个朋友在争论问题, 你”意外”地撞倒了朋友的一个塑料架而且无法修复. 你道歉, 说你不是故意的. 但这真的是一次意外吗? 在弗洛伊德来看, 许多看似意外的行为, 其实是无意识冲动驱使的.</p><p>我们也许有很多”忘记”, “推延”的动作, 其实都是无意识的不愿意.</p><h4 id="象征行为"><a href="#象征行为" class="headerlink" title="象征行为"></a>象征行为</h4><p>例如有一个母亲喜欢菊花图案, 孩子回家在菊花图案的擦鞋店上不停地踩, 其实是对母亲怀有敌意.</p><h2 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h2><h3 id="梦的功能"><a href="#梦的功能" class="headerlink" title="梦的功能"></a>梦的功能</h3><p>睡眠有一个阶段为”快速动眼”, 在快速动眼的时候, 人的大脑活动仍与清醒一样. 研究发现快速动眼阶段充满了梦.</p><p>说一个实验来说梦的功能:</p><p>实验让被试者分为两批, 分别在睡前和睡后看一个医生解剖尸体的可怕细节. 睡前看的被试者明显比睡后看的产生了更多焦虑情绪, 并且睡前看的被试者当天晚上增加了快速动眼睡眠.</p><p>实验结论是快速动眼, 做梦是为被压抑的想法提供了发泄的出口. 遭受心理创伤, 在白天总是回避想创伤的人, 夜晚经常会做反应创伤性事件的梦. 有另外一个研究:</p><p>被试者在睡觉前进行一个意识流写作练习, 要求在练习中故意不去想他们认识的某人. 当晚, 要求不要想那个熟人的被试者更多的梦到了这个人.</p><h3 id="防御风格"><a href="#防御风格" class="headerlink" title="防御风格"></a>防御风格</h3><p>每个人都会较多地使用一些防御机制而较少的使用另一些, 这种个人化的方式叫做<strong>防御风格</strong>.</p><p>不同的年龄, 防御风格会产生变化.</p><p>防御风格形成的原因是, 使用者的经历关系某些防御机制特别好用, 使用者遇到了别的事情也会继续使用, 就形成了防御风格.</p><h3 id="幽默"><a href="#幽默" class="headerlink" title="幽默"></a>幽默</h3><p>弗洛伊德认为人因为笑话而笑是因为这种笑是无意识的发泄. 许多笑话都是带有黄色或者攻击性的. </p><p>一直压抑着性的人更会因为黄色笑话而笑.</p><p>对别人敌意更大的更会因为攻击性的笑话而笑. 试想象如果攻击性的笑话(出丑)的主角是自己亲近的人, 是不是想笑的欲望就减少了. 因为人天生对所有人有攻击性(死的本能), 所以听到攻击性笑话会笑. 所以人可能希望除了自己亲近的人其他人都去死是一种本能.</p><p><strong>用敌意的笑话可以降低攻击性</strong>. 也就是旁人嘲笑你生气的对象会让你对他的生气减少. 而其他的笑话则不能减少你的生气.</p><p><strong>人越紧张越容易笑</strong>. 实验是: 被试者分为两批, 一批被要求: 摸实验老鼠5秒, 并被告知这些老鼠很温顺. 另一批被要求: 用针筒吸取2毫升老鼠的血液, 并被告知老鼠很凶小心被咬到. 最后当被试者打开盖子发现是玩具老鼠, 被要求吸血的被试者笑了, 另外的被试者觉得没有那么好笑. 原因是压抑紧张让自己表现正常被释放了. </p><p>所以笑和做梦是有积极意义的, 释放心理能量.</p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>弗洛伊德认为, 我们身上多数真实的东西都不是意识的, 而我们意识中的多数东西都不是真实的.</li><li>清白无邪的梦, 是披着羊皮的狼. 当我们对这些梦进行分析时, 他们的含义可能与其表面正相反. —弗洛伊德</li><li>梦从来都与琐事无关: 我们不会允许无关紧要的事打扰我们的睡眠. —弗洛伊德</li><li>一个人因为听了黄色笑话而大笑, 就仿佛他在旁观一场性侵略而大笑. —弗洛伊德</li></ul><h3 id="对世界新的认识"><a href="#对世界新的认识" class="headerlink" title="对世界新的认识"></a>对世界新的认识</h3><p>在知道了一件事以后就再也不会当不知道了. </p><p>人的无意识操纵了人的很多行为, 需要注意的是, 我们自己意识不到, 我们会被广告, 被运营, 被qq空间的黄色擦边球的文章吸引, 自己也觉得很无聊, 但是就买了, 点了, 看了, 那都是因为自己的无意识操作了自己的行为.</p><p>从弗洛伊德的理论我也感受到了: <strong>空的脑子是没有任何输出的</strong>, 所以<strong>以为是随意的或者是无意义的想法和行为, 都是自己无意识的表现</strong>. 而无意识有一部分是遗传的, 成为<em>集体无意识</em>(是后面章节弗洛伊德延伸派的理论), 另一部分是自己输入的无意识, 只是被自我排除了. </p><p>举例, 上文有奇怪的行为(对马的害怕), 人的梦, 口误. 这些看似无意义的, 奇怪的行为, 都是人的愿望的表现. 人越大越成熟就知道很多事不能说, 不能做. 网络流行说人都是带着面具生活, 可怕的是, 我们骗了别人一部分, 也骗了自己, 自己还信了. 这就是自我把认为不好的事(想攻击亲人, 想乱伦, 想出轨). 这些事情自己也觉得是错的, 所以就骗自己事实不是这样的.</p><h3 id="对自己行为的影响"><a href="#对自己行为的影响" class="headerlink" title="对自己行为的影响"></a>对自己行为的影响</h3><p>弗洛伊德提到了防御风格, 越成熟的人使用的防御风格越好(防御风格是有好坏的, 刚才提到的升华是几乎不消耗心理能量的). </p><p>对自己的认识是: 不要在任何时候相信自己, 在遇到不爽的时候努力分析是否使用了防御机制, 防御机制是暂时的, 如果能面对问题, 解决问题, 就可以解放心理能量的使用而把能量投入更积极的心理机能里.</p><p>另外要对自己输入更好的无意识: 也就是养成好习惯. 小时候会有个想法: “到时候认真做就可以了”. 对自己, 对事, 对人都用真心真态度. 因为如果用了假的态度, 以为自己表现得很像了, 还是会做出自己真实想做的事. 例子是看书学习, 为什么我会想好学习一天, 结果学习2小时玩2小时呢, 原因是对自己的心理暗示不够. 许多人看书都是”我知道看书好”, 或者是”我要让别人知道我在看书”而发了个朋友圈. 所以要用”真”的态度对待自己, 把”我应该这么做”, 换成”我必须这么做”.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人格心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加班与效率</title>
      <link href="/2017/09/27/overtime-or-efficiency/"/>
      <url>/2017/09/27/overtime-or-efficiency/</url>
      
        <content type="html"><![CDATA[<p>已连续四天23点从公司出来, 包含周末, 昨天没有加班, 但是又被同事留下, 还是强行走了. 到家吃晚饭8点一觉睡到了早上, 感觉生活中除了工作什么都没有了.</p><span id="more"></span><p>早上看到琴发现自己已经很久没弹琴了, 再仔细想想, 自己一路来也放弃了很多东西, 日语也不学了, 工作技术也好久没研究了, 自己的项目也都烂尾了.</p><h2 id="往前看往后看"><a href="#往前看往后看" class="headerlink" title="往前看往后看"></a>往前看往后看</h2><p>有了3年工作经验, 从毕业的别人都好厉害, 到现在眼里开始有不厉害的人了. 现在明显感觉自己可以短时间做出毕业生做很久的东西, 构建工具的模板也是齐全, 一条xxx-cli就可以秒搭前端环境. </p><p>看看现在的自己也有变化, 正在尝试从””百度和中文””变成””文档与原文””, 思考的点也从”如何实现”变为”如何优雅易改易扩展”, 代码结构也从流程变为模块+组合.</p><p>那么同样的, 我们以后也要成长为看不起现在的自己的人. 以后的水平一定要是工作1小时超过现在1天的水平吧, 如果没有, 那么成长停止了吧.</p><h2 id="另一个小插曲"><a href="#另一个小插曲" class="headerlink" title="另一个小插曲"></a>另一个小插曲</h2><p>前阵在玩怪物猎人, 玩的频率很高玩到了6级, 一个同学也在玩, 他1级, 我们一起玩, 后来各种事情忙我大概2周没玩, 再一起玩的时候他已经12级. 可能故事听起来很正常, 但是当时自己并不觉得正常, 可能自己的直觉还是觉得惊讶的.</p><p>再看看自己qq好友列表里的人, 有一些觉得以前很羡慕的人, 现在一丝都不羡慕他们了.</p><p>进步是很慢又很快的事.</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>那么说回加班, 我认为加班是必须的, 但是超过20%的工作日就是错误的, 可能有一个看法是”加班进步快”, 我相信也有一部分人被这个想法洗脑. 我认为这是一种思维懒惰的表现. 我们应该做的是”动脑提升自己的效率”, 效率代表水平, 而不是放弃进步, 用”加班就会进步”来骗自己, 给自己不动脑子不进步的理由. btw, 如果把加班作为日常, 一般是6点半等饭, 7点吃饭, 7点半吃好休息到8点. 然后9点回家.</p><h2 id="基础能力的重要性"><a href="#基础能力的重要性" class="headerlink" title="基础能力的重要性"></a>基础能力的重要性</h2><p>以前有个同事跟我说: “我们有工作经验了可以不做事, 让下面的同事做事”. 然后他成了混浮骗的人. 这个圈子一年等于七年, 保持coding能力也是很重要的. 不动脑子做是进步很慢的, 但保持基础业务能力也重要, 因为基础业务是一切的基础, 决不可脱离.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以回忆下刚工作&#x2F;临近考试&#x2F;刚换新工作时候的心情与态度. 要给自己<strong>真实, 有用</strong>的目标, 而不是骗自己的目标, 因为只有实在的目标才可以让自己实在的进步. 对于英语学习来也是, 我们看英语文章只有10%单词不认识, 20%组合不认识, 我们会惰性思考告诉自己”看懂就行, 要多看”, 其实不然, 我们需要看, 然后不是多看, 而是把”少部分不认识的单词”认真背下来, 总结复习, 这样才能更快的进步. 使用<a href="https://github.com/fjonas/lock-on">vocabook</a>累积日常工作中不熟悉的单词, 大幅提高英语学习效率, 成为英语达人.</p>]]></content>
      
      
      <categories>
          
          <category> 生活吐槽 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>electron实战vocabook(一)</title>
      <link href="/2017/09/03/electron-application-1/"/>
      <url>/2017/09/03/electron-application-1/</url>
      
        <content type="html"><![CDATA[<p>零基础使用electron编写记录&#x2F;复习单词的软件<a href="https://github.com/fjonas/lock-on">vocabook</a>. 记录了第一次开发electron遇到的问题与如何组合使用api来实现通常的需求.</p><p>这个项目是使用了<a href="https://github.com/SimulatedGREG/electron-vue">electron-vue</a>作为模板的.</p><span id="more"></span><p><em>这个系列把问题作为标题, 实现过程作为内容</em></p><h2 id="如何控制每个窗口的控制条与标题栏"><a href="#如何控制每个窗口的控制条与标题栏" class="headerlink" title="如何控制每个窗口的控制条与标题栏"></a>如何控制每个窗口的控制条与标题栏</h2><p>electron默认的窗口是显示在正中, 带有标题栏, 可以拖动大小的窗口. 然而在各个不同场景, 我们需要不同的窗口, 接下来说一下不同形态的窗口的配置.</p><p>创建窗口使用了main process中的<code>BrowserWindow</code>对象, 在<a href="https://electron.atom.io/docs/api/browser-window/">文档</a>和<a href="https://electron.atom.io/docs/api/frameless-window/#alternatives-on-macos">无边框窗口的文档</a>里介绍了这个部分提到的所有配置和更多的配置.</p><h3 id="主窗口"><a href="#主窗口" class="headerlink" title="主窗口"></a>主窗口</h3><p>主窗口的需求是不要标题栏, 这样可以自定义ui, 不让标题栏影响界面, 配置为<code>titleBarStyle: &#39;hidden&#39;</code>. 如此产生了一个问题, 没有标题栏不能拖动. 结局方案是在dom上加上<code>-webkit-app-region: drag;-webkit-user-select: none;</code>的css就可以使dom变得可以拖动窗口. 另外主窗口的设计是有最小宽度和最小高度. 那么就是用<code>minHeight</code>和<code>minWidth</code>来设置.</p><h3 id="配置窗口"><a href="#配置窗口" class="headerlink" title="配置窗口"></a>配置窗口</h3><p>这个项目会有”配置”的功能, 那么配置的窗口一般是写死大小, 不能拖动的. 也不能最大化和最小化.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">titleBarStyle</span>: <span class="string">&#x27;customButtonsOnHover&#x27;</span>,</span><br><span class="line">  <span class="attr">resizable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">minimizable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">maximizable</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷你面板"><a href="#迷你面板" class="headerlink" title="迷你面板"></a>迷你面板</h3><p>迷你面板是主界面的第二形态, 期望的行为是置顶窗口, 并自定义窗口控制(红绿灯). 那么配置为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">alwaysOnTop</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">frame</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>alwaysOnTop</code>是置顶窗口, 迷你面板会覆盖其他所有程序, <code>frame</code>是去除窗口控制按钮(最大化&#x2F;最小化&#x2F;关闭)</p><h3 id="优雅显示窗口"><a href="#优雅显示窗口" class="headerlink" title="优雅显示窗口"></a>优雅显示窗口</h3><p>因为页面加载需要时间, 而打开窗口以后还在加载页面会使体验变差, 可以把初始窗口配置的<code>show</code>字段设为<code>false</code>, 并监听加载事件操作窗口:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.<span class="title function_">once</span>(<span class="string">&#x27;ready-to-show&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mainWindow.<span class="title function_">show</span>()</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="http请求跨域"><a href="#http请求跨域" class="headerlink" title="http请求跨域"></a>http请求跨域</h2><p>在这个项目中使用了axios作为http库, 但因为跨域问题研究了一天, 解决方法很简单. 和chrome插件类似, 配置窗口的安全策略.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webPreferences</span>: &#123;</span><br><span class="line">  <span class="attr">webSecurity</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置窗口的显示"><a href="#配置窗口的显示" class="headerlink" title="配置窗口的显示"></a>配置窗口的显示</h2><p>为配置窗口新增了一个一级路由, 但是在build环境下和dev环境下url不同, dev为http协议, build为file协议, baseurl的写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winURL = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br></pre></td></tr></table></figure><h2 id="配置窗口与主窗口的数据"><a href="#配置窗口与主窗口的数据" class="headerlink" title="配置窗口与主窗口的数据"></a>配置窗口与主窗口的数据</h2><p>配置窗口是一个独立的页面, 与主窗口是分离的, 那么如何在配置窗口切换了设置以后让主窗口感应到成了一个问题.</p><p>这里用到了: </p><ul><li>ipc传递事件</li><li>vuex插件</li><li>main process <code>webContents</code>获取所有窗口</li></ul><p>流程:</p><ol><li>通过vuex插件来像main process发送事件, 并在vuex插件中监听消息, 直接commit来改变vuex的state</li><li>在main process中监听事件, 因为事件参数只能获得来源窗口, 所以需要调用<code>webContents.getAllWebContents()</code>来获取所有窗口, 向别的窗口发送设置变化的事件.</li></ol><p>具体代码:</p><p>vuex plugin:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store =&gt; &#123;</span><br><span class="line">  store.<span class="title function_">subscribe</span>(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;ipc/theme&#x27;</span>) &#123;</span><br><span class="line">      ipcRenderer.<span class="title function_">send</span>(<span class="string">&#x27;themeChange&#x27;</span>, state.<span class="property">config</span>.<span class="property">theme</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  ipcRenderer.<span class="title function_">on</span>(<span class="string">&#x27;broadcastTheme&#x27;</span>, <span class="function">(<span class="params">event, arg</span>) =&gt;</span> &#123;</span><br><span class="line">    store.<span class="title function_">commit</span>(<span class="string">&#x27;config/setTheme&#x27;</span>, arg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main process:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.<span class="title function_">on</span>(<span class="string">&#x27;themeChange&#x27;</span>, <span class="function">(<span class="params">event, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  webContents.<span class="title function_">getAllWebContents</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    v.<span class="title function_">send</span>(<span class="string">&#x27;broadcastTheme&#x27;</span>, arg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="如何切换主窗口与迷你面板"><a href="#如何切换主窗口与迷你面板" class="headerlink" title="如何切换主窗口与迷你面板"></a>如何切换主窗口与迷你面板</h2><p>切换窗口也是通过了ipc事件来做的, 需要在主进程保存当前打开的窗口的变量, 来决定关闭了窗口之后再次激活应用打开的是主窗口还是迷你面板.</p><h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><p>我用了<a href="https://github.com/louischatriot/nedb">nedb</a>来储存数据, 使用main process的api<code>app</code>, <code>app.getPath(&#39;userData&#39;)</code>可以获取用户存储数据的路径来连接数据库.</p><h3 id="nedb介绍"><a href="#nedb介绍" class="headerlink" title="nedb介绍"></a>nedb介绍</h3><p>nedb是个模仿mongoodb查询方式的node数据库, 在electron项目里把实例创建在文件上就行了, 介绍一些概念:</p><ul><li>collection 对应 数据库的表, 一个collection为一个实例(一个文件)</li><li>document 对应 数据库的列</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写d3-selection插件</title>
      <link href="/2017/07/29/d3-selection-plugin/"/>
      <url>/2017/07/29/d3-selection-plugin/</url>
      
        <content type="html"><![CDATA[<p>在使用d3中遇到问题: 在渲染中, 根据数据渲染自定义节点, 那么如何进行优雅的操作呢.</p><span id="more"></span><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>先来抛出问题. 需求需要根据数组中元素的某个字段来画出配置中的图标, 如:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;created&quot;</span></span><br><span class="line">  iconId<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;workflow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  iconId<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>其中每个iconId对应了一个配置的好的svg, 那么如何把这些数据注入并画出对应配置的svg.</p><p>在d3-selection文档提到了扩充方法的办法以及如何嵌套joining data. 以这两个示例为入口扩展如何实现需求.</p><h2 id="文档中的例子"><a href="#文档中的例子" class="headerlink" title="文档中的例子"></a>文档中的例子</h2><h3 id="d3-selection"><a href="#d3-selection" class="headerlink" title="d3.selection()"></a>d3.selection()</h3><p>通过<code>d3.select()</code>得到的都是<code>d3.selection()</code>对象, 所以类似<code>.attr()</code>, <code>.style()</code>, <code>.append()</code>的方法都是挂载在<code>d3.selection()</code>上的. 所以拓展<code>d3.selection()</code>的prototype就可以进行d3的拓展. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d3.<span class="property">selection</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">checked</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span> &lt; <span class="number">1</span></span><br><span class="line">      ? <span class="variable language_">this</span>.<span class="title function_">property</span>(<span class="string">&quot;checked&quot;</span>)</span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">property</span>(<span class="string">&quot;checked&quot;</span>, !!value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样对selection的<code>.checked()</code>做出了拓展, 就可以直接在链式操作中使用啦.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.<span class="title function_">selectAll</span>(<span class="string">&quot;input[type=checkbox]&quot;</span>).<span class="title function_">checked</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="嵌套joining-data"><a href="#嵌套joining-data" class="headerlink" title="嵌套joining data"></a>嵌套joining data</h3><p>文档中有个例子, 一个二维数组对应一个表格, 需要把第一次已经join data的selection赋值给一个中间变量, 再继续join data. 第二次调用<code>.data()</code>方法需要传入function参数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = [</span><br><span class="line">  [<span class="number">11975</span>,  <span class="number">5871</span>, <span class="number">8916</span>, <span class="number">2868</span>],</span><br><span class="line">  [ <span class="number">1951</span>, <span class="number">10048</span>, <span class="number">2060</span>, <span class="number">6171</span>],</span><br><span class="line">  [ <span class="number">8010</span>, <span class="number">16145</span>, <span class="number">8090</span>, <span class="number">8045</span>],</span><br><span class="line">  [ <span class="number">1013</span>,   <span class="number">990</span>,  <span class="number">940</span>, <span class="number">6907</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr = d3.<span class="title function_">select</span>(<span class="string">&quot;body&quot;</span>)</span><br><span class="line">  .<span class="title function_">append</span>(<span class="string">&quot;table&quot;</span>)</span><br><span class="line">  .<span class="title function_">selectAll</span>(<span class="string">&quot;tr&quot;</span>)</span><br><span class="line">  .<span class="title function_">data</span>(matrix)</span><br><span class="line">  .<span class="title function_">enter</span>().<span class="title function_">append</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> td = tr.<span class="title function_">selectAll</span>(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">  .<span class="title function_">data</span>(<span class="keyword">function</span>(<span class="params">d</span>) &#123; <span class="keyword">return</span> d; &#125;)</span><br><span class="line">  .<span class="title function_">enter</span>().<span class="title function_">append</span>(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">    .<span class="title function_">text</span>(<span class="keyword">function</span>(<span class="params">d</span>) &#123; <span class="keyword">return</span> d; &#125;);</span><br></pre></td></tr></table></figure><p>这里感到奇怪的是tr其实是一个multi-selection了, 对他进行join data以后的td又是什么样的selection呢, 我们在后面深入了解.</p><h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><h3 id="selection结构"><a href="#selection结构" class="headerlink" title="selection结构"></a>selection结构</h3><p>打印了selection, 每个selection结构为:</p><ul><li>属性: <code>_groups</code>; 结构: 数组; 内容: 数组(内容 dom节点)</li><li>属性: <code>_parents</code>; 结构: 数组; 内容: dom节点</li></ul><p>那么接下来看一下在各个情况下selection的内容是什么.</p><h4 id="d3-select-和d3-selectAll-的返回值"><a href="#d3-select-和d3-selectAll-的返回值" class="headerlink" title="d3.select() 和d3.selectAll()的返回值"></a><code>d3.select()</code> 和<code>d3.selectAll()</code>的返回值</h4><p>在页面上有2个类名为<code>.test</code>的div. 分别选择:</p><p><code>d3.select(&quot;.test&quot;)</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  _groups<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      div.test <span class="comment">// dom node</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  _parents<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    html <span class="comment">// dom node</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>d3.selectAll(&quot;.test&quot;)</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  _groups<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// node list</span></span><br><span class="line">        <span class="punctuation">[</span></span><br><span class="line">          div.test<span class="punctuation">,</span> <span class="comment">// dom node</span></span><br><span class="line">          div.test  <span class="comment">// dom node</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  _parents<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    html <span class="comment">// dom node</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里看出, 无论选取到多少dom, <code>selection._groups</code>的长度还是为1, 只是数组第一个元素变成了node list.</p><h4 id="嵌套joining-data-的selection-结构"><a href="#嵌套joining-data-的selection-结构" class="headerlink" title="嵌套joining data 的selection 结构"></a>嵌套joining data 的selection 结构</h4><p>我们以[之前提到的例子](#嵌套joining\ data)来看. 这两个变量的结构分别为:</p><p>tr</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  _groups<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      tr<span class="punctuation">,</span></span><br><span class="line">      tr<span class="punctuation">,</span></span><br><span class="line">      tr<span class="punctuation">,</span></span><br><span class="line">      tr</span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  _parents<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    table</span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>td</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  _groups<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span>td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">,</span> td<span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  _parents<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    tr<span class="punctuation">,</span> tr<span class="punctuation">,</span> tr<span class="punctuation">,</span> tr</span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>开始我不负责的分析:</p><ol><li>&#96;&#96;&#96;js<br>var tr &#x3D; d3.select(“body”)<br>  .append(“table”)<br>  .selectAll(“tr”)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   直到这里, 当前selection还是table.</span><br><span class="line"></span><br><span class="line">2. **`.data(matrix)`**</span><br><span class="line"></span><br><span class="line">   此时table的dom里被加上了`.__data__`属性, 值为matrix.</span><br><span class="line"></span><br><span class="line">3. **`.enter()`**</span><br><span class="line"></span><br><span class="line">   因为table的`.__data__`的值第一层有4个元素. 所以被留了4个空位</span><br><span class="line"></span><br><span class="line">4. **`.append(&quot;tr&quot;)`**</span><br><span class="line"></span><br><span class="line">   在空位上创建tr元素, 并返回了新的selection(因为`.append`方法返回的新的selection). 并把parent设为table.</span><br><span class="line"></span><br><span class="line">5. ```js</span><br><span class="line">   var td = tr.selectAll(&quot;td&quot;)</span><br><span class="line">     .data(function(d) &#123; return d; &#125;)</span><br><span class="line">     .enter().append(&quot;td&quot;)</span><br></pre></td></tr></table></figure>因为tr._groups[0]是个数组(而不是dom list), 所以执行了<code>.data</code>以后<code>._groups</code>扩展到了4个元素的数组, 并进行了和上一步一样的行为.</li></ol><h4 id="each-call"><a href="#each-call" class="headerlink" title=".each(), .call()"></a><code>.each()</code>, <code>.call()</code></h4><p><code>.attr()</code>, <code>.style()</code>这样的方法可以对每个进行操作, 那么他们是如何对上面这样的selection进行操作的呢.</p><p>在<a href="https://github.com/d3/d3-selection/blob/master/src/selection/attr.js#L53">attr的源码</a>中可以看到selection还有一个<code>.each</code>方法. 顺着看到了<a href="https://github.com/d3/d3-selection#selection_each">文档</a>, 如下:</p><p><code>.each</code>接受参数<code>function(datum, index, nodes)</code>, 还有一个重要的角色是<code>this</code>, </p><p><code>.each</code>遍历的是当前selection的_.groups[0]的元素, 所以<code>this</code>每个遍历到的元素构成的selection.</p><p>还看到了<a href="https://github.com/d3/d3-selection#selection_call"><code>.call</code></a>方法, 作用是调用对传入的第一个参数为selection的函数做处理的快捷方式.</p><h2 id="应用-完成需求"><a href="#应用-完成需求" class="headerlink" title="应用: 完成需求"></a>应用: 完成需求</h2><p>于是写了一个满足需求的<a href="https://github.com/fjonas/d3-v4-learning/blob/master/selection-plugin-2017-7-29/plugin.js">插件</a>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> d3 <span class="keyword">from</span> <span class="string">&quot;d3-selection&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&quot;./svgPath&quot;</span></span><br><span class="line"></span><br><span class="line">d3.<span class="property">selection</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">createIcon</span> = <span class="keyword">function</span> (<span class="params">fn, style = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params">...params</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = <span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span> ? <span class="title function_">fn</span>(...params) : <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">let</span> svg = d3.<span class="title function_">select</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(style)) &#123;</span><br><span class="line">            svg.<span class="title function_">attr</span>(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">        svg.<span class="title function_">call</span>(drawIcon, config[id].<span class="property">path</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawIcon</span> (svg, paths) &#123;</span><br><span class="line">    svg.<span class="title function_">attr</span>(<span class="string">&quot;viewBox&quot;</span>, <span class="string">&quot;0 0 128 128&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> g = svg.<span class="title function_">append</span>(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">        .<span class="title function_">attr</span>(<span class="string">&quot;transform&quot;</span>, <span class="string">&quot;translate(0, 128) scale(0.1, -0.1)&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> each <span class="keyword">of</span> paths) &#123;</span><br><span class="line">        g.<span class="title function_">append</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">            .<span class="title function_">attr</span>(<span class="string">&quot;d&quot;</span>, each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>d3.selection.prototype.createIcon = ...</code>: 在selection的prototype上写可以直接调用</li><li><code>this.each()</code>, <code>return this</code>: 因为需求是每个图标不同, 所以需要分别获取到每个子元素所绑定的<code>__data__</code>, 调用<code>.each</code>方法, 并在最后<code>return this</code> 返回当前selection以便于继续链式操作.</li><li><code>let id = typeof fn === &quot;function&quot; ? fn(...params) : &quot;0&quot;</code>: d3的selection的所有动态参数都接受3个: datum, index, nodes. 所以看都不看直接z在每个子selection上调用插件的第一个参数, 如果传的不是方法就写个默认值(其实应该使用fn, 避免再判断是否存在配置)</li><li><code>svg.call(drawIcon, config[id].path)</code>: drawIcon方法是把第二个参数的配置画到第一个参数的selection上, 调用了selection的快捷方法<code>.call</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> d3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读vuex example</title>
      <link href="/2017/07/17/list-of-incorrect-vuex-usage/"/>
      <url>/2017/07/17/list-of-incorrect-vuex-usage/</url>
      
        <content type="html"><![CDATA[<p>阅读<a href="https://github.com/vuejs/vuex/tree/dev/examples">vuex example</a>来感受与自己写法不同的细节.</p><span id="more"></span><h2 id="state不绑定v-model"><a href="#state不绑定v-model" class="headerlink" title="state不绑定v-model"></a>state不绑定v-model</h2><p>这个原则是显而易见的, 但是我们在实际操作中还是会因为遍历多层以后不注意, 或因为操作便利上的原因适用了<code>v-model</code>绑定state, 甚至做了一些多余的操作. </p><p>再来重新分析一下为什么state不能绑定v-model:</p><ul><li>state的改变必须通过mutation来进行, 而v-model会修改绑定属性的值, 并通过对象传地址的特性来改变了state的值.</li><li>state是一个computed属性. 而computed属性是不能绑定v-model的. example中有一个购物车的例子. 试想场景: computed属性是返回所有购物车中物品的价格总和, 改变了购物车的东西, computed总价自然会变, 而把总价绑定v-model去改变他在逻辑上就是错误的.</li></ul><p>容易犯错的场景:</p><p>对于一个每个元素包含一些字段的列表, 每个元素的一些属性都可以修改并保存, 直觉上就会使用v-model去绑定这些元素.</p><p>解决方式:</p><p>不适用v-model绑定, 用v-bind:value来绑定, 并监听事件来使用mutation改变vuex的值.</p><h3 id="v-model有多甜"><a href="#v-model有多甜" class="headerlink" title="v-model有多甜?"></a><code>v-model</code>有多甜?</h3><p><a href="https://vuejs.org/v2/guide/components.html#Form-Input-Components-using-Custom-Events">v-model</a>为什么不可以被使用在computed属性呢, 因为v-model做了对computed属性赋值的操作.</p><p>vue组件交互是单向数据流的设计, 而v-model是一种双向绑定的语法糖. v-model做了两件事: 子接受父的<code>value</code>属性, 父接受子的<code>input</code>事件, 并把子组件的状态值赋给父组件的变量.</p><p>那么computed属性不能绑定v-model的情况问题出在接受了input时间并给变量赋值. 所以在computed属性我们需要分开做:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;description&quot;</span> /&gt;</span> // 错误</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;description&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;update($event.target.value)&quot;</span> /&gt;</span> // 正确</span><br></pre></td></tr></table></figure><p>在update方法中调用mutation</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    update (description) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(updateDescription, description)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在自定义组件中, v-model的行为是:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;something&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;value =&gt; &#123; something = value &#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只需要在自定义组件中的props接受value并在需要更新父组件值的时候<code>$emit</code>input事件就可以做到双向绑定, 而不需要在父组件中写方法.</p><p><strong>2.2+特性</strong></p><p>一些组件的<code>value</code>属性可能包含别的意义, 而更新父组件也不希望在<code>input</code>事件下进行, 所以v-model提供了配置语法糖属性&#x2F;事件的功能.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-checkbox&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">checked</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="comment">// this allows using the `value` prop for a different purpose</span></span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>2.3+特性</strong></p><p>在任何v-bind属性的时候加<code>.sync</code>修饰符, 只要在子组件种<code>.$emit</code>一个<code>update:binded</code>事件就可以双向绑定<code>binded</code>属性. 原理和v-model相同.</p><h2 id="什么情况要拆分组件"><a href="#什么情况要拆分组件" class="headerlink" title="什么情况要拆分组件?"></a>什么情况要拆分组件?</h2><p>在todomvc的例子中学到了一种拆分组件可以解决的问题.</p><p>在todomvc种, 每个todo项都有一个<code>editing</code>状态, 作用是双击todo名字, 进入可编辑状态, 而这个<code>editing</code>状态又是一个组件的临时状态, 不需要存入vux中, 如果v-for中去添加这个<code>editing</code>属性, 会使vuex数据结构改变.</p><p>因为子组件的数据来源的<code>props</code>和<code>data</code>是分开的, <code>props</code>取得父组件的属性, <code>data</code>作为自己私有属性, 也就是组件的状态, 那么<code>editing</code>作为这个状态就再合适不过了.</p><h2 id="vuex插件"><a href="#vuex插件" class="headerlink" title="vuex插件"></a>vuex插件</h2><p><a href="https://vuex.vuejs.org/en/plugins.html">vuex插件</a>是vuex中的钩子, 在vuex<strong>加载的时候</strong>与<strong>mutation发生的时候</strong>分别调用.</p><p>加载方式为new Store时候的<code>plugin</code>属性, 语法是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myPlugin</span> = store =&gt; &#123;</span><br><span class="line">  <span class="comment">// called when the store is initialized</span></span><br><span class="line">  store.<span class="title function_">subscribe</span>(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// called after every mutation.</span></span><br><span class="line">    <span class="comment">// The mutation comes in the format of `&#123; type, payload &#125;`.</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个钩子可以在store合法变化的时候获取到store, 这样可以在一处对数据进行同步, 而不是在每个action&#x2F;mutation中进行保存操作. </p><p>在文档中还举了一些其他vuex插件的例子.</p><p>直接通过api而非界面操作来对vuex的state进行操作.</p><p>或是保存一些状态, 根据需要回滚状态来进行时间旅行. (实际操作时打开vuex的chrome调试插件一段时间会导致内存爆炸)</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用d3来画一个时间线</title>
      <link href="/2017/07/13/draw-a-timeline-with-d3/"/>
      <url>/2017/07/13/draw-a-timeline-with-d3/</url>
      
        <content type="html"><![CDATA[<p>数据可视化不再是简单的表格, 现在慢慢地接触了解到许多数据可视化的js库, d3, processing.js, three.js, highcharts, echarts等.</p><p>本文将用基于svg的时间线例子使用d3, 先介绍api随后介绍实例中api的应用.</p><span id="more"></span><h2 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h2><p><a href="https://github.com/d3/d3">d3</a>是一个粒度很细的的lib, 比起echart算是工具类的lib. 之后的例子会有感性认识.</p><p>d3的<a href="https://github.com/d3/d3/blob/master/API.md">api</a>在4.0版本被划分成多个子模块了. 这些子模块其实功能各异, 下面例子要画的时间线使用了操作dom的模块, 数学计算的模块, 选区的模块, 各个模块的性质都是不同的.</p><p>d3官方有一个<a href="https://github.com/d3/d3/wiki/Gallery">作品展</a>有的需要购买, 可以看到效果和代码, 用作出作品或者学习.</p><p>按照惯例, 我开了一个<a href="https://github.com/fjonas/d3-v4-learning">repo</a>来放一些学的时候的demo. 下面开始来看看一部分画时间线用到的模块.</p><h3 id="d3-selection"><a href="#d3-selection" class="headerlink" title="d3-selection"></a>d3-selection</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><a href="https://github.com/d3/d3-selection">d3-selection</a>是一个操作dom的模块. 选择器有2个方法, <code>d3.select()</code>与<code>d3.selectAll()</code>, 结果类似于<code>document.querySelector</code>和<code>document.querySelectorAll</code>, 选择器也相同, d3的selector返回的是一个<code>selection</code>, <code>selection</code>也拥有<code>selection.select()</code>和<code>selection.selectAll()</code>方法, 区别是在当前selection查找.</p><p><code>d3.select()</code>也可以把普通dom转化为d3<code>selection</code>.</p><h4 id="modifying"><a href="#modifying" class="headerlink" title="modifying"></a>modifying</h4><p>d3<code>selection</code>有一些修改节点属性的方法: <code>.attr()</code>, <code>.style()</code>, <code>.text()</code>, <code>.html()</code>, <code>.append()</code>, <code>.insert()</code>… 直到这里, d3-select 还是浓重的jquery味道,</p><p>还有一些<code>.on</code>处理事件, 用法也是不看文档就能猜到的.</p><h4 id="data-joining"><a href="#data-joining" class="headerlink" title="data joining"></a>data joining</h4><p>这个特性就比较有意思, 是data driven的特性. 流程是: 选择dom &#x3D;&gt; 绑定数据 &#x3D;&gt; 渲染子dom. 渲染子dom的时候每个dom都带着了绑定了的数据.</p><p>一开始对三个东西比较疑惑: <code>.enter()</code>的意义其实是”获取被装载过data的空selection”, 而不是”进入”这个动作.</p><p>而<code>.exit()</code>的意义是”获取已经没有数据并正被渲染的dom”, 而不是”退出”这个动作. 另外<code>.merge()</code>也不是想象力的merge. </p><p>官方推荐了一个<a href="https://bost.ocks.org/mike/join/">博客</a>和一个<a href="https://bl.ocks.org/mbostock/3808218">示例</a>. 我们来看一下每次渲染的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = g.<span class="title function_">selectAll</span>(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">   .<span class="title function_">data</span>(data);</span><br><span class="line"><span class="comment">// 选择现存的dom, 并绑定数据</span></span><br><span class="line"><span class="comment">// 如果没有旧的dom, 选择器将返回带有数据的空的selection, 注意带有数据的selection就有enter和exit方法</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果存在旧dom, 更新class属性</span></span><br><span class="line"> text.<span class="title function_">attr</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;update&quot;</span>);</span><br><span class="line"></span><br><span class="line"> text.<span class="title function_">enter</span>().<span class="title function_">append</span>(<span class="string">&quot;text&quot;</span>) <span class="comment">// 获得需要插入的dom, 在这些dom上新增text节点</span></span><br><span class="line">     .<span class="title function_">attr</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;enter&quot;</span>)</span><br><span class="line">     .<span class="title function_">attr</span>(<span class="string">&quot;x&quot;</span>, <span class="keyword">function</span>(<span class="params">d, i</span>) &#123; <span class="keyword">return</span> i * <span class="number">32</span>; &#125;)</span><br><span class="line">     .<span class="title function_">attr</span>(<span class="string">&quot;dy&quot;</span>, <span class="string">&quot;.35em&quot;</span>)</span><br><span class="line">   .<span class="title function_">merge</span>(text) <span class="comment">// 更新数据</span></span><br><span class="line">     .<span class="title function_">text</span>(<span class="keyword">function</span>(<span class="params">d</span>) &#123; <span class="keyword">return</span> d; &#125;);</span><br><span class="line"></span><br><span class="line">text.<span class="title function_">exit</span>().<span class="title function_">remove</span>(); <span class="comment">// 获取到已经没有数据的dom, 并移除</span></span><br></pre></td></tr></table></figure><h3 id="d3-scale"><a href="#d3-scale" class="headerlink" title="d3-scale"></a>d3-scale</h3><p><a href="https://github.com/d3/d3-scale">d3-scale</a>是一个计算刻度比例的计算库. 数据中的年份&#x2F;距离&#x2F;颜色需要映射到实际屏幕尺寸.</p><p>scale有许多类型. 线性, 幂, 对数等scale类型. 在示例中我用了线性scale, 应该也是最常用, 最简单的scale.</p><h4 id="linear-scale"><a href="#linear-scale" class="headerlink" title="linear scale"></a>linear scale</h4><p>线性scale顾名思义, 把数据进行线性映射, 画一个<code>y = kx + b</code>的直线来映射数据与实际尺寸的关系.</p><h4 id="创建scale"><a href="#创建scale" class="headerlink" title="创建scale"></a>创建scale</h4><p>每个scale都需要被创建, 我们以linear为例.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = d3.<span class="title function_">scaleLinear</span>()</span><br><span class="line">    .<span class="title function_">domain</span>([<span class="number">10</span>, <span class="number">130</span>])</span><br><span class="line">    .<span class="title function_">range</span>([<span class="number">0</span>, <span class="number">960</span>])</span><br></pre></td></tr></table></figure><p>其中<code>.domain()</code>接受数据的范围, <code>.range()</code>接受实际尺寸的范围. <code>.range()</code>还接受颜色, 可以把颜色与数据对应来把数据显示成对应关系的颜色.</p><h4 id="使用scale"><a href="#使用scale" class="headerlink" title="使用scale"></a>使用scale</h4><p>刚才的代码我们获取了<code>scale</code> . 直接调用<code>scale()</code>传入数据值, 返回对应的实际尺寸值.</p><p>而如果通过<a href="#d3-brush">brush</a>获得了当前屏幕的尺寸, 需要知道对应了什么数据. 可以调用<code>scale.invert()</code>来获得反函数的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scale.<span class="title function_">invert</span>(<span class="number">80</span>); <span class="comment">// 20</span></span><br><span class="line">scale.<span class="title function_">invert</span>(<span class="number">320</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h3 id="d3-brush"><a href="#d3-brush" class="headerlink" title="d3-brush"></a>d3-brush</h3><p><a href="https://github.com/d3/d3-brush">brush</a>是用来在d3的selection中创建选区, 配合scale的<code>.invert()</code>方法来获取选中的数据并作处理.</p><p>下面来说一些概念.</p><h4 id="创建brush"><a href="#创建brush" class="headerlink" title="创建brush"></a>创建brush</h4><p>创建brush有3个方法, 对应着3种brush, 分别为<code>d3.brush()</code>, <code>d3.brushX()</code>, <code>d3.brushY()</code>. </p><h4 id="brush的方法"><a href="#brush的方法" class="headerlink" title="brush的方法"></a>brush的方法</h4><ul><li><strong>move</strong>: 设置brush的选区. 拖动brush即可改变选区, 而move方法可以通过代码改变brush的选区.</li><li><strong>extent</strong>: 设置brush的选区范围.</li><li><strong>filter</strong>: 设置哪些地方是不可以新建选区的.</li><li><strong>handleSize</strong>: 设置brush尺寸</li><li><strong>on</strong>: 监听时间, 分别有<code>start</code>, <code>brush</code>, <code>end</code>三个事件, 一般只用<code>brush</code>, 在brush互相调用的时候需要使用别的事件来防止无限循环.</li><li><strong>brushSelection</strong>: 获取selection的值. 这个是用在brush事件回调里, 有个参数是node, 调用这个方法就可以获得brush状态, 并用<a href="#d3-scale">scale</a>.invert来获取圈选的对应的数据.</li></ul><h4 id="装载brush"><a href="#装载brush" class="headerlink" title="装载brush"></a>装载brush</h4><p>在需要装载brush的<code>selection</code>上调用<code>.call()</code>方法来装载brush.</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>svg是一个用xml定义的矢量图形. svg有各种标签, 各种标签有各种style. 来介绍一下时间线用到的svg标签.</p><h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><p>line是画一条线. 俗话说得好, 两点确定一线.</p><p><strong>属性</strong></p><ul><li>x1 属性在 x 轴定义线条的开始</li><li>y1 属性在 y 轴定义线条的开始</li><li>x2 属性在 x 轴定义线条的结束</li><li>y2 属性在 y 轴定义线条的结束</li></ul><h3 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h3><p>画一个正方形. 属性比想象的多一点点.</p><p><strong>属性</strong></p><ul><li>rect 元素的 width 和 height 属性可定义矩形的高度和宽度</li><li>style 属性用来定义 CSS 属性</li><li>x 属性定义矩形的左侧位置（例如，x&#x3D;”0” 定义矩形到浏览器窗口左侧的距离是 0px）</li><li>y 属性定义矩形的顶端位置（例如，y&#x3D;”0” 定义矩形到浏览器窗口顶端的距离是 0px）</li><li>rx 和 ry 属性可使矩形产生圆角。</li></ul><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>随意画线.</p><p>类似于canvas的lineTo moveTo画线.</p><p>path接受一个attribute<code>d</code>, 有以下语法:</p><ul><li>M &#x3D; moveto</li><li>L &#x3D; lineto</li><li>H &#x3D; horizontal lineto</li><li>V &#x3D; vertical lineto</li><li>C &#x3D; curveto</li><li>S &#x3D; smooth curveto</li><li>Q &#x3D; quadratic Belzier curve</li><li>T &#x3D; smooth quadratic Belzier curveto</li><li>A &#x3D; elliptical Arc</li><li>Z &#x3D; closepath</li></ul><p>例子:</p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M153 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C153 334 151 334 151 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C151 339 153 344 156 344</span></span></span><br><span class="line"><span class="string"><span class="tag">C164 344 171 339 171 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C171 322 164 314 156 314</span></span></span><br><span class="line"><span class="string"><span class="tag">C142 314 131 322 131 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C131 350 142 364 156 364</span></span></span><br><span class="line"><span class="string"><span class="tag">C175 364 191 350 191 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C191 311 175 294 156 294</span></span></span><br><span class="line"><span class="string"><span class="tag">C131 294 111 311 111 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C111 361 131 384 156 384</span></span></span><br><span class="line"><span class="string"><span class="tag">C186 384 211 361 211 334</span></span></span><br><span class="line"><span class="string"><span class="tag">C211 300 186 274 156 274&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;fill:white;stroke:red;stroke-width:2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="svg通用样式"><a href="#svg通用样式" class="headerlink" title="svg通用样式"></a>svg通用样式</h3><ul><li>stroke: 描边颜色</li><li>stroke-width: 描边粗细</li><li>fill: 填充颜色</li><li>stroke-opacity: 描边透明度</li><li>fill-opacity: 填充透明度</li><li>opacity: 整个元素透明度</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>结合以上知识写了一个<a href="https://github.com/fjonas/d3-v4-learning/tree/master/timeline-2017-7-5">demo</a>. 在实现需求的过程中遇到了一些问题, 来总结一下是如何解决的. 以下问题的代码均在<a href="https://github.com/fjonas/d3-v4-learning/tree/master/timeline-2017-7-5">demo</a>中.</p><p><strong>brush需求</strong>: brush要求不能改变选区, 只能拖动选区. 使用另一个brush来改变选区的宽度, 高度固定.</p><h3 id="问题一-如何获得brush的选区数据"><a href="#问题一-如何获得brush的选区数据" class="headerlink" title="问题一: 如何获得brush的选区数据"></a>问题一: 如何获得brush的选区数据</h3><p>使用<code>.on</code>方法, 在回调函数中获取第三个参数(回调函数的参数分别为<code>target</code>, <code>type</code>, <code>selection</code>), 使用<code>d3.brushSelection</code>来把获得的<code>selection</code>转化为一个表示范围的数组.</p><h3 id="问题二-如何使两个brush联动"><a href="#问题二-如何使两个brush联动" class="headerlink" title="问题二: 如何使两个brush联动"></a>问题二: 如何使两个brush联动</h3><p>先写好2个brush, 分别在2个brush的<code>.on</code>方法中使用<code>brush.move()</code>方法, 配合在问题一中获取到的数据来计算另外一个brush需要<code>.move</code>到哪儿.</p><p>如此写会出现死循环的问题, 所以需要设置一个状态变量, 并在各自brush<code>.on(&#39;start&#39;)</code>和<code>.on(&#39;end&#39;)</code>上监听并改变状态变量, 在<code>.on(&#39;brush&#39;)</code>种判断当前状态来决定是否执行另一个brush的<code>.move()</code>方法.</p><h3 id="问题三-如何禁用brush的改变选区"><a href="#问题三-如何禁用brush的改变选区" class="headerlink" title="问题三: 如何禁用brush的改变选区"></a>问题三: 如何禁用brush的改变选区</h3><p>要使得一个brush不能改变选区, 只有拖动选区功能, 来分析选区是如何改变的, brush改变选区有两个方式: 直接点击选区的边框来拖拽更改选区, 或是直接在brush的载体上用鼠标划出一个选区. 针对这两个行为要做两个行为:</p><p>brush其实包含了8个边框, 分别为四条边和四个角. 每个边框都是一个dom, 只需要把对应的dom去掉, 就可以禁用对应的操作了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--n&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--e&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--s&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--w&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--nw&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--ne&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--se&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">brushG.<span class="title function_">select</span>(<span class="string">&quot;.handle--sw&quot;</span>).<span class="title function_">remove</span>()</span><br></pre></td></tr></table></figure><p>第二个问题, 需要使用brush的filter功能. filter的回调函数返回falsely的值就会阻止鼠标的点击事件. 我们可以根据<code>event</code>来判断鼠标点在哪里, 若不是在现存的选区中就return false. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">call</span>(brush.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event.<span class="property">target</span> !== brushG.<span class="property">_groups</span>[<span class="number">0</span>][<span class="number">0</span>].<span class="property">firstElementChild</span></span><br><span class="line">    &#125;))</span><br></pre></td></tr></table></figure><p>注意的是<code>event</code>变量在linter中会报错, 可以使用 <code>// eslint-disable-line</code>来防止linter报错.</p><h3 id="问题四-导航brush的拖动块偏外导致初始化显示不全"><a href="#问题四-导航brush的拖动块偏外导致初始化显示不全" class="headerlink" title="问题四: 导航brush的拖动块偏外导致初始化显示不全"></a>问题四: 导航brush的拖动块偏外导致初始化显示不全</h3><p>brush的样式是所有的边框都向外3px, 如果想把边框往里, 可以使用css的<code>transform: translate</code>来改变位置.</p><hr><p>参考: </p><p><a href="http://bl.ocks.org/rengel-de/5603464">例子</a></p><p><a href="http://www.simile-widgets.org/timeline/">例子</a></p><p><a href="http://bl.ocks.org/bunkat/1962173">例子</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> d3 </tag>
            
            <tag> svg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用色轮设计系统主题色</title>
      <link href="/2017/06/19/color-wheel-introduction/"/>
      <url>/2017/06/19/color-wheel-introduction/</url>
      
        <content type="html"><![CDATA[<p>从需求开始研究颜色. 工作中会遇到关于颜色的问题, 每次自己有权力选个颜色就选得超不和谐, 另外, 有的网页看久眼睛难受, 但现实生活里的东西看久不会难受, 带着这些问题来研究下颜色.</p><span id="more"></span><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>整理需要通过研究解决的问题:</p><ul><li>已知一个颜色, 如何匹配到与他能匹配的颜色.</li><li>颜色的对比是如何产生的(组成角度), 什么样的对比度在什么情境下最合适.</li><li>rgb和色轮是两种系统, 如何讲色轮映射到rgb上. 包括色轮的”加”操作如何映射到rgb的”加”操作上.</li><li>色轮的三原色是否是cmy</li></ul><p>颜色知识太深, 先务实解决问题.</p><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><h3 id="三原色"><a href="#三原色" class="headerlink" title="三原色"></a>三原色</h3><p>光的三原色是红绿蓝. 色的三原色是红黄蓝. 两者区别在于模式.</p><p>光的三原色相加是白色, 所以是加色模式: 即<strong>在无色模式下rgb相加得出颜色</strong>, 色的三原色相加是黑色: 即<strong>在白纸情况下ryb相加得出颜色</strong>.</p><p>推倒: <strong>无色的表现是黑色</strong>, 所以rgb(0, 0, 0)是黑色. 而白色是具有所有颜色rgb(255, 255, 255)</p><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>RGB是牛顿发现的. 光通过色散分解, 发现RGB是不能分解的. 所以原色是RGB.</p><p>RGB的特点是”加”. </p><p>场景是RGB值代表光的强度.</p><ul><li>1~255代表光强度, 越低合成色越接近黑色.</li><li>RGB的比例代表色相</li><li>RGB全255代表白色</li></ul><h3 id="CMY-K"><a href="#CMY-K" class="headerlink" title="CMY(K)"></a>CMY(K)</h3><p>CMY是颜料三原色, 场景是在白纸上涂上颜料, 特点是”减”. </p><ul><li>C代表没有去除红元素, RGB的 <code>G+B</code> 的颜色为C.</li><li>颜料里经常用CMY合黑色不合适, 所以加一个黑色.(与RGB的蓝色区分用K)</li><li>CMY全100%代表黑色.</li></ul><h2 id="HSB与RGB的关系"><a href="#HSB与RGB的关系" class="headerlink" title="HSB与RGB的关系"></a>HSB与RGB的关系</h2><p>HSI代表从感官上认知颜色的三个方面.</p><ul><li>色相(Hue) 颜色的品种. 也就是RGB的配比. 同一个色相的不同饱和度亮度也算同色搭配.</li><li>饱和度(Saturation) 颜色的纯度, 鲜艳度. 色相不变的情况下(RGB比例), RGB越大, 颜色越接近白色, 饱和度越低.</li><li>亮度(Brightness) 亮度与饱和度相反. 在RGB比例不变情况下, 越小, 颜色越接近黑色, 亮度越低.</li></ul><h3 id="色相"><a href="#色相" class="headerlink" title="色相"></a>色相</h3><p>色相的单位是度(角度). 也就是以RGB(255, 0, 0)为0deg&#x2F;360deg的色轮. 其公式为<code>H = f(R, G, B) (°)</code>.</p><p>在色轮的最外环移动(保持饱和度100%, 明度100%), 发现<strong>RGB种总有一个值为0</strong>. 也就是纯色的特点. 以此判断其实<strong>色相是由2个原色的比例决定的, 其余的那个是配合控制饱和度与明度的</strong>.</p><h3 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h3><p>饱和度单位是百分比. 公式: <code>S = 1 - (min(r, g, b) / max(r, g, b)) (%)</code>. (应该补充rgb(0, 0, 0)为100%)</p><p>公式的字面感觉是: rgb的最小值占rgb值总和的比例. 也就是rgb值越靠近饱和度越低(越接近黑白). 而特殊的是当rgb最小值为0的时候饱和度100%.</p><h4 id="饱和度最高"><a href="#饱和度最高" class="headerlink" title="饱和度最高"></a>饱和度最高</h4><p>rgb总有一个为0</p><h4 id="饱和度最低"><a href="#饱和度最低" class="headerlink" title="饱和度最低"></a>饱和度最低</h4><p>rgb值相同</p><h4 id="改变饱和度时rgb的变化"><a href="#改变饱和度时rgb的变化" class="headerlink" title="改变饱和度时rgb的变化"></a>改变饱和度时rgb的变化</h4><p>当饱和度从100%变为0%时, rgb值都向最大值靠拢. 最大值由亮度决定.</p><p>当饱和度达到0%, 当前色相已经掺入最大的白光(rgb相同), 形成的灰色是由原来颜色的亮度决定的.</p><h3 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h3><p>亮度的单位是百分比. 公式: <code>B = max(r, g, b) / 255 (%)</code>.</p><p>从公式看出, 亮度与rgb值总和的大小有关, 可以把rgb值想成三束光的大小, 都没光时一片黑, 都打到最亮时为白色.</p><h4 id="亮度最高"><a href="#亮度最高" class="headerlink" title="亮度最高"></a>亮度最高</h4><p>rgb总有一个值为255</p><h4 id="亮度最低"><a href="#亮度最低" class="headerlink" title="亮度最低"></a>亮度最低</h4><p>rgb全为0</p><h4 id="改变亮度时rgb的变化"><a href="#改变亮度时rgb的变化" class="headerlink" title="改变亮度时rgb的变化"></a>改变亮度时rgb的变化</h4><p>当亮度从100%变为0%时, rgb的值各自匀速变为0. 所以<strong>亮度代表rgb的最大值</strong>.</p><h2 id="颜色对比效果"><a href="#颜色对比效果" class="headerlink" title="颜色对比效果"></a>颜色对比效果</h2><p>颜色对比效果也可以分为多个通道.</p><h3 id="根据色相"><a href="#根据色相" class="headerlink" title="根据色相"></a>根据色相</h3><p>色相相差越多, 颜色对比越明显.</p><p>最大的相差为180°, 此时颜色对比最明显, 成为<strong>补色</strong>, 并且两者相加为白色.</p><p>色块相隔30%°为相似色, 用多个相似色做主题可以在同一个色调中制造丰富的质感和层次.</p><h3 id="根据饱和度"><a href="#根据饱和度" class="headerlink" title="根据饱和度"></a>根据饱和度</h3><p>饱和度明度越高, 页面色彩强烈艳丽, 对视觉刺激是迅速的, 醒目的效果, 但不易于长时间的观看.</p><h3 id="根据亮度"><a href="#根据亮度" class="headerlink" title="根据亮度"></a>根据亮度</h3><p>亮度相差越多, 对比越大.</p><hr><p>本文参考各种网上资料:</p><p><a href="http://blog.csdn.net/xhhjin/article/details/7020449">RGB&#x2F;HSB转换</a></p><p>推荐工具:</p><p><a href="https://color.adobe.com/create/color-wheel/">adobe color</a></p><p><a href="https://j-i-n.github.io/">自制工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 颜色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用electron与vue构建应用—electron api</title>
      <link href="/2017/06/13/build-an-application-with-electron-and-vue-electron-api/"/>
      <url>/2017/06/13/build-an-application-with-electron-and-vue-electron-api/</url>
      
        <content type="html"><![CDATA[<p>一个electron应用只需要在全局安装electron, 并在<code>package.json</code>中声明main入口就可以启动, 那么如何从一个空的应用出现页面, 菜单等界面并调用各种web接口&#x2F;node接口&#x2F;os接口呢. 这里是<a href="https://github.com/electron/electron-api-demos">官方api例子</a>.</p><span id="more"></span><h2 id="应用进程"><a href="#应用进程" class="headerlink" title="应用进程"></a>应用进程</h2><p>electron应用的进程分为<code>Main Process</code>(主进程)和<code>Renderer Process</code>(渲染进程), 主进程是整个应用的进程, 控制窗口的建立消除&#x2F;应用菜单&#x2F;后台行为等, 渲染进程其实就是网页进程(窗口进程), 控制界面的行为和与主进程的交互. 写到这里感觉与之前的<a href="/2016/11/07/how-to-build-an-chrome-extension/">使用vue编写chrome拓展</a>的应用结构几乎一样, 只是api和发布平台不同.</p><h2 id="Electron-API-分类-x2F-使用-介绍"><a href="#Electron-API-分类-x2F-使用-介绍" class="headerlink" title="Electron API 分类&#x2F;使用 介绍"></a>Electron API 分类&#x2F;使用 介绍</h2><p><a href="https://electron.atom.io/docs/">文档</a>的中间那列API Reference, 被分为了主进程api, 渲染进程api和共享api.</p><p>使用api的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;apiName1, apiName2&#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>)</span><br></pre></td></tr></table></figure><p>在介绍API前, 先用<a href="https://github.com/electron/electron-quick-start">官方quick start</a>的例子(作用是打开一个窗口并加载html页面)来对api的使用有感性认识.</p><p>在入口<code>main.js</code>中, 引用了两个api: <code>app</code> 和 <code>BrowserWindow</code>.</p><p><code>app</code>指的是主进程应用, 例子中监听了<code>ready</code>事件并执行<code>createWindow</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, createWindow)</span><br></pre></td></tr></table></figure><p>在<code>createWindow</code>中, 调用了<code>BrowserWindow</code>来创建window对象, 并加载html到窗口中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the browser window.</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;<span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and load the index.html of the app.</span></span><br><span class="line">  mainWindow.<span class="title function_">loadURL</span>(url.<span class="title function_">format</span>(&#123;</span><br><span class="line">    <span class="attr">pathname</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;index.html&#x27;</span>),</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;file:&#x27;</span>,</span><br><span class="line">    <span class="attr">slashes</span>: <span class="literal">true</span></span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><p>如此, 在当前目录下运行<code>electron . </code>就可以看到自己编写的<code>index.html</code>页面了.</p><h2 id="API走马观花"><a href="#API走马观花" class="headerlink" title="API走马观花"></a>API走马观花</h2><p>经过了刚才的例子, 对api的调用场景有了概念, 来看一看常用的api能干些啥.</p><h3 id="app与BrowserWindow"><a href="#app与BrowserWindow" class="headerlink" title="app与BrowserWindow"></a><code>app</code>与<code>BrowserWindow</code></h3><p><code>app</code>是用来控制整个应用的事件, 分为event和methods.</p><p>event包含应用的各个事件, 如创建窗口&#x2F;关闭窗口&#x2F;打开文件&#x2F;获得焦点&#x2F;退出等. </p><p>methods包含应用的退出&#x2F;激活&#x2F;显示隐藏&#x2F;设置图表&#x2F;获得应用的当前状态.</p><p><code>BrowserWindow</code>的使用方法是<code>new BrowserWindow(options) </code>. 根据不同的参数会得到不同性质的窗口, 窗口实例也有监听event和自己的methods, events都是对窗口的操作(点击&#x2F;拖动&#x2F;全屏)和关闭, methods有显示隐藏&#x2F;关闭等等, 和app相似.</p><p>来说几个创建对象的参数:</p><ul><li><code>parent</code>: 子窗口会随着父窗口一起被拖动. 猜想使用场景是应用的settings.</li><li><code>modal</code>: 顾名思义, 子窗口在父窗口中. 我们在需要modal的时候可以不用html模拟了.</li></ul><h3 id="Menu与MenuItems"><a href="#Menu与MenuItems" class="headerlink" title="Menu与MenuItems"></a><code>Menu</code>与<code>MenuItems</code></h3><p>这对api是用来创建应用菜单的. 菜单产生如下:</p><ul><li><p><code>MenuItem</code>是menu class, new <code>MenuItem</code>或<code>Menu.buildFromTemplate()</code>使用是产生menu对象的方法.</p></li><li><p><code>MenuItem</code>是一个数组, <code>label</code>是菜单名, <code>click</code>方法是点击以后执行的方法. 还有一些别的选项, 另外<code>submenu</code>是递归子菜单的选项, 不同的是可以不接受manu对象, 可以直接传option, electron会自动parse成menu对象.</p></li><li><p><code>MenuItem</code>还提供了个快捷选项<code>role</code>, electron有一些内置的菜单, 比如只要<code>role: &quot;copy&quot;</code> electron就会产生一个复制菜单, 并有我们期待中的一切效果.</p></li><li><p>把产生的Menu使用<code>Menu.setApplicationMenu</code>设成菜单就可以, 官方文档的写法(用了<code>Menu.buildFromTemplate</code>来产生menu):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menu = <span class="title class_">Menu</span>.<span class="title function_">buildFromTemplate</span>(template)</span><br><span class="line"><span class="title class_">Menu</span>.<span class="title function_">setApplicationMenu</span>(menu)</span><br></pre></td></tr></table></figure></li></ul><p>最后, 要注意的是, 如果系统是mac, 那么要unshift一个menu, 因为mac的第一个菜单是应用标题.</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a><code>shell</code></h3><p>这是一个公用api, 作用是系统(桌面)集成. (有一个段子是总把shell翻译成”壳”, 那么这里的shell可能真的是”壳”的意思了)</p><p>方法介绍:</p><ul><li><code>shell.showItemInFolder(fullPath)</code> 在文件夹中显示</li><li><code>shell.openItem(fullPath)</code> 用系统默认打开文件</li><li><code>shell.openExternal(url[, options, callback])</code> 打开网页</li><li><code>shell.moveItemToTrash(fullPath)</code> 扔进回收站</li><li><code>shell.beep()</code> 让系统叫一下</li><li>(windows) <code>shell.writeShortcutLink(shortcutPath[, operation], options)</code> 创建快捷方式</li><li>(windows)<code>shell.readShortcutLink(shortcutPath)</code> 读取快捷方式</li></ul><h3 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h3><p>操作文件与各种其他弹窗, 是主程序api, 如果需要在渲染进程中调用, 可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;dialog&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>).<span class="property">remote</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dialog)</span><br></pre></td></tr></table></figure><ul><li><p><code>dialog.showOpenDialog([browserWindow, ]options[, callback])</code> 选择文件. 选项可以调整目标文件的范围, 在callback中获得选择的文件, 如果不指定callback, 选择的文件将作为函数的返回值.</p></li><li><p><code>dialog.showSaveDialog([browserWindow, ]options[, callback])</code> 同上, 只是按钮变成保存. 实际操作都得自己做.</p></li><li><p><code>dialog.showMessageBox([browserWindow, ]options[, callback])</code> 弹出框, 选项中只有<code>message</code>是required的. </p><p>callback的内容有两个字段, <code>response</code> 如果设置了多个按钮, 被点击的按钮的索引, <code>checkboxChecked</code> 如果设置了<code>checkboxLabel</code> 这里是checkbox的值, 默认是false. (经尝试<code>checkboxLabel</code>在mac上没有显示出来). 如果没有设置callback, 那么<code>response</code>将会作为函数的返回值.</p></li><li><p><code>dialog.showErrorBox(title, content)</code> 这是错误提示, 只有两个简单的参数.</p></li></ul><h3 id="ipcMain与ipcRenderer"><a href="#ipcMain与ipcRenderer" class="headerlink" title="ipcMain与ipcRenderer"></a><code>ipcMain</code>与<code>ipcRenderer</code></h3><p>这两个是主进程与渲染进程通信的方式. </p><ul><li>发送事件没有callback, <code>sendSync()</code>方法可以获取监听端的<code>event.returnValue</code>值.</li><li>监听端可以使用<code>evnet.sender.send()</code>或另外一个api<code>webContents.send</code>来向渲染进程发, 但没有<code>sendSync()</code>方法. <code>webContents.send</code>在下回分解.</li></ul><h2 id="告一段落"><a href="#告一段落" class="headerlink" title="告一段落"></a>告一段落</h2><p>如此构造文件结构, 调用api, 已经可以把自己的web应用增加系统集成并发布到mac, windows, linux平台了, 剩下的标准流程的配置, 测试就和web开发一样了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> electron </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用electron与vue构建应用--应用结构</title>
      <link href="/2017/06/13/build-an-application-with-electron-and-vue-app-structrue/"/>
      <url>/2017/06/13/build-an-application-with-electron-and-vue-app-structrue/</url>
      
        <content type="html"><![CDATA[<p>electron越来越流行,  github也用起来写了个client, 之前写过用md做presentation的东西, 现在考虑结合一下试试做个md工具再加上博客发布功能等应用.</p><span id="more"></span><p>electron应用的优点:</p><ul><li>一份代码发布到三个平台</li><li>作为web开发不用兼容低版本和浏览器内核差异</li></ul><p>之前跟着electron官网的<a href="https://github.com/electron-userland/electron-builder">例子</a>和<a href="https://github.com/electron-userland/electron-packager">electron-packer</a>运行有过失败的经验, 这次看着另外个<a href="https://github.com/egoist/eme">项目</a>来尝试. 前半部分介绍一下各个功能需要的依赖和运行方式.</p><h2 id="common的vue和es6构建"><a href="#common的vue和es6构建" class="headerlink" title="common的vue和es6构建"></a>common的vue和es6构建</h2><p>作为vue的项目, 在<code>dependencies</code>中添加<code>vue</code>和<code>vuex</code>, <code>devDependencies</code>中依赖<code>webpack</code>及一系列相关的loader.</p><p>在拉取<a href="https://github.com/electron-userland/electron-builder">eme</a>代码的时候频频报错, 在webpack和各种loader的时代已经无法坚持使用npm了, <a href="https://yarnpkg.com/">yarn</a>其实只是作为npm的一个封装吧, 实际也是拉了npm的代码仓库. 命令也很简单.</p><table><thead><tr><th align="left">npm</th><th>yarn</th></tr></thead><tbody><tr><td align="left">npm i</td><td>yarn</td></tr><tr><td align="left">npm i -S <name></td><td>yarn add <name></td></tr><tr><td align="left">npm i -D <name></td><td>yarn add -D <name></td></tr></tbody></table><h2 id="electron应用启动"><a href="#electron应用启动" class="headerlink" title="electron应用启动"></a>electron应用启动</h2><p>electron有一个主进程, 需要在<code>package.json</code>的<code>main</code>字段中声明主进程. <a href="https://github.com/fjonas/yohane-client/blob/empty/app/main.js">十几行代码</a>就可以启动electron应用了. 具体electron的api简介会在下一章讨论.</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>开发环境在<code>package.json</code>中不需要配置, electron开发者在全局安装即可本地运行.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g electron</span><br></pre></td></tr></table></figure><p>electron运行的时候<code>commond + r</code>就可以刷新, 配合webpack的—watch参数即可.</p><h2 id="build与发布"><a href="#build与发布" class="headerlink" title="build与发布"></a>build与发布</h2><p>在<code>devDependencies</code>添加<code>electron-prebuilt</code></p><p>官方推荐了两个发布类, 因为在文章开头提到的失败, 这次选用了<a href="https://github.com/electron-userland/electron-builder">electron-builder</a>来构建, 操作非常简单.</p><ol><li>在<code>package.json</code>中配置<code>build</code>字段</li><li>在<code>package.json</code>的<code>scripts</code>字段中配置命令<code>build</code></li><li>在<code>package.json</code>中添加字段<code>postinstall</code>值为<code>install-app-deps</code></li><li>在项目下建<code>build</code>文件夹存放windows和mac的icon, 和mac安装时的背景.</li></ol><p>我是这么写的:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;postinstall&quot;</span><span class="punctuation">:</span> <span class="string">&quot;install-app-deps&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dist&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run mac &amp;&amp; npm run linux &amp;&amp; npm run win&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build --mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linux&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build --linux deb tar.xz&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;win&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build --win --ia32&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --config webpack/webpack.config.js --progress --watch &amp; electron app&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.yo-cwj.yohane-client&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;public.app-category.utilities&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;win&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;squirrel&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><p>到这里, 一个<a href="https://github.com/fjonas/yohane-client/tree/empty">空的应用架子</a>已经完成60%并可以运行了. 搞笑的是在文档里看到了<a href="https://github.com/SimulatedGREG/electron-vue">starter</a>. 觉得都白做了.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> electron </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从vuex源码分析module与namespaced</title>
      <link href="/2017/05/31/vuex-source-analyzation-modules-and-namespaced/"/>
      <url>/2017/05/31/vuex-source-analyzation-modules-and-namespaced/</url>
      
        <content type="html"><![CDATA[<p>使用vue已经有半年有余, 在各种正式非正式项目中用过, 开始专注于业务比较多, 用到现在也遇见不少因为理解不深导致的问题. 有问题就有找原因的勇气, 所以带着问题搞一波.</p><span id="more"></span><h2 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h2><p>所以来整理了一下使用过程中不注意或者不规范, 或者简化写法的奇技淫巧, 会结合文档的说明和实际的问题来看看源码, 问题:</p><ul><li>module在vuex里实际的数据结构</li><li>namespaced在vuex里实际的数据结构</li><li>mapState, mapActions等helper的正确用法(配合module&#x2F;namespaced), 或者是否存在更多骚用法</li><li>mutation中赋值&#x2F;触发state变化原理</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>看的源码版本为vuex2.3.1</p><p>我们使用vuex可能是类似:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> plugins <span class="keyword">from</span> <span class="string">&#x27;./plugins&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">todo</span>: [<span class="string">&quot;todo1&quot;</span>, <span class="string">&quot;todo2&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="title function_">mutationName</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">            state.<span class="property">xxx</span> = payload.<span class="property">xxx</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="title function_">actionName</span>(<span class="params">&#123; commit, dispatch &#125;, payload</span>) &#123;</span><br><span class="line">            <span class="title function_">commit</span>(mutationName, payload)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">modules</span>: &#123;</span><br><span class="line">        <span class="attr">catagories</span>: &#123;</span><br><span class="line">            <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">mutations</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用vuex的方法为使用<code>Vue.use</code>来install<code>vuex</code>, 并new一个Store实例, 我们来看一下vuex核心对象.</p><h3 id="Store对象分析"><a href="#Store对象分析" class="headerlink" title="Store对象分析"></a>Store对象分析</h3><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L6">line6</a>: 本地vue变量, 在install时会被赋值, 之后会通过vue是否为<code>undefined</code>来判断是否install</p><h4 id="Store对象构建"><a href="#Store对象构建" class="headerlink" title="Store对象构建"></a>Store对象构建</h4><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L10">line10~14</a>: 判断vuex是否被正确使用<br><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L16">line16~26</a>: 获取options, <strong><code>state</code>可以和vue的component的<code>data</code>一样为函数return一个对象, 会在这段代码中被parse</strong><br><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L28">line28~36</a>: <a href="#store%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96">store对象内部变量初始化</a><br><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L39">line39~46</a>: 绑定commit和dispatch方法到自身<br><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L54">line54</a>: 装载动作<br><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L58">line58</a>: 装载响应动作<br><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L61">line61</a>: 调用插件</p><h4 id="store内部变量初始化"><a href="#store内部变量初始化" class="headerlink" title="store内部变量初始化"></a>store内部变量初始化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>是否合法更新state的标识, 对象有方法<code>_withCommit</code>是唯一可以改动<code>_committing</code>的方法, 只有对象内部使用<code>_withCommit</code>更新状态才是合法的, 在<code>strict</code>模式下非法更新state会抛出异常.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br></pre></td></tr></table></figure><p>modules的cache, 直接把store的参数全部扔给了<code>ModuleCollection</code>新建一个modules对象.</p><p>点击跳转<a href="#ModuleCollection%E5%AF%B9%E8%B1%A1">ModuleCollection对象</a>来看分析.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_modulesNamespaceMap</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_subscribers</span> = []</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_watcherVM</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure><p><a href="#Store%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93">其余的变量</a>是新建了空的变量, 之后会在<a href="#install%E6%A8%A1%E5%9D%97">install模块</a>的时候赋值.</p><h4 id="绑定dispatch和commit方法"><a href="#绑定dispatch和commit方法" class="headerlink" title="绑定dispatch和commit方法"></a>绑定dispatch和commit方法</h4><p>在<a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L39">line39~46</a>, 对dispatch和commit方法进行绑定, 使dispatch方法可以调用在Store对象上注册过的<code>._actions</code></p><p>和<code>._mutations</code>的方法.</p><p>dispatch方法在<a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L108">line108</a>, 先兼容了参数的写法, 取到参数, 然后判断Store对象的<code>_.actions</code>属性是否注册过, 如果注册过多个, 将会<strong>依次调用</strong>. 也就是如果type重复了也是会调用多次的, 这个地方如果出错debug会非常困难. 暂时没有理解vuex此处设计的意图.</p><p>commit方法稍微多一点, 大体思路是一样的, 只是直接执行没有返回值, dispatch会返回执行结果. 另外在<a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L95">line95</a>进行了subscriber的操作, 我们暂且不知道subscriber的作用. 稍后再看.</p><h4 id="install模块"><a href="#install模块" class="headerlink" title="install模块"></a>install模块</h4><p>首先来看参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span> (store, rootState, path, <span class="variable language_">module</span>, hot)</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">installModule</span>(<span class="variable language_">this</span>, state, [], <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L255">line255</a> 根据path获得namespace, 做法是读取path的每个模块, 如果namespaced为true则拼接, 例如path为<code>[&#39;catagories&#39;, &#39;price&#39;, &#39;detail&#39;]</code>, 其中<code>price</code>的namespaced为false, 其余为true, 那么获得的namespace为<code>catagories/detail/</code>.</p><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L260">line258~260</a> 把namespaced为true的module注册到<code>_modulesNamespaceMap</code>.</p><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L271">line271</a>的<code>makeLocalContext</code>函数整理了namespace和type的关系. 在之后的三个<code>module.forEachXxx</code>中, 都调用了<code>registerXxx</code>, 最后的参数都是<code>makeLocalContext</code>的返回值.  我们来分析一下<code>makeLocalContext</code>的作用:</p><p>被注册到全局的mutation&#x2F;actiongetter实际的type类似于<code>namespace1/namespace2/type</code>的形式, 而我们在namespaced为true的module中调用的type只是:<code>type</code>. 所以在namespace[true]的action中调用的所有<code>dispatch</code>, <code>commit</code>, <code>getter</code>, <code>state</code> 都会被加上  path.join(“&#x2F;“) + “&#x2F;“  的type来调用到正确的方法.</p><p>根据注册的type, 我还得到了一个偏门结论: <strong>可以通过设置type为<code>namespace1/namespace2/type</code>来调用其他namespace的type</strong>(待测试), 因为他们是这样被注册的.</p><h4 id="install-child-module"><a href="#install-child-module" class="headerlink" title="install child module"></a>install child module</h4><p>通过比较, install child module的时候是改了第三第四个参数: <code>path</code> &#x3D;&gt; <code>path.concat(key)</code>, <code>module</code> &#x3D;&gt; <code>module.getChild(key)</code>.</p><p>主要区别只是在<a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L264">line264~268</a>, 与<a href="#%E9%80%92%E5%BD%92register%E5%AD%90module">ModuleCollection的递归注册子module</a>行为类似, 递归的path参数流程上只是多了一步把当前loop产生的对象挂到父节点上. 做法也是一样的, 把module名字(path)作为key, 套在父级state上. 也就是结构为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state</span>: &#123;</span><br><span class="line">  ...currentState,</span><br><span class="line">  <span class="attr">moduleName</span>: &#123;</span><br><span class="line">    ...subState</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module2Name</span>: &#123;</span><br><span class="line">    ...anotherSubState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前注册Mutation的时候vuex也是通过这个方法来试mutation获得嵌套过的state作为arguments[0]的.</p><h4 id="Store对象总结"><a href="#Store对象总结" class="headerlink" title="Store对象总结"></a>Store对象总结</h4><p>store对象把传入的options放入了各个变量进行储存, 并提供了commit, dispatch等方法来调用和处理他们:</p><h5 id="modules"><a href="#modules" class="headerlink" title="._modules"></a><code>._modules</code></h5><p>这里存放raw的modules, 未经处理的, 以module名字作为key的方式递归子module.</p><h5 id="state"><a href="#state" class="headerlink" title=".state"></a><code>.state</code></h5><p>这里也是以module名字作为key的方式递归储存传入的state</p><h5 id="entrys"><a href="#entrys" class="headerlink" title="entrys"></a>entrys</h5><p>这里的entry指<code>._actions</code>, <code>._mutations</code>, <code>._getters</code>. 他们的储存方式并没有递归储存key, 而是平级的, 用<code>/</code>来分割namespace来分辨type, 并在注册时把当前的entry绑定对应的state(通过<code>getNestedState</code>方法).</p><p>问题: 如果在不同module注册了相同type的mutation, 会发生什么?</p><p>回答: 会依次在自己的state中执行, 不会影响对方state, 但是会造成错误执行. (待测试). 所以应该在大的项目中尽量使用namespaced[true]的方式, 而不是命名的方式.(但是也是可以利用<code>/</code>来串namespace的, 所以自己type命名避免<code>/</code>)</p><h5 id="modulesNamespaceMap"><a href="#modulesNamespaceMap" class="headerlink" title="._modulesNamespaceMap"></a><code>._modulesNamespaceMap</code></h5><p>根据namespace为key来存放子module</p><h4 id="初始化Store-VM"><a href="#初始化Store-VM" class="headerlink" title="初始化Store VM"></a>初始化Store VM</h4><p>这里会新建一个Vue实例并赋值给Store对象的<code>._vm</code>属性, 把整个vuex的状态放进去. 并判断严格模式, 如果为严格模式会在非法改变状态的时候抛出异常.</p><p>这样整个构建动作已经完成了, 那么这个<code>._vm</code>在什么时候用的, 请看下面的章节.</p><h3 id="Store对象的属性-amp-方法"><a href="#Store对象的属性-amp-方法" class="headerlink" title="Store对象的属性&amp;方法"></a>Store对象的属性&amp;方法</h3><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L64">line64</a> state的getter方法, 会获取<code>._vm</code>的vue实例的state. 所以我们在vue代码中<code>this.$store.state.xxx</code>获取到的东西就是这个vue的实例的数据.</p><p><a href="https://github.com/vuejs/vuex/blob/v2.3.0/src/store.js#L68">line68</a> 当直接set Store的state时报错, 只能通过设置<code>._vm</code>来进行.</p><p>剩余的方法的是vuex的进阶用法, 是可以在使用时对vuex状态进行操作的方法, 详见<a href="http://vuex.vuejs.org/en/api.html#vuexstore-instance-methods">文档</a></p><h3 id="ModuleCollection对象"><a href="#ModuleCollection对象" class="headerlink" title="ModuleCollection对象"></a>ModuleCollection对象</h3><p>我们来看下<code>ModuleCollection</code>的构造方法.</p><h4 id="register根module"><a href="#register根module" class="headerlink" title="register根module"></a>register根module</h4><p>调用了<code>register</code>方法, 把参数的path设为根目录, runtime设为false.</p><p><code>register</code>方法一开始(l30)就判断了除<code>state</code>外的属性的值是否为函数, 若不是则抛出异常.</p><p>line33 把module参数(还是初始的options, 就是<code>&#123;state:&#123;...&#125;, mutations:&#123;...&#125;, actions: &#123;...&#125;&#125;</code>这个)和runtime &#x3D; false 来构建了<code>Module</code>对象(稍后我们看Module对象的构造)</p><p>line35 把<code>ModuleCollection</code>的root私有变量设为了刚才使用初始options新建的<code>Module</code>对象.</p><p>line42 如果初始options有modules这个属性, 就开始递归注册modules. </p><h4 id="递归register子module"><a href="#递归register子module" class="headerlink" title="递归register子module"></a>递归register子module</h4><p>上面是<code>register</code>的第一个参数<code>path</code>为空, 也就是root节点的时候的流程, 在最后一部分(line42)根据是否当前注册的module含有modules属性来递归注册, 这部分我们来看一下register的path参数的行为会把数据存成什么结构. 以<a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">概览</a>部分的例子的参数为例(modules含有一个key为<code>catagories</code>)来走一遍代码流程. (开始~)</p><p>被作为子module传入<code>register</code>方法的参数应该为: <code>path</code>([‘catagories’]), <code>rawModule</code>(state: {},mutations: {}), <code>runtime</code>(false).</p><p>注意到的是, 如果<code>catagories</code>有同级module, 被传入的<code>path</code>也是一个元素的数组, 也就是path的意思应该类似于从跟到当前module的层级, 对于兄弟节点是无感的.</p><p>这里的<code>runtime</code>尚未明白用途, 可能是在别处调用的. 注册流程应该runtime都为false.</p><p>一路看下来, 也是new了一个<code>Module</code>对象, 但是没有走到line35把new出的对象放到<code>root</code>变量里, 而是在line37~38去寻找当前module的父节点并把自己作为child, append到父节点上.</p><p>这里又脑补了一下数据结构: <code>path.slice(0, -1)</code>是获取被pop()一下的path, <code>path[path.lengt - 1]</code>是获取当前path的最后一个元素, 也就是当前正在被register的module的key. 所以之前对于path的数据结构判断是正确的.</p><p>这里的<code>appendChild</code>和<code>getChild</code>很明显是<code>Module</code>对象的方法了, 我们再继续看<code>Module</code>对象的结构.</p><h4 id="Module对象"><a href="#Module对象" class="headerlink" title="Module对象"></a><code>Module</code>对象</h4><p>最后来看<code>Module</code>对象的构造~</p><p>接受2个参数, 一个<code>rawModule</code>, 一个<code>runtime</code>, 第一个参数是刚才相对于key为<code>catagories</code>的value, 也就是类似<code>&#123;state: xxx, mutations: xxx, actions: xxx&#125;</code>的options. </p><p><code>Module</code>的构造函数只是把参数拆分, 放入了自己的私有变量, 其中<code>state</code>也接受函数, 并执行函数parse成对象存入私有变量. 其他变量都是原封不动储存的, 所以vuex给他起名为 <strong>raw</strong>Module 吧. 剩下那些方法都是顾名思义的, 语法上也简单, 没什么好看的.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>那么这样Store对象的<code>._modules</code>属性的数据结构已经很清楚了. 类似于(脑内):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// (ModuleCOllection实例)</span></span><br><span class="line">  <span class="attr">root</span>: &#123;</span><br><span class="line">    <span class="comment">// (Module实例)</span></span><br><span class="line">    <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">      <span class="attr">state</span>: &#123;...&#125;, <span class="attr">mutations</span>: &#123;...&#125;, <span class="comment">// ...(全是options直接传入)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>: &#123;&#125;, <span class="comment">// 进行过parse的state, 如果是function会调用并赋值</span></span><br><span class="line">    <span class="attr">_children</span>: &#123;</span><br><span class="line">      <span class="attr">catagories</span>: &#123;</span><br><span class="line">        <span class="comment">// (Module实例)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">anotherModule</span>: &#123;</span><br><span class="line">        <span class="comment">// (Module实例), 递归</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一点, 就是这里贮存的数据都是”raw”的.</p><h2 id="helpers"><a href="#helpers" class="headerlink" title="helpers"></a>helpers</h2><p>所有的helper都用了两个wrap方法, 先来看下这两个方法的作用.</p><h4 id="normalizeNamespace"><a href="#normalizeNamespace" class="headerlink" title="normalizeNamespace"></a><code>normalizeNamespace</code></h4><p>因为helper是都接受两种传参方式:<code>mapState(namespace, map)</code> &#x2F; <code>mapState(map)</code> , 如果第一个参数为map时这个函数把namespace设为空字符串 , 并且检查namespace的最后一个字符是不是<code>/</code>, 如果不是的话加上.</p><h4 id="normalizeMap"><a href="#normalizeMap" class="headerlink" title="normalizeMap"></a><code>normalizeMap</code></h4><p>我们map的内容也接受两种语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;state1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;state2&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">state1</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">state1</span>,</span><br><span class="line">  <span class="attr">state2</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">state2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个wrap函数会把两种形式都normalize为含有<code>key</code>和<code>val</code>属性的数组, 便于统一处理. 也就是上面个两个形式会转化为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array like</span></span><br><span class="line">[&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;state1&quot;</span>,</span><br><span class="line">  <span class="attr">val</span>: <span class="string">&quot;state1&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;state2&quot;</span>,</span><br><span class="line">  <span class="attr">val</span>: <span class="string">&quot;state2&quot;</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="comment">// Object like</span></span><br><span class="line">[&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;state1&quot;</span>,</span><br><span class="line">  <span class="attr">val</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">state1</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;state2&quot;</span>,</span><br><span class="line">  <span class="attr">val</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">state2</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><p>这里做了2个处理: </p><ul><li>如果namespace不为空, 把state和getter的环境切换到相对于namespace的环境(就是之前的<code>makeLocalContext</code>的返回值)</li><li>如果val为函数则执行, 否则返回state的val为键的属性. 两者的执行环境皆为处理过namespace的local环境.</li></ul><h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><p>mapAction的val语法只接受字符串的, 所以先把val前借namespace, 变为: <code>namespace/val</code>, 这样能符合在Store里注册的entry名. </p><p>然后检查了一下namespace是否被注册过, 也就是防碰撞, 然后把val作为type, 并把剩余参数带着dispatch Store里的action.</p><hr><p>参考:</p><ul><li><a href="http://tech.meituan.com/vuex-code-analysis.html">美团vuex源码分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 分析 </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2.0 filter替代方案</title>
      <link href="/2017/03/02/vue2filter/"/>
      <url>/2017/03/02/vue2filter/</url>
      
        <content type="html"><![CDATA[<p>vue2.0开始其实是准备取消filter, 最后保留了text的filter并取消内置filter. 作者本意是用原生更优雅, 灵活地替代filter的. 所以讨论并总结一下</p><span id="more"></span><h2 id="filter的prons-amp-cons"><a href="#filter的prons-amp-cons" class="headerlink" title="filter的prons&amp;cons"></a>filter的prons&amp;cons</h2><p>关于吹黑的东西我真的觉得是浪费时间, 只有值得去解释的人和直接碰到同样理解的人. 这个head只是交代一下问题背景.</p><h3 id="filter-proponents"><a href="#filter-proponents" class="headerlink" title="filter proponents"></a>filter proponents</h3><ul><li>容易, 直白</li><li>全局, 可复用</li><li>新手容易上手, 体验好</li></ul><h3 id="computed-x2F-native-proponents"><a href="#computed-x2F-native-proponents" class="headerlink" title="computed&#x2F;native proponents"></a>computed&#x2F;native proponents</h3><ul><li>确实比较难上手</li><li>可以在vue中挂在prototype上使用, 但还是建议按需引用</li><li>因为原生, 可灵活组合&#x2F;可用在别的地方</li><li>filter的管道操作符将进入es标准, 导致和现在的filter冲突</li></ul><h2 id="如何不使用filter来在项目中format-data"><a href="#如何不使用filter来在项目中format-data" class="headerlink" title="如何不使用filter来在项目中format data"></a>如何不使用filter来在项目中format data</h2><p>不使用filter的代替而使用原生的函数format数据, 首先需要</p><h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>首先有一种不推荐的全局引入到vue的<code>prototype</code>, 代码在issue(文末)里有, 我觉得比较正规的做法是按需引入.  类似于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reserve, filterBy, findBy&#125; <span class="keyword">from</span> <span class="string">&quot;./filter&quot;</span></span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>filter使用有两种情况, 一种是对字符串做处理, 一种是对数组&#x2F;对象做处理.</p><ul><li><p>第一种情况其实是真的format数据, 可能占去了90%的使用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reserve, filterBy, findBy&#125; <span class="keyword">from</span> <span class="string">&quot;./filter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    reverse,</span><br><span class="line">    filterBy,</span><br><span class="line">    findBy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html也很容易, 如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;reverse(words)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>第二种情况占比相对少, 是对数组&#x2F;对象做处理, 一般用于过滤, 排序, 分页等情况. 这种情况filter的使用会出现链式调用, 如果与第一种用法相同会导致代码可读性变差.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;filter, sort, slice&#125; <span class="keyword">from</span> <span class="string">&quot;./filter&quot;</span></span><br></pre></td></tr></table></figure><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slice(sort(filter(data, &quot;keywords&quot;), &quot;asc&quot;), 5, 0)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以这种情况推荐使用<code>computed</code>, 还能充分利用函数编程的灵活, 给开发者极大的空间来根据自己的情况开发filter, 也给第三方lib一个更好的机会.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  filteredThings () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">things</span></span><br><span class="line">       .<span class="title function_">filter</span>(<span class="title function_">contains</span>(<span class="variable language_">this</span>.<span class="property">foo</span>))</span><br><span class="line">       .<span class="title function_">sort</span>(<span class="title function_">by</span>(<span class="function"><span class="params">thing</span> =&gt;</span> thing.<span class="property">bar</span>))</span><br><span class="line">       .<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些辅助函数可能是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">contains</span> (value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">thing</span> =&gt;</span> thing.<span class="title function_">indexOf</span>(value) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">by</span> (getValue) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getValue</span>(a) &gt; <span class="title function_">getValue</span>(b) ? <span class="number">1</span> : -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何写filter"><a href="#如何写filter" class="headerlink" title="如何写filter"></a>如何写filter</h2><p>这个问题大概能看出程序员的水平了. 如何更优雅是个永久的问题. <a href="https://github.com/fjonas/vueFormatData">现在是这样的</a></p><p>参考:</p><ul><li><a href="https://github.com/vuejs/vue/issues/2756">issue</a></li><li><a href="https://forum-archive.vuejs.org/topic/3896/i-m-going-to-miss-filters-in-vue-2-0">discussion</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码组织 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron介绍</title>
      <link href="/2016/12/20/intro-of-electron/"/>
      <url>/2016/12/20/intro-of-electron/</url>
      
        <content type="html"><![CDATA[<p><a href="http://electron.atom.io/">electron</a>是个可以通过html, css, js 技术制作桌面应用的项目. 于是读了一下guide了解了大概的流程.</p><span id="more"></span><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h3><p>新建个npm项目, 依赖<code>electron</code>就可以了.</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>在<code>package.json</code>中的main字段指定主进程文件.</p><ul><li>主进程: 打开应用就存在的进程.</li><li>渲染进程: 打开每个窗口存在的进程.</li></ul><p>在主流程中指定打开什么窗口, 以及各种业务流程.</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>electron . </code></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>可以用第三方库以<code>electron-package</code>举例. 安装好以后运行一个桌面应用就产生了.</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>devtron&#x2F;spectron&#x2F;webdriver 开发&#x2F;测试工具</p></li><li><p>electron-builder, electron-packager 第三方打包工具</p></li><li><p>chrome 拓展: Chrome DevTools Extension</p></li><li><p>调试参数: 在5858端口起web容器 electron –debug&#x3D;5858 your&#x2F;app</p><p>其他调试工具: electron-inspector(node库), VSCode(IDE).</p></li></ul><p> </p><h2 id="桌面集成环境"><a href="#桌面集成环境" class="headerlink" title="桌面集成环境"></a>桌面集成环境</h2><ul><li>桌面通知 (HTML5)  for linux, mac, windows</li><li>最近打开的文档 for mac, windows</li><li>自定义Dock菜单 for mac</li><li>用户任务 for windows</li><li>工具栏预览 for windows </li><li>Unity launcher 快捷方式 for linux</li><li>工具栏进度条 for windows, mac, unity</li><li>图表布局 for windows</li><li>flash框架 for windows</li><li>窗口右键菜单 for mac</li><li>拖动文件事件</li><li>在线&#x2F;离线 事件检测</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑客与画家</title>
      <link href="/2016/12/03/hacker-and-painter/"/>
      <url>/2016/12/03/hacker-and-painter/</url>
      
        <content type="html"><![CDATA[<p>这是一个比较吸引自己的书, 甚至还因此理解了喜欢看星座的人的感受. 摘抄一部分作为介绍和回顾.</p><span id="more"></span><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><blockquote><p>黑客的行为包括三个特点: 好玩, 高智商, 探索精神. 并不是实用性和金钱.</p></blockquote><p>我给特点排序: 探索精神, 好玩, 高智商. 如果修改一批文件名, 可能一部分人会去花10分钟一个一个改, 黑客可能会花30分钟写一个脚本. 然后下次改文件名的时候 — 第一部分人会再花10分钟, 黑客花5分钟找脚本失败, 然后又花30分钟写了一个.</p><h3 id="为什么书呆子不受欢迎"><a href="#为什么书呆子不受欢迎" class="headerlink" title="为什么书呆子不受欢迎"></a>为什么书呆子不受欢迎</h3><blockquote><p>智商高的人&#x2F;书呆子并不是不想受欢迎, 而是他们更喜欢花精力去做重要的事, 就像顶着一杯水踢足球, 别的一心在踢足球的人觉得他们非常弱.</p></blockquote><p>(关于欺负)</p><blockquote><p>在一个人产生良知之前, 折磨就是一种娱乐.</p><p>没有自信的人会虐待他们眼中的下等人来突显自己的身份.美国社会中低层派人是对待黑人最残酷的群体.</p></blockquote><blockquote><p>一个政客, 他想让选民忘记糟糕的国内局势, 方法就是为国家找出一个敌人, 哪怕敌人并不真的存在, 他也可以创造一个出来.</p></blockquote><p>一个事件的发生确实可能因为掩盖另外一个事件. 有时候我们需要注意找到事情的真相, 有时候我们需要主动制造事情掩盖不好的事情&#x2F;心情.</p><p>顺带吐槽一下觉得自己爱国反日的人. 反抗日本教科书修改历史, 难道你们不知道中国的墙是用来干什么的么, 倒底谁才无知得更多.</p><blockquote><p>学校只不过是关住牲口的围栏. 表面上学校的使命是教育儿童. 事实上, 学校的真正目的是把儿童都关在同一个地方, 以便大人们白天可以腾出手来把事情做完. </p></blockquote><p>文章也说到老师和狱警没区别. 保证犯人&#x2F;学生不产生大冲突, 对小团体, 欺负等时而不闻.</p><blockquote><p>学校就是个扭曲的世界, 成年人肯定不可避免地看到孩子受的苦. 但为什么他们什么都不做, 他们觉得是青春期在作祟. 他们觉得社会系统一点问题也没有, 孩子都了这个年纪不可避免地会感觉很糟糕.</p></blockquote><p>文中举了些例子, 描述了老师学生都是混日子, 即使真的想学的学生和真的很好的老师也无法改变现状.</p><blockquote><p>真实世界的领导往往是最善于实现共同目标的人担当. 而学校里根本就没有共同目标. 所以孩子们的等级也是凭空创造出来的.</p></blockquote><p>总的来说, 因为时代的发展, 青少年对成年人来说没有了经济意义反而成了负担, 成年人就构造了一个半无菌室半原始野蛮的世界给孩子, 并把产生的痛苦归为青春期来骗自己. 孩子生活的空虚和无聊甚至会影响以后的人生.</p><h3 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h3><blockquote><p>简单的考核不怎么准确, 比如我们用代码的行数考核程序员工作效率. 这样考核最容易所以总是首先被采用.</p></blockquote><blockquote><p>唯一有效的外部考核就是时间, 经过岁月的洗礼, 优美的东西生存发展机会更大, 丑陋的东西往往会被淘汰. 不幸的是这种考核时间可能比一个人的生命更长.</p></blockquote><blockquote><p>我现在认为, 大学里学的编程方法是错的, 绘画和建筑都有一个方法是打草稿. 你把程序想清楚的时间点应该是编码的同时, 而不是编码之前. </p></blockquote><blockquote><p>赚钱和好玩不重叠. 好玩的软件需求量比不上解决客户麻烦的需求量. 在小剧场里演出的酬劳比不上穿着卡通大猩猩服装在展览会上为厂商站台的酬劳. 写小说的回报比不上写广告文案的回报. 开发编程语言的收入, 比不上把某些公司老掉牙的数据库脸上服务器的收入.</p></blockquote><blockquote><p>有时候有个令人兴奋的项目你愿意为他一天工作16小时. 等过了这阵你又会觉得百无聊赖, 对所有事情都提不起兴趣. </p></blockquote><p>要了解自己的心里周期. 在有热情的时候做复杂的事没热情的时候做简单琐碎的事. 比如解决bug就是简单的事, 有热情的时候把别的先做了.</p><blockquote><p>要为别人设身处地想. 不代表你需要做其他人的事情. 而是从他人角度思考问题. “换位思考”不是自我牺牲的意思, 比如打仗的时候, 了解对手的目的是打败对手.</p></blockquote><p>这章摘出来的不多, 但是原文说的各个方面都很赞同.</p><h3 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h3><blockquote><p>翻看以前的东西会觉得很难为情, 觉得以前的东西一点都不时尚. 道德观念也如此.</p><p>我们的时代和历史上地心说的时代没有区别, 即使我们现在的信念都是正确的, 那也只是非常巧合, 而不是因为我们真找到了方向.</p></blockquote><p>没有可信的东西, 所有我们相信的东西都只是与自己的经验做对比. 从我们的角度来看, 去接受的东西越多, 自己的价值观越可以预判下次的输入的结果(只是预判并不是真理). 这样好比机器学习. 真理可能只是一种假想出来的东西.</p><blockquote><p>你说的每个观点都毫不犹豫, 自己深深赞同, 并且也确信会得到别人的赞同, 这是否太过于巧合了? 一种可能是: 事情并不巧合, 因为你的观点就是从别人那来的, 别人告诉你什么你就相信了什么, 你把别人灌输的观点当做了自己的观点.</p></blockquote><blockquote><p>真话&#x2F;接近事实的&#x2F;会引起思考的话是不能讲的, 如果你说2+2&#x3D;5, 不会激怒任何人.</p></blockquote><blockquote><p>家长不给孩子讲脏话, 孩子以为脏话是不该讲的, 所以在外面讲, 家里不讲, 家长也如此. 就形成了奇怪的演戏.</p></blockquote><blockquote><p>禁忌的制造者是权力斗争中略占上风的一方. 如果强得很多就不需要禁忌, 只是略占上风所以需要禁忌保护自己的利益.</p></blockquote><blockquote><p>智力越高的人越愿意去思考那些惊世骇俗的思想观点. 这不仅仅是因为聪明人本身很积极地去寻找传统观念的漏洞, 还因为传统观念对他们的束缚力很小, 很容易摆脱. 从他们的衣着上你就可以看出这一点: 不受传统观念舒服的人, 往往也不会穿流行的衣服.</p></blockquote><p>这个完全是想笑www, 吐槽程序员衣着么.</p><blockquote><p>自由思考比畅所欲言更重要. 如果你一定要跟某个人辩个明白, 咽不下这口气, 结果可能是从此你再也无法自由理性地思考了. 更好的方法是在思想和言论之间划一条明确的界面. </p></blockquote><blockquote><p>守口如瓶的真正缺点在于, 你从此无法享受讨论带来的好处了. (守口如瓶是指上条说是不多说话)</p></blockquote><p>这章的感觉从看了第一句话开始, 突然怀疑自己的脑子, 用文中的话就是拉开了距离看自己.</p><p>记得以前听过某总统(因为忘记了而已)说人类最大的成就是把统治者关在笼子里, 我们也一样, 人类了不起的地方是自己会用理智思考自己, “拉开距离看自己”.</p><h3 id="如何创造财富"><a href="#如何创造财富" class="headerlink" title="如何创造财富"></a>如何创造财富</h3><blockquote><p>如果你又一两老爷车, 你将他修葺一新. 那么老爷车的价值一定是高了, 他可以卖出更多的钱. 但世界任何地方的财富不会减少. 这就推翻了财富是个固定的大饼的言论.</p></blockquote><blockquote><p>如果你有一个令你感到安全的工作, 你是不会致富的, 因为没有危险, 就几乎等于没有可放大性.</p></blockquote><blockquote><p>不要过早优化, 客户是检验问题的最好手段.</p></blockquote><p>这章说了财富的概念和工作的性质, 工作绩效的可测量性. </p><h3 id="关注贫富分化"><a href="#关注贫富分化" class="headerlink" title="关注贫富分化"></a>关注贫富分化</h3><blockquote><p>如果你觉得由于人们的需求不正确, 导致某些工作的报酬过低而且不公平, 那么这个世界一定会让你感到非常遗憾, 人们就是喜欢看电视真人秀, 而不是莎士比亚作品, 人们就是喜欢吃玉米热狗, 而不是水煮蔬菜. </p><p>如果你觉得以上不公平, 那么你就是’老爹模式’ — 觉得努力和收获是正比的, 而不是根据现实来的(老爹模式指觉得钱都是爸妈分配的)</p></blockquote><blockquote><p>为了破除老爹模式思想, 让我们假设有一个工人, 让它单独一个人在荒岛上打猎和采集水果. 如果他的能力不足, 就算非常勤奋的工作, 最后也不会得到很多事物. 这是不公平吗? 又是谁对它不公平呢?</p></blockquote><blockquote><p>因为历史上富人都是以偷窃为致富方式(贵族-农奴, 农奴制造财富-贵族偷取; 征税for和平时期; 战争for战争时期). 所以使得今天的靠自己制造财富的人(比尔盖茨, 乔布斯, 他们是产生财富而富裕的) 也让别人抱有怀疑态度. </p></blockquote><blockquote><p>巴尔扎克: “每一笔巨大财富的背后, 都隐藏着罪行. “. 这句话的意思是财富没有明显的来源, 那可能就来源于精心安排的犯罪活动, 由于掩盖得太好, 使得罪行被人遗忘了. </p></blockquote><blockquote><p>技术的发展使贫富差距缩小, 富人有的东西穷人也有, 而品牌是贫富差距的遗留物.</p></blockquote><blockquote><p>技术的发展加大了收入差距的同时, 缩小了大部分的其他差距.</p></blockquote><p>总体来说观点是贫富差距大可能代表社会健康(100%的人工作的社会一定不是发达国家). 还有保住每个人自己创造的财富的话(减少偷窃) 社会会发展很快. (国富论?)</p><h3 id="设计者的品味"><a href="#设计者的品味" class="headerlink" title="设计者的品味"></a>设计者的品味</h3><blockquote><p>我们大多数人从孩提时代起就被鼓励不要去分析清楚自己的头脑.(例子太长了)</p></blockquote><blockquote><p>好设计是简单的设计.</p></blockquote><blockquote><p>好设计是看似容易的设计. 作家的文章读起来流畅自如, 但背后其实经过了反复修改. </p></blockquote><blockquote><p>科学和工程学的一些重大发现在形式上往往很简单, 会使得你觉得自己也想到过. 可是, 如果他真的那么简单, 为什么发现人不是你呢?</p></blockquote><blockquote><p>练习的作用也许是训练你把刻意为之的事情变为一种自觉的行为. </p></blockquote><p>这章看起来像是设计教学与历史. </p><h3 id="一百年后的编程语言"><a href="#一百年后的编程语言" class="headerlink" title="一百年后的编程语言"></a>一百年后的编程语言</h3><blockquote><p>语言就像生物物种进化一样. 有些会进化到头.</p><p>我想知道一百年后的编程语言的原因是, 我们现在可能正在使用他, 我不愿押错堵住.</p></blockquote><p>(什么时候站对队伍还是很重要的)</p><blockquote><p>因为技术的发展, 不仅语言是这样, 每代人都在做上代人觉得浪费的事情. 30年前的人要是看到我们今天如此随意地使用长途电话, 一定会感到震惊. </p><p>我已经预测到一百年后硬件发展高速的结果, 就是更多的东西遭到浪费.</p></blockquote><blockquote><p>好的浪费即是用更多的钱得到更简单的设计.</p></blockquote><blockquote><p>效率低下的软件并不等于很烂的软件.一种让程序员做无用功的软件才真正称得上很烂. 浪费程序员的时间而不是浪费机器的时间才是真正的无效率. 随着计算机速度越来越快, 这会变得越来越明显.</p></blockquote><p>这个论点非常有意思, 现在的观点是, 注重细节, 注重优化, 并且这是高级程序员的进化条件. 所以老程序员做的事情以后都是白搭? 看来可能是这样的, 程序员真是个非常令人不安的职业.</p><p>题为一百年后, 实际是对语言的发展做了描述, 现在的我们其实已经充分感受到语言发展的迅速了(js?).</p><h3 id="书呆子的复仇"><a href="#书呆子的复仇" class="headerlink" title="书呆子的复仇"></a>书呆子的复仇</h3><p>这章应该是产品经理看的, 我看了一些就快翻了.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这本书是这样的, 每章都是完全不同不依赖的内容. 但是每章都非常有趣, 有的能摘抄一下, 有的看一遍没有能摘抄些什么(可能是太精彩停不下来, 可能是需要自己总结).</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stage-3 rest函数和解构赋值</title>
      <link href="/2016/12/02/stage-3-rest-spread-transform/"/>
      <url>/2016/12/02/stage-3-rest-spread-transform/</url>
      
        <content type="html"><![CDATA[<p>已经使用了一段时间es的新标准, 很明显感受到编码的感觉与之前不同了. 一开始以为没什么用的rest和解构倒反而使用得较多. 所以来看一下他们的便利的例子.</p><span id="more"></span><h2 id="语法描述"><a href="#语法描述" class="headerlink" title="语法描述"></a>语法描述</h2><h3 id="解构赋值-x2F-rest参数"><a href="#解构赋值-x2F-rest参数" class="headerlink" title="解构赋值&#x2F;rest参数"></a>解构赋值&#x2F;rest参数</h3><p>所以解构赋值就是按照格式取值, 如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果格式没对上取到的是<code>undefined</code>, 或者外层数据类型就不同则报TypeError.</p><p>rest参数的语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getParam = <span class="keyword">function</span>(<span class="params">head, second, ...tails</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(head, second, tails);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getParam</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// =&gt; 1 2 [3]</span></span><br><span class="line"><span class="title function_">getParam</span>();<span class="comment">// =&gt; undefined undefined []</span></span><br></pre></td></tr></table></figure><p>我把这2个一起讲的原因是因为他们差不多, 根据结构取值. 把取到的东西放在数组里. 并且没取到的情况不是<code>undefined</code>而是一个空数组.</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数在给对象属性默认值的时候有时候令人迷糊, 但是仔细考虑原则:</p><blockquote><p><strong>默认值生效的条件是, 对象的属性值严格等于<code>undefined</code></strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>这个行为的原因是, 只有当参数不传时才会全等于<code>undefined</code>. 所以我个人认为<strong>这种写法是不推荐的</strong>, 应该换成下面这种:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="解构取值"><a href="#解构取值" class="headerlink" title="解构取值"></a>解构取值</h3><p>这个做法很基本, 但是实际使用中用得非常多. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params">&#123;state, commit&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">commit</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="string">&quot;state&quot;</span>,</span><br><span class="line">  <span class="attr">commit</span>: <span class="keyword">function</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="comment">//actions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的写法等同于: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params">param</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;state, commit&#125; = param;</span><br><span class="line">  <span class="title function_">commit</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果调用<code>fn()</code>会报匹配失败, 调用<code>fn(&#123;&#125;)</code> 在<code>commit(state)</code>处会报错. 所以我们可以给这个取值也加上默认值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params">&#123;state = <span class="string">&quot;state was missiong&quot;</span>, commit = <span class="keyword">function</span>()&#123;</span></span><br><span class="line"><span class="params">  <span class="variable language_">console</span>.log(<span class="string">&quot;i can not commit anything&quot;</span>)</span></span><br><span class="line"><span class="params">&#125;&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">commit</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是完美的, 但是如果某个参数是必须的请不要这样做啦. </p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>这是一个百度到的柯里化的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>,</span><br><span class="line">            __args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> __inargs = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">                <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, __args.<span class="title function_">concat</span>(__inargs));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用了rest参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currying = <span class="keyword">function</span>(<span class="params">fn, ...tails</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...tails, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处真的不用说了, 好写, 好看, 好理解, 无敌.</p><p>另外提一点, rest参数是可以取字符串的, 但是会把字符串取成数组, 如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="title function_">separateString</span>(<span class="params">head, ...tails</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(head, tails);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"><span class="comment">// =&gt; 1 [2,3,4]</span></span><br></pre></td></tr></table></figure><p>然后把他们join回去就可以了.</p><h3 id="stage-3的rest取值"><a href="#stage-3的rest取值" class="headerlink" title="stage-3的rest取值"></a>stage-3的rest取值</h3><p>我们取到一个对象以后可能要为他增加键值, 可能会这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">newKey</span> = <span class="string">&quot;newValue&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样修改了元数据, 是函数式编程的大忌. 所以我们只能写一个数据副本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = _.<span class="title function_">clonedeep</span>(obj);</span><br><span class="line">newObj.<span class="property">newKey</span> = <span class="string">&quot;newValue&quot;</span>;</span><br></pre></td></tr></table></figure><p>看一下新语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  <span class="attr">newKey</span>: <span class="string">&quot;newValue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿嘿.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程介绍</title>
      <link href="/2016/11/21/an-introduction-to-functional-programming/"/>
      <url>/2016/11/21/an-introduction-to-functional-programming/</url>
      
        <content type="html"><![CDATA[<p>许多函数式编程(以下简称fp for functional programming)文章都说一些抽象的fp技巧. 比如构造(composition), 管道操作(pipelining), 高阶函数(higher order functions). 本文不同. 这里会告诉大家一些平时大家平时每天都要写的命令式的, 非函数式的代码应该如何转换为fp风格的例子.</p><p>第一部分将会是把一些遍历处理数据的代码转为<code>map</code>和<code>reduce</code>. 第二部分把比较长的循环打成小块, 并使每个部分函数化. 第三部分会处理一个更大的数据结构并把他写成管道的形式.</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>当人们说到fp, 就会去联系到一些特性. 会提到<strong>不可编辑的数据(immutable data)</strong>, <strong>第一类公民(first-class function)</strong>, <strong>尾递归(tail call optimisation)</strong>. 这些是fp的语言特征. 会提到<strong>map</strong>, <strong>reduce</strong>, <strong>管道(pipeling)</strong>, <strong>递归(recursing)</strong>, <strong>柯里化(currying)</strong> 和使用<strong>高阶函数(higher order functions)</strong>. 以上这些是编写fp的技巧. 然后提到了<strong>并行(parallelization)</strong>, <strong>懒求值(lazy evaluation)</strong> 和 <strong>决定性(determinism)</strong>. 这些是fp的优点.</p><p>除了这些. fp还有一个特点: 没有<strong>附带作用(side effects)</strong>. fp不依赖方法所在的环境, 也不会改变函数外的变量. 任何变量都可以在函数内获得到. 把以上的东西作为你学习fp的引导思路.</p><p>这是一个非函数式的函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment1</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这是一个函数式函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="不要对列表遍历-使用map和reduce"><a href="#不要对列表遍历-使用map和reduce" class="headerlink" title="不要对列表遍历. 使用map和reduce"></a>不要对列表遍历. 使用map和reduce</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>map接受一个函数和一个集合. 然后创建一个新空集合, 在每个集合的元素上运行函数来插入空集合. 最后返回新的集合.</p><p>下面是个简单的获取名字长度的map:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name_lengths = <span class="built_in">map</span>(<span class="built_in">len</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Isla&quot;</span>, <span class="string">&quot;Sam&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> name_lengths</span><br><span class="line"><span class="comment"># =&gt; [4, 4, 3]</span></span><br></pre></td></tr></table></figure><p>下面是个返回元素平方的map:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> squares</span><br><span class="line"><span class="comment"># =&gt; [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p>上面的map没有接受一个有名字的函数, 而是一个行内的, 匿名的用lambda定义的函数. lambda函数定义在分号前, 函数体在分号后. 函数体也是lambda函数的返回值.</p><p>下面的非fp的代码: 接受真名列表和代名列表, 并随机给真名赋值为代名.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Isla&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>]</span><br><span class="line">code_names = [<span class="string">&#x27;Mr. Pink&#x27;</span>, <span class="string">&#x27;Mr. Orange&#x27;</span>, <span class="string">&#x27;Mr. Blonde&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line">    names[i] = random.choice(code_names)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"><span class="comment"># =&gt; [&#x27;Mr. Blonde&#x27;, &#x27;Mr. Blonde&#x27;, &#x27;Mr. Blonde&#x27;]</span></span><br></pre></td></tr></table></figure><p>(如你所看到的, 这个算法可以给保密机关的人员分配保密代号. 希望他们不要在执行任务的时候搞错代号.)</p><p>上面的代码也可以写成map:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Isla&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>]</span><br><span class="line"></span><br><span class="line">secret_names = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: random.choice([<span class="string">&#x27;Mr. Pink&#x27;</span>,</span><br><span class="line">                                            <span class="string">&#x27;Mr. Orange&#x27;</span>,</span><br><span class="line">                                            <span class="string">&#x27;Mr. Blonde&#x27;</span>]),</span><br><span class="line">                   names)</span><br></pre></td></tr></table></figure><p><strong>练习1.</strong> 尝试用map重写以下代码: 这次用更可靠的策略来给特工代号.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Isla&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line">    names[i] = <span class="built_in">hash</span>(names[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"><span class="comment"># =&gt; [6306819796133686941, 8135353348168144921, -1228887169324443034]</span></span><br></pre></td></tr></table></figure><p>(希望特工都记性不错, 不要在秘密任务中忘记别的同事的代号.)</p><p>答案:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Isla&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>]</span><br><span class="line"></span><br><span class="line">secret_names = <span class="built_in">map</span>(<span class="built_in">hash</span>, names)</span><br></pre></td></tr></table></figure><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>reduce接受一个函数和一个集合. 他返回的值是混合了输入的值.</p><p>下面是一个reduce. 他会返回输入集合的和. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = reduce(<span class="keyword">lambda</span> a, x: a + x, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">sum</span></span><br><span class="line"><span class="comment"># =&gt; 10</span></span><br></pre></td></tr></table></figure><p><code>x</code>是当前被遍历到的元素, <code>a</code>是暂存值. 他的值是上次循环lambda函数的返回值. <code>reduce()</code>循环每个元素. 每次都用当前的<code>a</code>和<code>x</code>执行lambda表达式, 把结果赋给下次的<code>a</code>.</p><p>那第一次循环<code>a</code>是什么? 第一次没有上一次. <code>reduce()</code>集合的第一个元素作为<code>a</code>的第一次值, 并从集合的第二个元素开始遍历. 也就是说, 第一个<code>x</code>是集合的第二个元素.</p><p>下面的代码计算’Sam’出现的次数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sentences = [<span class="string">&#x27;Mary read a story to Sam and Isla.&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;Isla cuddled Sam.&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;Sam chortled.&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sam_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> sentences:</span><br><span class="line">    sam_count += sentence.count(<span class="string">&#x27;Sam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> sam_count</span><br><span class="line"><span class="comment"># =&gt; 3</span></span><br></pre></td></tr></table></figure><p>reduce版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sentences = [<span class="string">&#x27;Mary read a story to Sam and Isla.&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;Isla cuddled Sam.&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;Sam chortled.&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sam_count = reduce(<span class="keyword">lambda</span> a, x: a + x.count(<span class="string">&#x27;Sam&#x27;</span>),</span><br><span class="line">                   sentences,</span><br><span class="line">                   <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>那么怎么解决希望reduce从第一个元素开始? 按照之前的执行, 第一个元素的’Mary read a story to Sam and Isla’中的’Sam’就不会被记入结果了, 我们要在第三个参数传入<code>a</code>的初始值, 这样reduce就会从第一个元素开始了.</p><h4 id="为什么map和reduce更好"><a href="#为什么map和reduce更好" class="headerlink" title="为什么map和reduce更好?"></a>为什么map和reduce更好?</h4><p>首先, 他们简化了代码.</p><p>第二, 遍历的最重要的部分  — 集合, 他们的操作与返回值不会改变集合的位置.</p><p>第三, 循环的代码会影响别的代码, 当然map和reduce是函数式的, 所以不会影响.</p><p>第四, map和reduce是元素性的操作. 每次我们操作一个循环, 都需要写几行循环逻辑的代码. 相对的, map和reduce把这些逻辑放进了算法, 代码的可读性也更高. ‘啊, 这个代码是这样这样改变了集合的每个值’.</p><p>第五, map和reduce还有一些类似的很实用的封装. 比如: <code>filter</code>, <code>all</code>, <code>any</code>, 和<code>find</code>.</p><p><strong>练习2.</strong> 实用map, reduce和filter重写以下代码. filter接受一个函数和一个集合, 返回所有经过函数返回<code>true</code>的元素的集合.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">people = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">160</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Isla&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">80</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Sam&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line">height_total = <span class="number">0</span></span><br><span class="line">height_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;height&#x27;</span> <span class="keyword">in</span> person:</span><br><span class="line">        height_total += person[<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">        height_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> height_count &gt; <span class="number">0</span>:</span><br><span class="line">    average_height = height_total / height_count</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> average_height</span><br><span class="line">    <span class="comment"># =&gt; 120</span></span><br></pre></td></tr></table></figure><p>如果看起来不好搞, 试试不要考虑数据操作. 思考下数据经过的状态, 从信息列表到平均身高. 不要尝试混合多个操作. 先做一部分, 代码成功了再混合他们.</p><p>答案:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">people = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">160</span>&#125;,</span><br><span class="line">          &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Isla&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">80</span>&#125;,</span><br><span class="line">          &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Sam&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line">heights = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;height&#x27;</span>],</span><br><span class="line">              <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="string">&#x27;height&#x27;</span> <span class="keyword">in</span> x, people))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(heights) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line">    average_height = reduce(add, heights) / <span class="built_in">len</span>(heights)</span><br></pre></td></tr></table></figure><h2 id="代码要声明式的-而不是命令式的"><a href="#代码要声明式的-而不是命令式的" class="headerlink" title="代码要声明式的, 而不是命令式的"></a>代码要声明式的, 而不是命令式的</h2><p>下面的程序是三台车的比赛. 每个阶段, 每台车都有概率前进, 有概率暂停. 每一步程序都把三台车的进度打出来. 五步以后比赛结束.</p><p>下面是样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line"></span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line">- -</span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">- - - -</span><br><span class="line">- - -</span><br><span class="line">- - - -</span><br><span class="line"></span><br><span class="line">- - - -</span><br><span class="line">- - - -</span><br><span class="line">- - - - -</span><br></pre></td></tr></table></figure><p>这是代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">time = <span class="number">5</span></span><br><span class="line">car_positions = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> time:</span><br><span class="line">    <span class="comment"># decrease time</span></span><br><span class="line">    time -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(car_positions)):</span><br><span class="line">        <span class="comment"># move car</span></span><br><span class="line">        <span class="keyword">if</span> random() &gt; <span class="number">0.3</span>:</span><br><span class="line">            car_positions[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># draw car</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * car_positions[i]</span><br></pre></td></tr></table></figure><p>这段代码是用命令式写的. 函数式版本应该是声明式的. 会声明要做什么, 而不是如何做他.</p><h2 id="使用函数式"><a href="#使用函数式" class="headerlink" title="使用函数式"></a>使用函数式</h2><p>程序可以通过拆分方法变得更声明化.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_cars</span>():</span><br><span class="line">    <span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(car_positions):</span><br><span class="line">        <span class="keyword">if</span> random() &gt; <span class="number">0.3</span>:</span><br><span class="line">            car_positions[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_car</span>(<span class="params">car_position</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * car_position</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_step_of_race</span>():</span><br><span class="line">    <span class="keyword">global</span> time</span><br><span class="line">    time -= <span class="number">1</span></span><br><span class="line">    move_cars()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> car_position <span class="keyword">in</span> car_positions:</span><br><span class="line">        draw_car(car_position)</span><br><span class="line"></span><br><span class="line">time = <span class="number">5</span></span><br><span class="line">car_positions = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> time:</span><br><span class="line">    run_step_of_race()</span><br><span class="line">    draw()</span><br></pre></td></tr></table></figure><p>想要理解程序, 读者只需要看一下主循环. ‘如果还有次数剩余, 运行比赛的一个阶段并打印, 然后继续检查剩余次数.’ 如果读者想进一步了解是怎么比赛, 怎么画的, 他们可以去对应的函数查看.</p><p>这点代码一点都没有注释, 代码是自解释的.</p><p>把代码拆分成方法很great, 不太耗脑力又把代码可读性提高. 这种技术使用了函数, 但只是把函数作为子程序使用, 包裹了代码. 从之前的引言来看, 这些代码并不是fp. 上面的代码使用的状态没有通过参数传导. 代码通过改变外部变量来实现. 为了知道方法真正做了什么需要去看外部变量. 如果变量不在, 还要去找变量哪里来的. 还要去查看哪些函数改变了这个变量…</p><h2 id="移除状态"><a href="#移除状态" class="headerlink" title="移除状态"></a>移除状态</h2><p>下面才是fp版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_cars</span>(<span class="params">car_positions</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span> <span class="keyword">if</span> random() &gt; <span class="number">0.3</span> <span class="keyword">else</span> x,</span><br><span class="line">               car_positions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">output_car</span>(<span class="params">car_position</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span> * car_position</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_step_of_race</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;time&#x27;</span>: state[<span class="string">&#x27;time&#x27;</span>] - <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;car_positions&#x27;</span>: move_cars(state[<span class="string">&#x27;car_positions&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(<span class="built_in">map</span>(output_car, state[<span class="string">&#x27;car_positions&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">race</span>(<span class="params">state</span>):</span><br><span class="line">    draw(state)</span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&#x27;time&#x27;</span>]:</span><br><span class="line">        race(run_step_of_race(state))</span><br><span class="line"></span><br><span class="line">race(&#123;<span class="string">&#x27;time&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="string">&#x27;car_positions&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&#125;)</span><br></pre></td></tr></table></figure><p>这些代码依然被分隔成了方法, 但这些方法是函数式的. 有三个特点. 第一, 没有共享的变量了. <code>time</code>和<code>car_positions</code>被直接传入<code>race()</code>.第二, 函数接受了参数. 第三, 没有变量在方法内部被初始化. 所有数据处理完都被作为返回值了. <code>race()</code>递归调用了<code>run_step_of_race()</code>的返回值. 每次运行产生的新状态都会被传入下次的调用中.</p><p>现在有2个函数, <code>zero()</code>和<code>one()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p><code>zero()</code>接受一个字符串, <code>s</code>. 如果第一个字符是<code>&#39;0&#39;</code>, 就返回剩余的, 如果不是就返回<code>None</code>, python函数的默认返回值.</p><p><code>one()</code>方法一样, 但检测的是<code>&#39;1&#39;</code>.</p><p>假设一个函数叫做<code>rule_sequence()</code>. 他接受的参数是一个字符串和一系列规则函数类似<code>zero()</code>和<code>one()</code>. 他在字符串上调用第一个规则, 除非返回值是<code>None</code>, 他会继续把返回值调用第二个规则. 除非返回值是<code>None</code>, 他会把返回值作调用第三个规则, 然后第四个… 除非返回了<code>None</code>, <code>rule_sequence()</code>就停止并返回<code>None</code>. 否则, 就返回最后的结果.</p><p>以下是一些输入输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> rule_sequence(<span class="string">&#x27;0101&#x27;</span>, [zero, one, zero])</span><br><span class="line"><span class="comment"># =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> rule_sequence(<span class="string">&#x27;0101&#x27;</span>, [zero, zero])</span><br><span class="line"><span class="comment"># =&gt; None</span></span><br></pre></td></tr></table></figure><p>下面是<code>rule_sequence()</code>的命令式实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rule_sequence</span>(<span class="params">s, rules</span>):</span><br><span class="line">    <span class="keyword">for</span> rule <span class="keyword">in</span> rules:</span><br><span class="line">        s = rule(s)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><strong>练习3.</strong> 上面是循环的实现方式, 用递归来实现:</p><p>答案:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rule_sequence</span>(<span class="params">s, rules</span>):</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> rules:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rule_sequence(rules[<span class="number">0</span>](s), rules[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h2 id="使用管道操作"><a href="#使用管道操作" class="headerlink" title="使用管道操作"></a>使用管道操作</h2><p>在上个章节, 一些命令式的循环被重写为了递归函数. 在这个部分, 另外一个类型的命令式循环会被用一种管道操作的技术重写.</p><p>下面的循环作用是: 纠正错误的国家, 纠正错误的拼写及格式.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bands = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;sunset rubdown&#x27;</span>, <span class="string">&#x27;country&#x27;</span>: <span class="string">&#x27;UK&#x27;</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">False</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;women&#x27;</span>, <span class="string">&#x27;country&#x27;</span>: <span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">False</span>&#125;,</span><br><span class="line">         &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a silver mt. zion&#x27;</span>, <span class="string">&#x27;country&#x27;</span>: <span class="string">&#x27;Spain&#x27;</span>, <span class="string">&#x27;active&#x27;</span>: <span class="literal">True</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_bands</span>(<span class="params">bands</span>):</span><br><span class="line">    <span class="keyword">for</span> band <span class="keyword">in</span> bands:</span><br><span class="line">        band[<span class="string">&#x27;country&#x27;</span>] = <span class="string">&#x27;Canada&#x27;</span></span><br><span class="line">        band[<span class="string">&#x27;name&#x27;</span>] = band[<span class="string">&#x27;name&#x27;</span>].replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        band[<span class="string">&#x27;name&#x27;</span>] = band[<span class="string">&#x27;name&#x27;</span>].title()</span><br><span class="line"></span><br><span class="line">format_bands(bands)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> bands</span><br><span class="line"><span class="comment"># =&gt; [&#123;&#x27;name&#x27;: &#x27;Sunset Rubdown&#x27;, &#x27;active&#x27;: False, &#x27;country&#x27;: &#x27;Canada&#x27;&#125;,</span></span><br><span class="line"><span class="comment">#     &#123;&#x27;name&#x27;: &#x27;Women&#x27;, &#x27;active&#x27;: False, &#x27;country&#x27;: &#x27;Canada&#x27; &#125;,</span></span><br><span class="line"><span class="comment">#     &#123;&#x27;name&#x27;: &#x27;A Silver Mt Zion&#x27;, &#x27;active&#x27;: True, &#x27;country&#x27;: &#x27;Canada&#x27;&#125;]</span></span><br></pre></td></tr></table></figure><p>问题从函数名字开始, ‘format’太含糊了. 想要仔细查看代码, 这个问题会很严重. 在这个函数里做了3件事: 把<code>country</code>字段的值改为<code>Canada</code>. 把<code>.</code>移除出了band name. 把band name 首字母大写. 这样的函数名很难让人知道他做的什么事, 很难重用, 很难测试, 很难并用.</p><p>与下面这个对比下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> pipeline_each(bands, [set_canada_as_country,</span><br><span class="line">                            strip_punctuation_from_name,</span><br><span class="line">                            capitalize_names])</span><br></pre></td></tr></table></figure><p>这样的代码很容易看懂. 一下就让人感觉这样的辅助函数是函数式的, 因为他们看起来链在一起. 上一个的输出和下一个的输入是连在一起的. 如果函数是函数式的, 就很容易被验证. 也很容易被重用, 测试, 和并用.</p><p><code>pipeline_each()</code>是使用传入的类似<code>set_canada_as_country()</code>的辅助函数(每次一个)来改变bands. 当辅助函数被应用到了所有bands上, <code>pileline_each()</code>把结果传到下一个函数中. </p><p>我们来看看这些辅助函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">assoc</span>(<span class="params">_d, key, value</span>):</span><br><span class="line">    <span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">    d = deepcopy(_d)</span><br><span class="line">    d[key] = value</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_canada_as_country</span>(<span class="params">band</span>):</span><br><span class="line">    <span class="keyword">return</span> assoc(band, <span class="string">&#x27;country&#x27;</span>, <span class="string">&quot;Canada&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strip_punctuation_from_name</span>(<span class="params">band</span>):</span><br><span class="line">    <span class="keyword">return</span> assoc(band, <span class="string">&#x27;name&#x27;</span>, band[<span class="string">&#x27;name&#x27;</span>].replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">capitalize_names</span>(<span class="params">band</span>):</span><br><span class="line">    <span class="keyword">return</span> assoc(band, <span class="string">&#x27;name&#x27;</span>, band[<span class="string">&#x27;name&#x27;</span>].title())</span><br></pre></td></tr></table></figure><p>每个都关联了band上的一个键并给了新值. 没有简单的办法可以不改变原来band的值, 所以<code>assoc()</code>使用了<code>deepcopy()</code>来解决问题. 每个辅助函数改变了一份副本并返回这份副本.</p><p>看起来一切正常. band的原始值也没有被修改. 但有2处潜在的修改问题. 在<code>strip_punctuation_from_name()</code>里, 没有带<code>.</code>的名字因为在原始值上调用了<code>replace()</code>而生成, 大写化的名字也因为调用了<code>capitalize_names()</code>而生成. 如果<code>replace()</code>和<code>title()</code>是非函数式的, 那么<code>strip_punctuation_from_name()</code>和<code>capitalize_names()</code>也不是函数式的了.</p><p>幸运的是, <code>replace()</code>和<code>title()</code>不会修改他们操作的元素. 这是因为字符串在python中是不可修改的. 也就是说<code>replace()</code>操作元素的时候新建了一份副本并在副本上操作.</p><p>python是像Clojure一样的语言, 程序员不需要考虑他们是否改变数据, 这些语言永远不会.</p><p><strong>练习4.</strong> 试着写出<code>pipeline_each</code>方法. 思考一下操作的顺序. 输入的元素, 一次一个元素, 给第一个辅助函数操作. 然后传递给之后的辅助函数.</p><p>答案:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pipeline_each</span>(<span class="params">data, fns</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, x: <span class="built_in">map</span>(x, a),</span><br><span class="line">                  fns,</span><br><span class="line">                  data)</span><br></pre></td></tr></table></figure><p>三个辅助方法都有重复的代码. 我们可以用<code>call()</code>方法来抽象他.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_canada_as_country = call(<span class="keyword">lambda</span> x: <span class="string">&#x27;Canada&#x27;</span>, <span class="string">&#x27;country&#x27;</span>)</span><br><span class="line">strip_punctuation_from_name = call(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">capitalize_names = call(<span class="built_in">str</span>.title, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> pipeline_each(bands, [set_canada_as_country,</span><br><span class="line">                            strip_punctuation_from_name,</span><br><span class="line">                            capitalize_names])</span><br></pre></td></tr></table></figure><p>如果我们为了简洁而牺牲些可读性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> pipeline_each(bands, [call(<span class="keyword">lambda</span> x: <span class="string">&#x27;Canada&#x27;</span>, <span class="string">&#x27;country&#x27;</span>),</span><br><span class="line">                            call(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">                            call(<span class="built_in">str</span>.title, <span class="string">&#x27;name&#x27;</span>)])</span><br></pre></td></tr></table></figure><p><code>call()</code>的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">assoc</span>(<span class="params">_d, key, value</span>):</span><br><span class="line">    <span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">    d = deepcopy(_d)</span><br><span class="line">    d[key] = value</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">fn, key</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply_fn</span>(<span class="params">record</span>):</span><br><span class="line">        <span class="keyword">return</span> assoc(record, key, fn(record.get(key)))</span><br><span class="line">    <span class="keyword">return</span> apply_fn</span><br></pre></td></tr></table></figure><p><strong>这里发生了很多, 让我们一点点地看.</strong></p><p>第一. <code>call()</code>是个高阶函数. 高阶函数接受函数为参数或者返回一个函数. 或者像<code>call()</code>一样, 两者都有.</p><p>第二. <code>apply_fn()</code>看起来很像那3个辅助函数. 他接受record(就是band). 他找到<code>record[key]</code>并用<code>fn</code>调用它. 最后返回一份结果的副本.</p><p>第三. <code>call()</code>方法实际没有做任何工作. 调用以后是<code>apply_fn()</code>来工作的. 在<code>pipeline_each()</code>中, 一个<code>apply_fn()</code>的实例会讲<code>country</code>设置为<code>Canada</code>. 另一个实例会把名字首字母大写.</p><p>第四. 当<code>apply_fn()</code>运行了, <code>fn</code>和<code>key</code>不在作用域中. 他们都是<code>apply_fn()</code>的参数, 也不是本地变量. 但仍可以被获取到. 当函数被定义, 会把引用当做变量存在自己的作用域里: 无论在方法内还是方法外的变量. 当函数运行, 他的代码引用了变量, python查找在参数中的变量. 如果找不到, 会去找保存过的引用. 这就是为什么可以找到<code>fn</code>和<code>key</code>.</p><p>第五. 在<code>call()</code>方法中没有涉及到bands. 因为<code>call()</code>方法是用来生成管道操作的, 不关心操作的内容. fp从某个程度上来说是构造一个普遍的, 可复用的, 组件化的函数.</p><p>好. 闭包, 高阶函数, 和变量作用域都在上面的例子说好了. 让我们喝杯柠檬水吧.</p><hr><p>我们还有一个band需要处理的东西. 就是移除除了name和contry的所有字段. <code>extract_name_and_contry()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_name_and_country</span>(<span class="params">band</span>):</span><br><span class="line">    plucked_band = &#123;&#125;</span><br><span class="line">    plucked_band[<span class="string">&#x27;name&#x27;</span>] = band[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    plucked_band[<span class="string">&#x27;country&#x27;</span>] = band[<span class="string">&#x27;country&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> plucked_band</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> pipeline_each(bands, [call(<span class="keyword">lambda</span> x: <span class="string">&#x27;Canada&#x27;</span>, <span class="string">&#x27;country&#x27;</span>),</span><br><span class="line">                            call(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">                            call(<span class="built_in">str</span>.title, <span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">                            extract_name_and_country])</span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; [&#123;&#x27;name&#x27;: &#x27;Sunset Rubdown&#x27;, &#x27;country&#x27;: &#x27;Canada&#x27;&#125;,</span></span><br><span class="line"><span class="comment">#     &#123;&#x27;name&#x27;: &#x27;Women&#x27;, &#x27;country&#x27;: &#x27;Canada&#x27;&#125;,</span></span><br><span class="line"><span class="comment">#     &#123;&#x27;name&#x27;: &#x27;A Silver Mt Zion&#x27;, &#x27;country&#x27;: &#x27;Canada&#x27;&#125;]</span></span><br></pre></td></tr></table></figure><p><code>extract_name_and_country()</code>可以用<code>pluck()</code>写成一个普通的函数.</p><p><code>pluck()</code>的作用是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> pipeline_each(bands, [call(<span class="keyword">lambda</span> x: <span class="string">&#x27;Canada&#x27;</span>, <span class="string">&#x27;country&#x27;</span>),</span><br><span class="line">                            call(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">                            call(<span class="built_in">str</span>.title, <span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">                            pluck([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;country&#x27;</span>])])</span><br></pre></td></tr></table></figure><p><strong>练习5.</strong>  <code>pluck()</code> 接受一个键的数组, 然后把键从集合中去掉. 试着写一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pluck</span>(<span class="params">keys</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pluck_fn</span>(<span class="params">record</span>):</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, x: assoc(a, x, record[x]),</span><br><span class="line">                      keys,</span><br><span class="line">                      &#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> pluck_fn</span><br></pre></td></tr></table></figure><hr><p><a href="https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming">原文地址</a> <em>顺带一提: 本文的章节号很乱, 出于尊重原文(lan)的原因没有改</em></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码组织 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体验stage-3 async/await</title>
      <link href="/2016/11/13/stage-3-async-await/"/>
      <url>/2016/11/13/stage-3-async-await/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript官方提出的异步解决方案(可能是阶段性的终极方案), 原理是<em>generator</em>的执行器(官方逼死同人系列ww[<em>co</em>]). 越新的东西越傻瓜, 所以来体验下.</p><p><strong>本文所有的结论都是基于babel的preset-stage-1环境编译<a href="http://github.com/fjonas/ecma-feature-test">实验</a>的结果</strong>(这个性质是stage-3的, 只是偷懒?)</p><span id="more"></span><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>async</code> 在<code>function</code>前修饰函数, 使函数变为async函数. 形如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//do sth.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在async函数内可以使用<code>await</code>来修饰async函数内的方法. 形如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">doSth</span>();</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">doSthElse</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><ul><li><code>await</code>可以用来修饰同步方法和promise方法.</li><li><code>await</code>修饰callback方法没有意义. (也就是不会去取callback的结果)</li></ul><h3 id="await修饰同步方法"><a href="#await修饰同步方法" class="headerlink" title="await修饰同步方法"></a>await修饰同步方法</h3><p>如果一个async函数中存在多个<code>await</code>修饰的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> nonDelayFn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`result`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promiseNDAsync = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">nonDelayFn</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">let</span> result2 = <span class="keyword">await</span> <span class="title function_">nonDelayFn</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">NDFResult</span> = <span class="title function_">promiseNDAsync</span>();</span><br></pre></td></tr></table></figure><p>执行结果与不加<code>await</code>相同. 顺序执行.</p><h3 id="await修饰promise方法"><a href="#await修饰promise方法" class="headerlink" title="await修饰promise方法"></a>await修饰promise方法</h3><p>如果一个async函数中存在多个<code>await</code>修饰promise的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseFn = <span class="keyword">function</span> (<span class="params">sucPossibility = <span class="number">1</span>, delay = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt;= sucPossibility) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`sucMsg`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">`errMsg`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promiseAsync = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> promiseSuc = <span class="keyword">await</span> <span class="title function_">promiseFn</span>(<span class="number">1</span>, <span class="number">5000</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise suc: <span class="subst">$&#123;promiseSuc&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">let</span> promiseErr = <span class="keyword">await</span> <span class="title function_">promiseFn</span>(<span class="number">0</span>, <span class="number">5000</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`catched err: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise err: <span class="subst">$&#123;promiseErr&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> asyncReturn = <span class="title function_">promiseAsync</span>();</span><br></pre></td></tr></table></figure><p>以上是实验的代码, 得出几个结论:</p><ul><li>经过<code>await</code>修饰的方法会直接返回promise的resolve结果, 来替代promise</li><li>如果有多个<code>await</code>修饰的promise函数, <strong>无论是否有依赖关系</strong>都将会依次执行并<strong>等待promise返回结果</strong>再执行下一步. 也就是这个地方以前需要用回调来些.</li><li><code>await</code>修饰过的promise返回的是resolve结果, 如果失败程序会报错发出退出信号, 所以必须加catch来捕获错误, 或者把await放在<code>try</code>块中.</li><li>如果promise被reject, catch到错误的话程序会继续运行, await修饰过的方法范围值为<code>undefined</code>.</li></ul><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async函数的返回值很容易理解, 有以下特点:</p><ul><li><p><code>return</code>任何值的async函数都将被<strong>立即</strong>接收到. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseFn = <span class="keyword">function</span> (<span class="params">sucPossibility = <span class="number">1</span>, delay = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt;= sucPossibility) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`sucMsg`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">`errMsg`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> promiseAsync = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> promiseSuc = <span class="keyword">await</span> <span class="title function_">promiseFn</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise suc: <span class="subst">$&#123;promiseSuc&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">let</span> promiseErr = <span class="keyword">await</span> <span class="title function_">promiseFn</span>(<span class="number">0</span>, <span class="number">0</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`catched err: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise err: <span class="subst">$&#123;promiseErr&#125;</span>`</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> asyncReturn = <span class="title function_">promiseAsync</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`async fn returned <span class="subst">$&#123;asyncReturn&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>以上代码执行的结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async fn returned [object Promise]</span><br><span class="line">promise suc: sucMsg</span><br><span class="line">catched err: errMsg</span><br><span class="line">promise err: undefined</span><br></pre></td></tr></table></figure><p>也就是async的返回值行为与同步函数一样. 所以个人认为他要被应用在异步函数处理的时候大多数<strong>会以匿名函数的形式出现</strong>.</p></li><li><p><code>return</code>的值会被promisefy. 如果返回一个基础类型的值(<strong>包括<code>null</code>, <code>0</code>, <code>undefined</code></strong>)或者<code>function</code>, 会被包装在promise的resolve中.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌拓展程序初体验</title>
      <link href="/2016/11/07/how-to-build-an-chrome-extension/"/>
      <url>/2016/11/07/how-to-build-an-chrome-extension/</url>
      
        <content type="html"><![CDATA[<p>谷歌的拓展其实就是一(几)个网页而已拉, 1分钟就可以很容易弄起来一个谷歌拓展. 所以gogogo.</p><span id="more"></span><h2 id="简单的介绍"><a href="#简单的介绍" class="headerlink" title="简单的介绍"></a>简单的介绍</h2><h3 id="什么是chrome拓展"><a href="#什么是chrome拓展" class="headerlink" title="什么是chrome拓展"></a>什么是chrome拓展</h3><p>所以chrome拓展乃谷歌chrome提供的可在浏览器上做一些小程序的功能. 编写的方式就是普通的前端网页技术. 功能很多很多. 这篇文章也只是讲很少一部分. 可能一些别的浏览器也支持chrome拓展, 我并没有仔细看. </p><h3 id="如何加载-x2F-打包拓展程序"><a href="#如何加载-x2F-打包拓展程序" class="headerlink" title="如何加载&#x2F;打包拓展程序"></a>如何加载&#x2F;打包拓展程序</h3><p>在浏览器地址栏输入<a href="chrome://extensions/">chrome:&#x2F;&#x2F;extensions&#x2F;</a>就可以看到拓展啦. 这里简单说一下4个按钮:</p><ul><li>右上角<code>Developer mode</code>勾选以后进入了开发者模式</li><li>下方<code>Get more extensions</code>可以进入商店选择别人写的拓展</li><li>正中的位置左边的按钮<code>Load unpacked extension</code>是开发的时候加载的按钮</li><li>正中的位置右边的按钮<code>Pack extension</code>作用是打包完成的拓展.</li></ul><p>然后的话如果可以把自己开发的拓展注册在谷歌上. 也不贵.</p><h2 id="一个可以运行的拓展程序的组成部分"><a href="#一个可以运行的拓展程序的组成部分" class="headerlink" title="一个可以运行的拓展程序的组成部分"></a>一个可以运行的拓展程序的组成部分</h2><p>只要<code>Load unpacked extension</code>成功就可以算一个拓展了. 一个拓展需要:</p><ul><li>一个文件夹, 加载的时候就加载他.</li><li>一个<code>manifest.json</code>文件.</li></ul><p>好了. </p><p>那么<code>manifest.json</code>的内容呢, 如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;myExt&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extVersion&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>没错, 只需要3个字段拓展就ok了. <code>manifest_version</code>一定是数字2. 其他的为字符串, 内容随意.</p><h2 id="常用内容介绍"><a href="#常用内容介绍" class="headerlink" title="常用内容介绍"></a>常用内容介绍</h2><p><a href="https://developer.chrome.com/extensions/getstarted">chrome拓展的文档</a>在这, manifest的字段很多, api更多. 这个章节讲一些常用的api和插件运行方式.</p><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><ul><li><code>description</code>: 项目描述</li><li><code>icons</code>: 显示在拓展界面的图表</li><li><code>browser_action</code>: 拓展对浏览器的影响. (比如小图标的显示, 右击菜单等)</li><li><code>content_scripts</code>: 对访问的页面进行操作的脚本.</li><li><code>background</code>: 后台, 这个后面会讲</li><li><code>options_page</code>: 选项卡的页面, 右击拓展图表会有选项的选项. 点击会进入这个配置的页面.</li><li><code>perissions</code>: 需求的权限. 你的拓展可以调用的api的权限在这分配. 当然也回在用户加载你的拓展的时候被提示. 这是一些影响很大的权限. 比如操作storage(随用户名漫游的), 桌面提醒(与web的api是不同的), 操作书签(这个真的厉害了, 可以清空你所有书签), 右击菜单(这个也很帅)等.</li></ul><h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>我们的拓展在<code>browser_action</code>中可以指定<code>default_popup</code>字段来指定一个点击图表后弹出的页面, 其实也就是拓展的主界面(也有很多拓展没有弹出页面). 这个页面用于展示, 关闭当前页面或者关闭弹出也就会关闭这个页面, 所以无法进行数据的保存.</p><p>那么数据的保存就有<code>background</code>指定的文件来做. 打开浏览器后background就会在后台运行. 并且他是有页面的(一般不指定, 因为大多情况没有意义). 在这里可以保存数据, 操作api.</p><p>也就是说后台类似于服务端, 弹出页面类似于前端. 他们的交互由api实现. 并且交互的api有个比较坑的地方, <strong>接口需要即使相应, 只要有等待的操作会立即返回<code>undefined</code></strong>, 具体原理或者是否可配置还没有深入.</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>好拉稍微介绍几个api. 这些api通常在<code>background</code>中调用的, 原因在上节说了, 少部分在弹出页面调用.</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>这个api很重要, 等于是前端后端的协议了. 用起来很简单, 但是觉得坑也是有的, 在上节已经提到一个了. 然后他没有类似’事件名字’意思的字段, 就直接发个数据, 另外每次传递数据会带着当前tab的信息的. 我就为这个消息做了最简单的封装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sender</span> &#123;</span><br><span class="line">    <span class="title function_">send</span>(<span class="params">event, data = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123;<span class="attr">request</span>: event, <span class="attr">data</span>: data&#125;, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(response);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reciever</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">        chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">message, sender, sendResponse</span>) =&gt;</span> &#123;</span><br><span class="line">            message.<span class="property">request</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">events</span>[message.<span class="property">request</span>] &amp;&amp; <span class="title function_">sendResponse</span>(<span class="variable language_">this</span>.<span class="property">events</span>[message.<span class="property">request</span>](message.<span class="property">data</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">event, fn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[event] = fn;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="title class_">Message</span> = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">sender</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">sender</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">reciever</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">reciever</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="桌面提示"><a href="#桌面提示" class="headerlink" title="桌面提示"></a>桌面提示</h3><p>这个桌面提示与h5接口略有不同, 可以<strong>改变</strong>, 可以销毁, 弹出的签名不是当前网站的host, 当然也不会requestPermission. 然后每个提示是有id的. 没有仔细想, 如果需要维护id的话应该比较花功夫. 这个是个极简版的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> notifier = &#123;</span><br><span class="line">    <span class="attr">pop</span>: <span class="function">(<span class="params">content, title = <span class="string">&quot;友情提示&quot;</span>, ico = <span class="string">&quot;../imgs/ruby_q.png&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">        chrome.<span class="property">notifications</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;basic&quot;</span>,</span><br><span class="line">            <span class="attr">iconUrl</span>: ico,</span><br><span class="line">            <span class="attr">title</span>: title,</span><br><span class="line">            <span class="attr">message</span>: content</span><br><span class="line">        &#125;, <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(cb);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h3 id="badge"><a href="#badge" class="headerlink" title="badge"></a>badge</h3><p>badge可以设置颜色, badge内容. 因为badge一般是个消息条数, 提示条数的东西, 限制3个字符(可能是4个), 超过长度会被省略号代替.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> badge = &#123;</span><br><span class="line">    <span class="title function_">setColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">        chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeBackgroundColor</span>(&#123;<span class="attr">color</span>: color&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setText</span>(<span class="params">text, color</span>) &#123;</span><br><span class="line">        chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeText</span>(&#123;<span class="attr">text</span>: text.<span class="title function_">toString</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (color)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setColor</span>(color);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeText</span>(&#123;<span class="attr">text</span>: <span class="string">&quot;&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h3><p>储存分为2种, 一种为<code>chrome.storage.local</code>, 本地储存, 另外一种<code>chrome.storage.sync</code>同步储存, 如果没有登录用户或者没有网的时候行为会与本地储存一致. 他与h5的storage也是不同的. h5的只能存字符串. 他可以存数组, 对象什么的. 这个我看来要使用还是需要做一些处理:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> storage = &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">        obj[key] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(obj, <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`ok<span class="subst">$&#123;callback&#125;</span>`</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(key, <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(callback[key]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(callback);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">sAdd</span>(<span class="params">set, key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">get</span>(set)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                result = result || &#123;&#125;;</span><br><span class="line">                result[key] = value;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">set</span>(set, result);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">sGet</span>(<span class="params">set, key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">get</span>(set)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (result &amp;&amp; result[key]) ? <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(result[key]) : <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;set not found&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">sRem</span>(<span class="params">set, key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">get</span>(set)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp;&amp; result[key]) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> result[key];</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">set</span>(set, result);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;set not found&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">remove</span>(key, <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(callback);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="告一段落"><a href="#告一段落" class="headerlink" title="告一段落"></a>告一段落</h2><p>试水过程中顺带用<code>vue</code>(试水++) 做了前端(并没有画样式) 做了一些<a href="https://github.com/fjonas/yosoro/tree/v0.0.1">小功能</a>. 感觉不错. 将来可以拓展作为方便的小工具啦.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> 入门 </tag>
            
            <tag> chrome extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客生成目录</title>
      <link href="/2016/11/07/blog-outline/"/>
      <url>/2016/11/07/blog-outline/</url>
      
        <content type="html"><![CDATA[<p>本次尝试给博客的文章加个目录. 完成了第一版, 虽然还存在各种问题, 但是大概的样子已经有了.<br>前前后后的东西也不多吹了, 直接由步骤作为大标题了.</p><span id="more"></span><h2 id="放置"><a href="#放置" class="headerlink" title="放置"></a>放置</h2><p>由于每个文章目录不同, 第一想法是必须有js来生成, 所以没有放在widget中, 暂时选择放在<code>post.pug</code>中引入的<code>post.js</code>中来用jquery强行append一个目录.</p><h2 id="检索标题"><a href="#检索标题" class="headerlink" title="检索标题"></a>检索标题</h2><p>由于博客标题, 文章标题都是H1标题, 一般文章内容从H2开始(并不是什么一般, 其实是不由H2开始那目录就乱了).<br>思路很简单, 代码也很简单, 所以只能用代码撑一下文章字数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤一下特殊字符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">escp</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="title function_">replace</span>(<span class="regexp">/([\s\.\*\=\+\&gt;\,\[\]\:\~\?\&#x27;\&quot;\(\)])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//从dom树种检索标题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getOutLine</span>(<span class="params">titles, startNum</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> content = [];</span><br><span class="line">    [].<span class="property">filter</span>.<span class="title function_">call</span>(titles, <span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">tagName</span> == <span class="string">&quot;H&quot;</span> + startNum;</span><br><span class="line">    &#125;).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        content.<span class="title function_">push</span>(<span class="title function_">generateOutline</span>(item, startNum));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">generateOutline</span>(<span class="params">item, tagn</span>) &#123;</span><br><span class="line">        $(item).<span class="title function_">attr</span>(<span class="string">&#x27;id&#x27;</span>, <span class="title function_">escp</span>(item.<span class="property">textContent</span>));</span><br><span class="line">        <span class="keyword">var</span> result = &#123;</span><br><span class="line">            <span class="attr">name</span>: item.<span class="property">textContent</span>,</span><br><span class="line">            <span class="attr">depth</span>: +tagn,</span><br><span class="line">            <span class="attr">child</span>: []</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; titles.<span class="property">length</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (titles[index] == item) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (titles[index].<span class="property">tagName</span> == <span class="string">&quot;H&quot;</span> + tagn) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (titles[index].<span class="property">tagName</span> == <span class="string">&quot;H&quot;</span> + (+tagn + <span class="number">1</span>)) &#123;</span><br><span class="line">                    result.<span class="property">child</span>.<span class="title function_">push</span>(<span class="title function_">generateOutline</span>(titles[index], +tagn + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> titles = $(<span class="string">&#x27;h2,h3,h4,h5&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="title function_">getOutLine</span>(titles, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当然是依赖了jquery, 所以好像不能在别的地方服用, 要用的话得简单修改下.</p><p>这样<code>content</code>是获得到的标题树了, 现在直接复制代码在浏览器的控制台就能看到<code>content</code>的内容了.</p><h2 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h2><p>由于目录是由结构的(虽然大多文章结构并不多), 所以不能一个循环完成, 需要多写几行: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">appendMess</span>(<span class="params">target, data</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = $(<span class="string">&#x27;&lt;li&gt;&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> a = $(<span class="string">&#x27;&lt;a&gt;&#x27;</span>);</span><br><span class="line">  a.<span class="title function_">attr</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;#&quot;</span> + <span class="title function_">escp</span>(data.<span class="property">name</span>));</span><br><span class="line">  a.<span class="title function_">html</span>(data.<span class="property">name</span>);</span><br><span class="line">  li.<span class="title function_">html</span>(a);</span><br><span class="line">  li.<span class="title function_">addClass</span>(<span class="string">&#x27;depth&#x27;</span> + data.<span class="property">depth</span>);</span><br><span class="line">  target.<span class="title function_">append</span>(li);</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">child</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ul = $(<span class="string">&#x27;&lt;ul&gt;&#x27;</span>);</span><br><span class="line">    ul.<span class="title function_">addClass</span>(<span class="string">&#x27;nav&#x27;</span>);</span><br><span class="line">    ul.<span class="title function_">addClass</span>(<span class="string">&#x27;depth&#x27;</span> + (+data.<span class="property">depth</span> + <span class="number">1</span>));</span><br><span class="line">    li.<span class="title function_">append</span>(ul);</span><br><span class="line">    data.<span class="property">child</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">each</span>) &#123;</span><br><span class="line">      <span class="title function_">appendMess</span>(ul, each);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把数据, 生成到的标的dom传入就可以了, 再加个标题’目录’, 用jquery加到右边的widget上就可以了.</p><h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h2><p>当然有了目录要知道当前滚到哪里, 所以找到了这个<a href="https://github.com/forsigner/scroll-spy">lib</a>, 会把当前滚到的地方加上<code>active</code>类, 但这不是我理想的lib, 优化时需要修改用法或者换别的lib.</p><p>代码的话是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollSpy.<span class="title function_">init</span>(&#123;<span class="attr">nodeList</span>: $(<span class="string">&quot;nav a&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure><p>这样滚动到哪会给加上<code>active</code>类, 在css里处理下就ok了.</p><h2 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h2><p>当然作为目录需要被固定, 要不spy还有什么意义. 于是也找到了个<a href="https://github.com/webpop/jquery.pin">lib</a>, 这个非常炫酷了. </p><p>代码的话也一样简单:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#outline&quot;</span>).<span class="title function_">pin</span>();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初步的, 难看的, bug很多的目录就做好了, 今后会改(lan)进(wei)的.</p><p>以上一切都需要jquery, 哈哈. 正好也不浪费.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular decorator</title>
      <link href="/2016/10/20/angular-decorator/"/>
      <url>/2016/10/20/angular-decorator/</url>
      
        <content type="html"><![CDATA[<p>许多知识点只在脑内有印象而并没有实际应用, 比如我ng的decorator, 今终于有机会来一把体验.</p><span id="more"></span><h2 id="告老师-这个lib写得不好"><a href="#告老师-这个lib写得不好" class="headerlink" title="告老师, 这个lib写得不好"></a>告老师, 这个lib写得不好</h2><p>在某个项目中一直使用者<a href="http://lorenzofox3.github.io/smart-table-website/">st-table</a>(这个得翻墙)然而某天出现了这样的需求: 后台定时刷新表格的数据.</p><p>问题出现了, 假若我正在查看一些第二页的数据, 后台数据一刷新, 也就是给<code>datas</code>赋了新值, st-table的分页插件给直接翻到了第一页呢. 看了文档以后觉得没有提供明显的接口, scope也是独立的, 这该如何是好.</p><h3 id="先解决需求"><a href="#先解决需求" class="headerlink" title="先解决需求"></a>先解决需求</h3><p>脑子里第一个解决方案是最straight的: 刷新数据前保存当前页数, 刷新后手动翻页到指定页数, 也就是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$scope.<span class="property">loadData</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> curPage = $scope.<span class="property">$$childHead</span> ? $scope.<span class="property">$$childHead</span>.<span class="property">currentPage</span> : <span class="number">1</span>;</span><br><span class="line">    loadService.<span class="title function_">load</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            $scope.<span class="property">treedata</span> = treedata;</span><br><span class="line">            $scope.<span class="property">topics</span> = topics;</span><br><span class="line">            $timeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                $scope.<span class="property">$$childHead</span>.<span class="title function_">selectPage</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(curPage, $scope.<span class="property">$$childHead</span>.<span class="property">pages</span>.<span class="property">length</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行一看, 还真对得起我这张脸, 可以正常运作, 强行深入敌后调用了分页scope的方法.</p><h3 id="闪闪闪"><a href="#闪闪闪" class="headerlink" title="闪闪闪"></a>闪闪闪</h3><p>上面的解决方案只要一刷新页面就会翻到第一页, 再翻回到之前的页面, 非常尴尬呢. 看了st-table的源码, 发现了一段逻辑如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$scope.$watch(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">safeGetter</span>($scope);</span><br><span class="line">            &#125;, <span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">                    tableState.<span class="property">pagination</span>.<span class="property">start</span> = <span class="number">0</span>;</span><br><span class="line">                    <span class="title function_">updateSafeCopy</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>我的天老爷, 数据一变化就给强行翻到第一页, 就是这么强势.</p><p>于是想了些方法, 比如刷新好检测是否与上次数据相同, 相同则不赋值, 这个想法非常简陋, 并没什么用(只能减少一部分闪的情景)</p><h3 id="引言结束"><a href="#引言结束" class="headerlink" title="引言结束"></a>引言结束</h3><p>终于引入了decorator, 之前一直有耳闻, 作用是改变已经加载的模块的行为, 也就是项目中暂时改写lib咯. 以上的例子只是一小点, 临时改变lib的行为的需求还是挺多的, 毕竟每个项目都可能有独特的奇怪的需求.</p><p> 下面来说一下decorator.</p><h2 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h2><p>何为decorator? 重写已经定义过的模块, 包括<code>service</code>,<code>directive</code>,<code>filter</code>. 如果对lib不满意, 或者是需要在某个项目特殊处理, decorator是您最好的选择.</p><p><a href="https://code.angularjs.org/1.5.8/docs/guide/decorators">文档</a></p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>来段示例代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;myApp&#x27;</span>, [])</span><br><span class="line"></span><br><span class="line">.<span class="title function_">config</span>([ <span class="string">&#x27;$provide&#x27;</span>, <span class="keyword">function</span>(<span class="params">$provide</span>) &#123;</span><br><span class="line"></span><br><span class="line">  $provide.<span class="title function_">decorator</span>(<span class="string">&#x27;$log&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;$delegate&#x27;</span>,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">$logDecorator</span>(<span class="params">$delegate</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> originalWarn = $delegate.<span class="property">warn</span>;</span><br><span class="line">      $delegate.<span class="property">warn</span> = <span class="keyword">function</span> <span class="title function_">decoratedWarn</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        msg = <span class="string">&#x27;Decorated Warn: &#x27;</span> + msg;</span><br><span class="line">        originalWarn.<span class="title function_">apply</span>($delegate, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> $delegate;</span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>在<code>.decorator()</code>中第一个参数就是被装潢的方法了, function中的<code>$delegate</code>可以看做被装换模块的复制, 可以对他做操作, 或者完全重写return回去.</p><h3 id="被装潢名字的讲究"><a href="#被装潢名字的讲究" class="headerlink" title="被装潢名字的讲究"></a>被装潢名字的讲究</h3><p><code>$provide.decorator(&#39;$log&#39;, function()&#123;&#125;)</code>中的<code>$log</code>就是被装潢的服务名字了, 然而<code>directive</code>和<code>filter</code>有些区别的.</p><ul><li><code>directive</code>装换需要加上<code>Directive</code>, 如<code>$provide.decorator(&#39;myDirectiveDirective&#39;, …)</code></li><li><code>filter</code>同样的需要加上<code>filter</code></li></ul><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>好了, 文档看好了, 如何解决文章开头提到的问题呢, 也直接来代码吧.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">.<span class="title function_">config</span>(<span class="function">(<span class="params">$provide</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> betterStTableCtrl = &#123;</span><br><span class="line">    <span class="comment">//这里是修改的东西</span></span><br><span class="line">  &#125;;</span><br><span class="line">  $provide.<span class="title function_">decorator</span>(<span class="string">&#x27;stTableDirective&#x27;</span>, <span class="function">(<span class="params">$delegate</span>) =&gt;</span> &#123;</span><br><span class="line">        $delegate.<span class="property">controller</span> = betterStTableCtrl;</span><br><span class="line">        <span class="keyword">return</span> $delegate;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就是这么简单, 我需要修改的是<code>directive</code>, 名字是<code>stTable</code>, 那么注入名字就为<code>stTableDirective</code>, 然后对<code>$delegate</code>进行修改, 我这里需要修改的是他提供的api, 然后把修改后的return回去, 搞定了. 别的需要修改的也可以继续改咯.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> 代码组织 </tag>
            
            <tag> 应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>楚门的世界</title>
      <link href="/2016/10/20/true-man-show/"/>
      <url>/2016/10/20/true-man-show/</url>
      
        <content type="html"><![CDATA[<p>在es6 in depth系列的翻译中看见作者提到了true man show, 休息的时间看了下. 在此总(ju)结(tou)一下.</p><span id="more"></span><h2 id="剧情总览"><a href="#剧情总览" class="headerlink" title="剧情总览"></a>剧情总览</h2><p>主人公名字为楚门(trueman, 下文简称为tm), 从出生开始一直是被’导演’的生活, 这种导演强调<strong>一切都是真实的, 只是调控</strong>, 前半部分不知道电影在说些什么, 后半部分恍然大悟的感觉. 是这部电影的特点.</p><h2 id="二周目感受"><a href="#二周目感受" class="headerlink" title="二周目感受"></a>二周目感受</h2><p>第一遍看的时候觉得主角可能是个精神病人之类的, 而看完以后二周目前半有了很多感受.</p><h3 id="后悔了之前对主角的判定"><a href="#后悔了之前对主角的判定" class="headerlink" title="后悔了之前对主角的判定"></a>后悔了之前对主角的判定</h3><p>二周目的时候发现前半集的主角的一切动作, 都合第一次看的时候感觉不一样. 现实也如此, 不同人不同阶段看一个事情看到的东西是不一样的. 世界可能是主观的.</p><p>以下列举一些二周目感觉的小细节:</p><ul><li>航空公司的图片: 闪电会劈中</li><li>医院里一群病人一起自己飞快的推轮椅, ‘病人’没打麻药</li><li>所有人面无表情,去芝加哥的车上, 而且说了车子坏 了没人有怨言, 统一下车</li><li>照应后面说24小时直播没广告, 美露经常有广告行为, trueman也发现了, 而我没有发现</li></ul><p>同样, 主角的行为也非常睿智, <strong>看起来神经病的人只是你不知道, 知道了事情以后发现他是天才, 因为第一次看的时候自己的智商不知道发生了什么</strong>, 对别人的评论也如此, 每个你觉得不怎么的人可能都比自己厉害多了. 也举一些细节:</p><ul><li>说小镇的人在绕圈, 说老婆在对别人说话</li><li>他开车去什么地方的时候, 车很整齐的转入他的车道, 然后有的地方车满, 换一个马路车就没了</li><li>他尝试停下车子, 也没人骂他, 世界围着他转, 然后尝试非正常点对点工作的事, 被阻止. 发现了一些非正常的事–看电影的人并没有多想</li></ul><h3 id="调控"><a href="#调控" class="headerlink" title="调控"></a>调控</h3><p>主角的一切都是被’调控’的, 其实就是控制, 他和老婆相遇很难看得出是它老婆硬上她的.</p><p>周围有朋友会说, 不要担心, 没有工作没有老婆没成家没关系, 都安排好的, 几年以后大家都会有老婆有房子的. 本来是让人开心的语言, 现在想想很恐怖. 我之前一直觉得事情都是被安排好的(可能是脑子不好物理没学好的关系), 现在倒开始觉得, <strong>人不能被命运安排</strong>, 要尽量努力做点什么才好呢, (如果有水到渠成的好事或许有点怕呢, 是不是陷阱, 好事要自己争取来哦).</p><h3 id="戏里戏外"><a href="#戏里戏外" class="headerlink" title="戏里戏外"></a>戏里戏外</h3><p>trueman的好友当然也是演员, 但是对trueman说了一段话, 即使是演员, 感情也是真的, 毕竟从小到大都是朋友呢. 骗人先骗自己, 人本身就都不是真的, 但也不全是假的. 罗兰的感情倒全是真的, 他可能就是来拯救trueman为目的来当演员的呢, 可是是不是也有别的假的东西驱动的成分呢.</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>我们也一样, 不知道自己生活的世界的运行规律的. 导演说:</p><blockquote><p>我们也只是单纯的接受着周围发生的一切.</p></blockquote><p>如此, 也许导演得更好一些, trueman就不会发现他的世界是被演的了. 也许我们正处于一个这样一个演得很好的世界呢, 毕竟我们还有太多太多可能99%的世界运行的机制都不知道.</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth let 与 const</title>
      <link href="/2016/09/10/es6-in-depth-let-and-const/"/>
      <url>/2016/09/10/es6-in-depth-let-and-const/</url>
      
        <content type="html"><![CDATA[<p>当Brendan Eich在1995年设计了第一版javascript, 他留下了很多错误, 包括至今还留着的部分, 包括<code>Date</code>object和object会在你试图乘他们的时候转换为<code>NaN</code>. 但他也有做得好的地方: object; prototypes; 等等. 让语言有了骨架. 使语言比看上去的更好.</p><p>当然Brendan也做了一些设计导致了今天文章的主题~让我们来看一下吧.</p><p>是关于变量的.</p><h2 id="问题-1-代码块没有作用域"><a href="#问题-1-代码块没有作用域" class="headerlink" title="问题#1: 代码块没有作用域"></a>问题#1: 代码块没有作用域</h2><p>这个规则听上去没什么错: <strong>js函数中的<code>var</code>关键字创建的<a href="http://robertnyman.com/2008/10/09/explaining-javascript-scope-and-closures/">作用域</a>是这个函数的整个函数体</strong>. 但有两个情况会产生问题.</p><p>一个问题是在代码块中声明的变量作用不是代码块, 而是整个函数.</p><p>你可能之前都没注意过. 恐怕这个问题你不可以当做没看见一样. 我们来谈谈这个问题会导致bug的场景吧.</p><p>假设你在代码中用了变量<em>t</em>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runTowerExperiment</span>(<span class="params">tower, startTime</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> t = startTime;</span><br><span class="line"></span><br><span class="line">  tower.<span class="title function_">on</span>(<span class="string">&quot;tick&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ... code that uses t ...</span><br><span class="line">  &#125;);</span><br><span class="line">  ... more code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前看起来一切都正常. 现在你像加一个测试保龄球测速器, 所以你需要写一些<code>if</code>语句在回调方法中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runTowerExperiment</span>(<span class="params">tower, startTime</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> t = startTime;</span><br><span class="line"></span><br><span class="line">  tower.<span class="title function_">on</span>(<span class="string">&quot;tick&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ... code that uses t ...</span><br><span class="line">    <span class="keyword">if</span> (bowlingBall.<span class="title function_">altitude</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> t = <span class="title function_">readTachymeter</span>();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ... more code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦, 亲爱的. 你不经意地写了第二个变量<em>t</em>. 之前”用了变量t的代码”工作正常, 而现在<code>t</code>指向的是代码块内部的变量而不是外部的<code>t</code>了.</p><p><code>var</code>在javascript中就像把变量扔进了染缸. 会向两边拓展定义, 前和后, 直到方法边界. 虽然变量<em>t</em>的作用域拓展到方法头部, 但还是在创建时进入方法的. 这个行为被成为<em>变量提升</em>. js引擎会把每个<code>var</code>和<code>function</code>声明的变量提升到函数块的头部.</p><p>变量提升有他的好处. 许多写得好的代码不适用<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">立即执行函数</a>. 但在这个case中, 变量提升导致了很麻烦的问题: 你所有使用<em>t</em>变量的地方会开始产生<code>NaN</code>. 并且很难去追踪. 特别是在更大的项目中.</p><p>新加一个代码块会产生莫名其妙的错误, 我们并不想代码产生额外的行为.</p><p>这只是<code>var</code>问题的一部分.</p><h2 id="问题-2-循环中变量指向"><a href="#问题-2-循环中变量指向" class="headerlink" title="问题#2: 循环中变量指向"></a>问题#2: 循环中变量指向</h2><p>你可以猜一下下面代码的运行结果, 这很简单:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = [<span class="string">&quot;Hi!&quot;</span>, <span class="string">&quot;I&#x27;m a web page!&quot;</span>, <span class="string">&quot;alert() is fun!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; messages.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(messages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你一直追这个es6系列的文章, 你会发现我一直用<code>alert()</code>. 也许你知道<code>alert()</code>是个很可怕的api, 他是同步的. 所以当alert弹出的时候, 输入事件不会被传递, 你的js代码 — 事实上是你整个UI — 在你点击确定前全被暂停了.</p><p>在你的web页面中使用<code>alert()</code>是不好的, 但我用她是觉得<code>alert()</code>是一个很好的测试工具.</p><p>接下来我要写个说话的猫的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = [<span class="string">&quot;Meow!&quot;</span>, <span class="string">&quot;I&#x27;m a talking cat!&quot;</span>, <span class="string">&quot;Callbacks are fun!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; messages.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    cat.<span class="title function_">say</span>(messages[i]);</span><br><span class="line">  &#125;, i * <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://jsfiddle.net/8t2q8wfr/4/">运行效果</a></p><p>但是好像有问题, 猫没有说那些话, 而是说了3次”undefined”.</p><p>你可以定位到bug吗?</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/7994751456_e8d2019876_o.jpg" alt="一个图片"></p><hr><p>这里的问题就出在变量<em>i</em>. 循环的变量共享了外面的变量, 当循环结束, i的值是3, 所以<code>messages[3]</code>是<code>undefined</code>.</p><h2 id="let是新的var"><a href="#let是新的var" class="headerlink" title="let是新的var"></a><code>let</code>是新的<code>var</code></h2><p>大部分情况, javascript的设计错误(别的语言也如此, 但特别是js)不能被修复. 因为需要兼容之前的代码. 即使标准委员会也没权利说来修复 javascript中奇怪的自动补分号的行为. 浏览器也不会去实现断层的更新, 这样会影响到用户.</p><p>所以大概10年前, Brendan Eich决定要修复这个问题, 而且只有一个办法可以做到.</p><p>他加了一个新关键字<code>let</code>, 用来定义变量, 和<code>var</code>用法一样, 但是有更好的作用域规则.</p><p>看起来是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="title function_">readTachymeter</span>();</span><br></pre></td></tr></table></figure><p>或者是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; messages.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code>和<code>var</code>是不同的, 如果你进行全局替换, 会破坏你的代码(可能是不经意的), 因为<code>var</code>奇怪的行为. 但在大多数的情况中, 在用es6新写的代码中, 你应该要在任何情况下停止使用<code>var</code>而使用<code>let</code>来替代. 因此才有了这个口号: “<code>let</code>是新的<code>var</code>“.</p><p>那么到底<code>let</code>和<code>var</code>有什么区别呢? 很高兴你这么问.</p><ul><li><p><strong><code>let</code>变量是块级作用域的.</strong> <code>let</code>定义的变量作用域是当前代码块, 而不是函数块.</p><p><code>let</code>仍然有变量提升, 但不是盲目的了. 刚才的<code>runTowerExperiment</code>的例子可以通过简单地用<code>let</code>替代<code>var</code>来修复. 如果你到处都用<code>let</code>那就不会有这种问题了.</p></li><li><p><strong>全局中使用<code>let</code>不会把变量挂到全局object上.</strong> 也就是说你不能通过<code>window.variableName</code>来拿到变量了. 这些变量现在在一个看不见的抽象的闭包中.</p></li><li><p><strong>类似<code>for(letx...)</code>的循环每次遍历都会创建一个新的x.</strong></p><p>这是一个很微小的变化. 意思是<code>for(let...)</code>循环执行了多次, 循环会维护一个闭包, 比如刚才说话的猫的例子, 每次循环都会捕捉当前循环的变量的副本, 而不像但作用域一样捕捉到了相同的变量.</p></li><li><p><strong>如果在定义<code>let</code>变量前就使用会报错.</strong> 直到变量被声明前, 变量都没有被初始化. 看例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current time:&quot;</span>, t);  <span class="comment">// ReferenceError</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> t = <span class="title function_">readTachymeter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个规则是帮你查错的. 如果这么写会直接报错, 而不是得到一个<code>NaN</code>.</p><p>这种情况: 变量在一个作用域内, 但没被初始化, 这个区域被称作<em>暂时的死区</em>. 这里会去等到变量被声明的地方为止.</p></li><li><p><strong>重新声明<code>let</code>会导致<code>SymtaxError</code></strong>.</p><p>这个规则也是用来帮我们检查错误的. 这也是如果你把<code>let</code>换成<code>var</code>以后很容易发生的错误, 即使<code>let</code>是全局变量也如此.</p><p>如果你在多个脚本中都使用了全局变量, 你最好用<code>var</code>来代替他. 如果你使用<code>let</code>, 那么这些脚本加载时会报错.</p><p>或者使用es6的modules. 这是以后讲的故事了.</p><p>除了这些区别, <code>let</code>和<code>var</code>是一样的. 他们都支持用逗号分隔声明多个变量, 也都支持解构赋值.</p></li></ul><p>注意<code>class</code>的声明行为类似<code>let</code>. 所以如果你写了多个<code>class</code>, 第二次相同名字就会报重新定义的错.</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><p>好~ 再来一个!</p><p>es6还提供了第三个关键字: <code>const</code>.</p><p>被<code>const</code>修饰的变量行为与<code>let</code>一样, 除了: 在声明以外的地方为变量赋值都会得到<code>SyntaxError</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_CAT_SIZE_KG</span> = <span class="number">3000</span>; <span class="comment">// 🙀</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">MAX_CAT_SIZE_KG</span> = <span class="number">5000</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="variable constant_">MAX_CAT_SIZE_KG</span>++; <span class="comment">// nice try, but still a SyntaxError</span></span><br></pre></td></tr></table></figure><p>自然地, 如果你不能不给任何值地声明一个<code>const</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theFairest;  <span class="comment">// SyntaxError, you troublemaker</span></span><br></pre></td></tr></table></figure><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 类</title>
      <link href="/2016/09/10/es6-in-depth-classes/"/>
      <url>/2016/09/10/es6-in-depth-classes/</url>
      
        <content type="html"><![CDATA[<p>今天我们来讲一下一个老问题的语法: javascript中的object构造器创建.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>说一下我们想创建一个典型的面向对象设计的例子:  圆的类. 假设我们在为一个简单的canvas lib 写一个圆的类. 我们可能想直到如何做下列的事:</p><ul><li>画一个给定的圆到给定的canvas上.</li><li>追踪画过的圆的总数.</li><li>追踪画过的圆的半径, 并强制值不变.</li><li>计算所画圆的面积</li></ul><p>现在的js语言告诉我们, 我们先得写一个函数的构造器, 然后加上任何我们想这个函数自有的属性, 然后用一个object替换这个属性的<code>prototype</code>, 这个<code>prototype</code>object包含了我们创建的实例以后的属性. 即使一个很简单的例子, 我们也要花很多时间去写这些模板: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">    <span class="title class_">Circle</span>.<span class="property">circlesMade</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property">draw</span> = <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">circle, canvas</span>) &#123; <span class="comment">/* Canvas drawing code */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Circle</span>, <span class="string">&quot;circlesMade&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">_count</span> ? <span class="number">0</span> : <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_count</span> = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">area</span>: <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="variable language_">this</span>.<span class="property">radius</span>, <span class="number">2</span>) * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;radius&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_radius</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(radius))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Circle radius must be an integer.&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_radius</span> = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这些代码又复杂, 又难看懂. 现在需要一个不繁琐, 容易看懂的方法来工作, 让我们可以简单地给类添加属性. 如果以上的太复杂了, 不用担心, 下面的文章会接受简单的方法来做这些.</p><h2 id="定义方法的语法"><a href="#定义方法的语法" class="headerlink" title="定义方法的语法"></a>定义方法的语法</h2><p>第一步, es6提供了一些定义object方法的新语法. 当我添加<code>area</code>方法的时候, 我觉得这比写<code>radius</code>的getter&#x2F;setter方法麻烦多了. 因为js去除了面向对象的途径, 大家变得对设计更简单的方法来改变object有了兴趣. 现在有了一个给object添加方法的捷径了. 正如我们不需要<code>Object.defineProperty</code>而可以<code>obj.prop = method</code>来添加一个方法一样. 我们只需要按照以下步骤:</p><ol><li>在object上写一个普通的方法属性.</li><li>在object上写一个generator方法属性.</li><li>在object上写一个普通的getter&#x2F;setter方法属性.</li><li>以上任何步骤用<code>[]</code>语法来包裹属性名字. 我们把这个叫做<em>计算后的属性名</em>.</li></ol><p>这些以前都做不到. 新的语法加了以后我们可以写成以下的样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 现在添加方法不需要function关键字了</span></span><br><span class="line">    <span class="title function_">method</span>(<span class="params">args</span>) &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果声明一个generator只需要在属性名前加*号</span></span><br><span class="line">    *<span class="title function_">genMethod</span>(<span class="params">args</span>) &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessors can now go inline, with the help of |get| and |set|. You can</span></span><br><span class="line">    <span class="comment">// getter/setter不存在generator方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意getter是不接受参数的</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">propName</span>() &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter接受1个参数</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">propName</span>(<span class="params">arg</span>) &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// []语法在任何地方都可以用, 包括上面4个, 以及symbol, generator, getter/setter等等.</span></span><br><span class="line">    [<span class="title function_">functionThatReturnsPropertyName</span>()] (args) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用了新语法重写刚才的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">    <span class="title class_">Circle</span>.<span class="property">circlesMade</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property">draw</span> = <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">circle, canvas</span>) &#123; <span class="comment">/* Canvas drawing code */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Circle</span>, <span class="string">&quot;circlesMade&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">_count</span> ? <span class="number">0</span> : <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_count</span> = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="title function_">area</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="variable language_">this</span>.<span class="property">radius</span>, <span class="number">2</span>) * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">radius</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_radius</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">radius</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(radius))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Circle radius must be an integer.&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_radius</span> = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>准确地说, 上面的代码和第一版并不一样. 这么写的方法可以被编辑和遍历, 但getter&#x2F;setter就不可以了. 但在实际中不那么会注意到这个区别.</p><p>好, 其实还可以简洁, 来看看下面.</p><h2 id="Class定义语法"><a href="#Class定义语法" class="headerlink" title="Class定义语法"></a>Class定义语法</h2><p>现在来讲一下class的语法.</p><p><code>constructor</code>方法为class的构造器, <code>static</code>为静态方法, 相当与以前的<code>prototype</code>.</p><p>我们的代码变成了如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">        <span class="title class_">Circle</span>.<span class="property">circlesMade</span>++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">draw</span>(<span class="params">circle, canvas</span>) &#123;</span><br><span class="line">        <span class="comment">// Canvas drawing code</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">circlesMade</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">_count</span> ? <span class="number">0</span> : <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">set</span> <span class="title function_">circlesMade</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_count</span> = val;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">area</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="variable language_">this</span>.<span class="property">radius</span>, <span class="number">2</span>) * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">radius</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_radius</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">radius</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(radius))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Circle radius must be an integer.&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_radius</span> = radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哇哦! 又简洁又容易看, 嘿嘿, 接下来我们看几个点:</p><ul><li><strong>分号在哪里?</strong> — 为了让class看起来更像class, 所以把分号变成语法中可有可无的. </li><li><strong>如果我不想有构造器, 但还是想在object上放方法?</strong> — 可以的. <code>constructor</code>完全是个可选的方法. 如果你没有写, 那就等于你写了<code>constructor() &#123;&#125;</code>.</li><li><strong><code>constructor</code>可以是一个generator吗?</strong> — 不可以. 尝试使用getter&#x2F;setter与generator来定义构造器会抛出<code>TypeError</code>.</li><li><strong>我可以用[计算后的属性名]来定义<code>constructor</code>吗?</strong> — 不可以. 如果你尝试这么做, 那么constructor会变成class的一个方法, 而不是构造器- -</li><li><strong>如果我改变了<code>Circle</code>的值会发生什么, 会导致实例的行为错误吗?</strong> — 不会! 和方法表达式一样, 类会有一个内部的环境. </li><li><strong>如果我给class的一个方法赋值一个普通的字面量object, class会出错吗?</strong> — 不会. es6允许这种写法, 除了你企图在class中再创建一个作用域.</li><li><strong>如果我企图遍历class或者其他什么呢</strong> — 我们只可以去遍历新增的方法, 换句话说, class原有的方法只可编辑, 不可遍历.</li><li><strong>等等, 那么变量内部变量呢? 比如<code>static</code>变量有没有?</strong> — 被你发现了, es6暂时还没有这些东西, 以后的版本会跟进.</li></ul><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth Proxy</title>
      <link href="/2016/09/10/es6-in-depth-proxies/"/>
      <url>/2016/09/10/es6-in-depth-proxies/</url>
      
        <content type="html"><![CDATA[<p>下面的代码是我们今天要讲的内容:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个例子略微复杂, 之后的部分再来解释. 现在呢, 来看一下上面的代码创建的对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; obj.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line">    setting count!</span><br><span class="line">&gt; ++obj.<span class="property">count</span>;</span><br><span class="line">    getting count!</span><br><span class="line">    setting count!</span><br><span class="line">    <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里发生了什么? 我们在获得对象属性时做了拦截. 我们重载了<code>&quot;.&quot;</code>操作符.</p><h2 id="这是如何做到的"><a href="#这是如何做到的" class="headerlink" title="这是如何做到的"></a>这是如何做到的</h2><p>计算机中最有趣的诡计被叫做<em>虚拟化</em>. 是在做一些令人惊奇的事情时经常用到的技术. 这是他的工作方式:</p><ol><li><p>拿一个图片</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/power-plant.jpg" alt="一个风景图"></p></li><li><p>围着图中的某个东西画一个轮廓</p><p><img src="https://hacks.mozilla.org/files/2015/07/power-plant-with-outline.png" alt="风景图中的一艘船的周围被画了圈"></p></li><li><p>现在把轮廓中的东西用别的东西替代, 或者替代轮廓外的所有东西, 代替品是完全不相关的东西. 只有一个规矩, 就是背景适配. 你的替换必须让不知情的人注意不到某些东西被替换过.</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/wind-farm.png" alt="圈中的东西已被替换成了背景色相似的没有船的图片"></p></li></ol><p>你可能感到和某些经典电影的场景很像, 比如<em>楚门的世界</em>和<em>黑客帝国</em>. 一个人生活在一个轮廓中, 而其余部分的世界都被精心设计的假象包围着.</p><p>为了达成背景适配, 你的替换必须精心设计. 但真的难点是轮廓圈在哪.</p><p><em>轮廓</em>其实就是API包装, 一个接口, 用来告诉别的代码自己的行为或者需求对自己的输入的东西. 所以系统需要有接口, 而接口正是你应该圈画的轮廓. 你可以在满足接口的条件下替换行为, 这样别处的代码就不关心你的改动.</p><p>因为<em>没有</em>现有的接口你才必须变得有创造性. 一些很酷的软件花了很多时间去整理API的设计, 并花大量的努力去把接口实现.</p><p><a href="https://en.wikipedia.org/wiki/Virtual_memory">虚拟内存</a>, <a href="https://en.wikipedia.org/wiki/Hardware_virtualization">硬件虚拟化</a>, <a href="https://en.wikipedia.org/wiki/Docker_%28software%29">Docker</a>, <a href="http://valgrind.org/">Valgrind</a>, <a href="http://rr-project.org/">rr</a>-从各个角度来说所有这些软件都把新的, 甚至想不到的接口引入了现有的系统. 在一些情况下, 需要用一个新的操作系统, 甚至新的硬件来让新的接口良好工作.</p><p>最好的虚拟化拦截来自对虚拟化更新的理解. 为了给一些东西写API, 你必须先理解他. 一旦你理解了, 你就可以做出惊人的东西.</p><p> es6提供了javascript里最基础的东西:object的虚拟化支持.</p><h2 id="什么是object"><a href="#什么是object" class="headerlink" title="什么是object?"></a>什么是object?</h2><p>哦, 这个标题是认真的, 用一段时间想一下. 如果你知道什么是object的话可以向下滑来跳过这章了.</p><p><img src="https://hacks.mozilla.org/files/2015/07/thinker.jpg" alt="很有名的思考者雕像"></p><p>这个问题对我来说很难! 我从来没听过令人满意的定义. </p><p>很惊奇? 定义一个基础的概念一向很难 —— 来看看<a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/bookI.html">几何原本</a>的第一个定义. ECMAScript语言定义很清楚, 虽然如此, 当需要解释”对象成员”的时候并没什么用. </p><p>之后, 定义增加了”一个object是一些属性的集合”. 这个讲法不错. 如果你需要一个定义, 那就是他了, 我们之后会回来讲这个.</p><p>在我说为一些东西写API之前你必须理解他. 所以其实我可以保证通过这个我们能更好理解object, 并可以做出一些amazing的事来.</p><p>好我们来跟着es标准委员会来看看改如为object何定义一个API, 一个接口. 我们需要什么样的方法, object可以做什么.</p><p>以上的问题答案是需要看具体是什么object. DOM元素object可以做一些事情; AudioNode object可以做另外些事情. 但有一部分基础的行为是object共有的:</p><ul><li>object有属性. 你可以对属性设置, 删除等等.</li><li>object有prototype. 这是js继承的原理.</li><li>有些object有方法和构造器, 你可以调用他们</li></ul><p>几乎所有js程序员都使用object的属性, prototype和函数. 即使是比较特殊的dom元素或者audionode对象也是通过调用方法来操作他的.</p><p>完整的列表可以在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#table-5">es5和6标准</a>中看到. 我这里只将了一部分. 奇怪的双中括号:[[]], 强调了这是<em>内部</em>方法, 被从原声js代码中隐藏了. 你不可以像普通方法一样调用, 删除, 或者重载他们.</p><ul><li><p><strong>obj.[[Get]](key, reciever)</strong> - 获取一个属性的值.</p><p>调用点: <code>obj.prop</code> or <code>obj[key]</code></p><p>obj是正在被搜索的object; <em>receiver</em>是这个object第一个开始搜索的属性. 有时候我们必须搜索一些object. obj可能是<em>receiver</em>原型链上的一个对象.</p></li><li><p><strong>obj.[[Set]](key, value, receiver)</strong> - 为object的属性赋值</p><p>调用点: <code>obj.prop = value</code> or <code>obj[key] = value</code></p><p>当赋值语句为<code>obj.prop += 2</code>, [[Get]]方法会先被调用, 再调用[[Set]]方. <code>++</code>和<code>--</code>也是如此.</p></li><li><p><strong>obj.[[HasProperty]](key)</strong> - 查看属性是否存在</p><p>调用点: <code>key in obj</code></p></li><li><p><strong>obj.[[Enumerate]]()</strong> - 列出obj的可枚举属性.</p><p>调用点: <code>for(key in obj)</code>…</p><p>返回的是一个遍历器对象, 这是为什么<code>for-in</code>循环拿到的是键名.</p></li><li><p><strong>obj.[[GetPrototypeOf]]()</strong> - 返回obj的prototype</p><p>调用点: <code>obj.__proto__</code> or <code>Object.getPrototyoeOf(obj)</code>.</p></li><li><p><strong>functionObj.[[Call]](thisValue, arguments)</strong> - 调用方法</p><p>调用点: <code>functionObj()</code> or <code>x.method()</code></p><p>可选的, 不是每个object都是函数.</p></li><li><p><strong>constructorObj.[[Construct]](arguments, newTarget)</strong> - 调用一个构造器</p><p>调用点: 比如<code>new Date(2890, 6, 2)</code><br>可选的, 因为不是每个object都是构造器.</p><p>newTarget参数是subclassing. 我们以后会讲到.</p></li></ul><p>也许你已经可以猜到另外七个了.</p><p>通过es6标准, 任何一个语法或者内置函数对object的操作某个角度来说都是调用了这14个内部方法. es6在脑内勾画了一个object的轮廓. proxy就是让你可以随意替换这些行为.</p><p>在我们开始讲解重载这些内置方法前, 再重申一遍, 我们重载的是内置方法, 类似于<code>obj.prop</code>, <code>Object.keys()</code>.</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>es6定义了一个新的全局构造器, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>. 他接受2个参数: <em>target object</em>和<em>handler object</em>. 所以以下是一个简单的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;, handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>我们先把handler object稍微放一下, 先来看看proxy和target object的关系.</p><p>我可以告诉你proxy在某行代码中是如何表现的. 所有proxy的内部方法都会forward到一个target上. 也就是, 如果proxy[[Enumerate]]()被调用, 他的返回值为 target.[[Enumerate]]().</p><p> 我们来试一下. 我们来做点会激发proxy的事, [[Set]]()会被调用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy.<span class="property">color</span> = <span class="string">&quot;pink&quot;</span>;</span><br></pre></td></tr></table></figure><p>发生了什么? proxy.[[Set]]()的target.[[Set]]()方法被调用, 所以会在target上创建一个新属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;target.<span class="property">color</span></span><br><span class="line"> <span class="string">&quot;pink&quot;</span></span><br></pre></td></tr></table></figure><p>是的, 和大多数内部方法一样, proxy在大多数情况的行为如同操作了target目标.</p><p>对于这个’幻觉’的真实性还是有一些限制. 你会发现<code>proxy !== target</code>. proxy对象有时候会通不过类型检查. 比如: 即使proxy的target是一个dom元素, 但proxy并不是一个真的dom元素; 例如<code>document.body.appendChild(proxy)</code>的操作会因为<code>TypeError</code>而失败.</p><h2 id="Proxy-handler"><a href="#Proxy-handler" class="headerlink" title="Proxy handler"></a>Proxy handler</h2><p>现在回来说handler object. 这是让proxy有用的东西. </p><p>handler object的方法可以重载任何proxy的内部方法.</p><p>举个例子, 如果你想拦截任何对object属性的赋值, 你可以定义<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set">handler.set()</a>方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Please don&#x27;t set properties on this object.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt; proxy.<span class="property">name</span> = <span class="string">&quot;angelina&quot;</span>;</span><br><span class="line">    <span class="title class_">Error</span>: <span class="title class_">Please</span> don<span class="string">&#x27;t set properties on this object.</span></span><br></pre></td></tr></table></figure><p>handler的所有方法在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object">MDN Proxy文档</a>中. 一共有14个方法, 列出了14个es6的内部方法.</p><p>所有handler的方法都是可选的. 如果一个proxy的handler object没有方法, 那么这个proxy就是直接forward target的, 正如之前所见.</p><h2 id="例子-“不可能的”-自动创建object属性"><a href="#例子-“不可能的”-自动创建object属性" class="headerlink" title="例子: “不可能的” 自动创建object属性"></a>例子: “不可能的” 自动创建object属性</h2><p>我们现在知道了, proxy可以做到没有proxy就做不到的,奇怪的, 不可能的事.</p><p>这是我们的第一个练习. 写一个<code>Tree()</code>函数, 效果如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> tree = <span class="title class_">Tree</span>();</span><br><span class="line">&gt; tree</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&gt; tree.<span class="property">branch1</span>.<span class="property">branch2</span>.<span class="property">twig</span> = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">&gt; tree</span><br><span class="line">    &#123; <span class="attr">branch1</span>: &#123; <span class="attr">branch2</span>: &#123; <span class="attr">twig</span>: <span class="string">&quot;green&quot;</span> &#125; &#125; &#125;</span><br><span class="line">&gt; tree.<span class="property">branch1</span>.<span class="property">branch3</span>.<span class="property">twig</span> = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">    &#123; <span class="attr">branch1</span>: &#123; <span class="attr">branch2</span>: &#123; <span class="attr">twig</span>: <span class="string">&quot;green&quot;</span> &#125;,</span><br><span class="line">                 <span class="attr">branch3</span>: &#123; <span class="attr">twig</span>: <span class="string">&quot;yellow&quot;</span> &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>注意object的中间变量<em>branch1</em>, <em>branch2</em>, <em>branch3</em>是怎么被在需要时创建的. 很方便吧? 那么到底是如何工作的呢.</p><p>之前这么做是不可能的. 但现在有了proxy几行代码就搞定了. 我们只需要对[[Get]]()方法做点修改. 如果你想挑战下那么就在看下去前自己试一下.</p><p><img src="https://hacks.mozilla.org/files/2015/07/maple-tap.jpg" alt="这是一个阻止读者看到下文的图片, 意味不明"></p><p>这是我的答案:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Tree</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> target)) &#123;</span><br><span class="line">      target[key] = <span class="title class_">Tree</span>();  <span class="comment">// auto-create a sub-Tree</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意, 最后调用了<code>Reflect.get()</code>方法. 这能看出这是一个必须做的事, 在proxy的handler方法中, 需要告诉对象”现在返回代表target对象的默认行为”. 所以es6定义了新的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect对象</a>也有14个方法, 都是你需要用的.</p><h2 id="例子-read-only-view"><a href="#例子-read-only-view" class="headerlink" title="例子: read-only view"></a>例子: read-only view</h2><p>我想我可能给了大家错误的印象: proxy很容易用. 让我们再看一个例子来证实是否真的容易.</p><p>这次我们的赋值更复杂点: 我们需要实现一个函数, <code>readOnlyView(object)</code>, 接受一个object然后返回一个proxy行为和输入一样, <em>除了</em>不可以修改他. 举个例子, 他的行为可能如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> newMath = <span class="title function_">readOnlyView</span>(<span class="title class_">Math</span>);</span><br><span class="line">&gt; newMath.<span class="title function_">min</span>(<span class="number">54</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="number">40</span></span><br><span class="line">&gt; newMath.<span class="property">max</span> = <span class="title class_">Math</span>.<span class="property">min</span>;</span><br><span class="line">    <span class="title class_">Error</span>: can<span class="string">&#x27;t modify read-only view</span></span><br><span class="line"><span class="string">&gt; delete newMath.sin;</span></span><br><span class="line"><span class="string">    Error: can&#x27;</span>t modify read-only view</span><br></pre></td></tr></table></figure><p>我们如何去实现他?</p><p>首先我们要把改变目标属性的拦截了, 有五个哟:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NOPE</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;can&#x27;t modify read-only view&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="comment">// Override all five mutating methods.</span></span><br><span class="line">  <span class="attr">set</span>: <span class="variable constant_">NOPE</span>,</span><br><span class="line">  <span class="attr">defineProperty</span>: <span class="variable constant_">NOPE</span>,</span><br><span class="line">  <span class="attr">deleteProperty</span>: <span class="variable constant_">NOPE</span>,</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="variable constant_">NOPE</span>,</span><br><span class="line">  <span class="attr">setPrototypeOf</span>: <span class="variable constant_">NOPE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readOnlyView</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是可以工作的. 通过这个read-only view可以阻止赋值, 属性定义, 等等.</p><p>那么有什么漏洞吗?</p><p>最大的问题就是[[Get]]方法, 或者其他方法, 会返回可编辑的object. 所以即便object<code>x</code>是read-only view, <code>x.prop</code>也是可编辑的! 这是个很大的漏洞.</p><p>要修复他, 我们需要加上<code>handler.get()</code>方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap other results in read-only views.</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// Start by just doing the default behavior.</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure not to return a mutable object!</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>(result) === result) &#123;</span><br><span class="line">      <span class="comment">// result is an object.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">readOnlyView</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// result is a primitive, so already immutable.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这还是不够. 其他的方法也需要这些代码来补充, 比如<code>getPrototypeOf</code>, <code>getOwnPropertyDescriptor</code>.</p><p>然后还有别的问题. 当getter方法被这种proxy调用, 被传入getter的<code>this</code>值将会是proxy本身. 正如我们之前说过的, proxy不能通过类型检测. 我们就需要用target来替换proxy. 你能猜到需要怎么做么?</p><p>来创建一个这样的proxy比较容易, 但要创建一个行为良好的proxy就比较难了.</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p><strong>真正需要proxy的地方</strong></p><p>当你需要观察或记录一个object被读取的情况时很有用. 也就是debug的时候很有用. 测试框架的时候可以用他们来创建<a href="https://en.wikipedia.org/wiki/Mock_object">mock object</a>. </p><p>proxy也在你需要一个普通object稍微改变行为的情况: 比如延迟吐出属性.</p><p>我几乎不想提起这点: 但最好的知道代码运行过程的方式是… 用<em>另一个proxy</em>包装proxy的handler object, 这样可以在每次handler被访问的时候打下log.</p><p>proxy可以用来控制object的读写权限, 正如刚才的例子<code>readOnlyView</code>. 但是这种用法在应用代码中很少, 但火狐使用了proxy来实现不同域名的<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Script_security">安全边界</a>. 这是安全模型的重要部分.</p></li><li><p><strong>proxy ♥ WeakMaps</strong>. 在刚才的<code>readOnlyView</code>例子中, 我们会在object每次被访问时创建一个proxy. 如果在<code>WeakMap</code>中创建proxy对象的话我们可以省下很多内存, 所以无论多少object被应用<code>readOnlyView</code>, 只有一个proxy被创建.</p><p>这也是一个使用<code>WeakMap</code>的地方.</p></li><li><p><strong>Revocable proxy</strong>. es6也定义了一个方法, <code>Proxy.revocable(target, handler)</code>, 这样会创建一个和<code>Proxy(target, handler)</code>创建出的一样的对象, 只是之后可以被<em>revoke</em>.(<code>Proxy.revocable</code>返回一个带有<code>.proxy</code>属性和<code>.revoke</code>方法的对象). 一但proxy被revoke, 他就是不能再工作了; 他所有的方法都没了.</p></li><li><p><strong>object 不变序列</strong>. 在某种情况下, es6需要proxy handler的方法来看出 target的状态. 这样做是为了强制对象的不可编辑, 即使是proxy. 举例, proxy不可以被声明成不可拓展的, 除非他的target是不可拓展的.</p><p>真正的规则在这很难讲清楚, 但如果你看到错误信息类似<code>&quot;proxy can&#39;t report a non-existent property as nonconfigurable&quot;</code>, 就是这种情况. 最像样的解决方案是改变proxy输出自己.</p></li></ul><h2 id="那么现在-什么是object"><a href="#那么现在-什么是object" class="headerlink" title="那么现在: 什么是object?"></a>那么现在: 什么是object?</h2><p>我想我们之前还留下了: “一个object是一些属性的集合”.</p><p>我不是完全赞同这个定义, 即使再加上属性和可调用性. 我觉得”集合”这个词太笼统, 那会给proxy一个多烂的定义. 他的handler方法可以做任何事情.  甚至可以返回随机结果.</p><p>通过猜测object可以做什么, 标准化这些方法, 增加每个人都会用到的虚拟化, es6标准委员会拓展了很大的可能行. </p><p>object现在几乎可以是任何东西.</p><h2 id="我现在可以用Proxy了嘛"><a href="#我现在可以用Proxy了嘛" class="headerlink" title="我现在可以用Proxy了嘛?"></a>我现在可以用Proxy了嘛?</h2><p>不, web上用不了proxy.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 生成器-续</title>
      <link href="/2016/09/10/es6-in-depth-generators-continued/"/>
      <url>/2016/09/10/es6-in-depth-generators-continued/</url>
      
        <content type="html"><![CDATA[<p>上一次我讲了生成器是es6里最有魔性的特性. 我讲了为什么他会是将来的异步编程. 然后我说了:<br>    但我觉得这篇文章已经够长了. 就像生成器一样, 我们也要暂停一下, 然后在以后的时间继续.<br>现在到了这个时间了.</p><p>如果没看过生成器第一篇一定要去看一下.</p><h2 id="快速回顾"><a href="#快速回顾" class="headerlink" title="快速回顾"></a>快速回顾</h2><p>上次我们重点观察了生成器的基本行为. 也许觉得有一点奇怪, 但并不难理解. 一个生成器方法在很大程度上都和普通方法是一样的. 主要的不同在于生成器的方法体中没有一次运行完所有代码. 一开始会运行一点, 然后每次运行到<code>yield</code>表达式的时候会暂停一下.</p><p>在生成器的第一部分已经有了详细的解释, 但我们没有写一个贯穿第一部分的例子, 那现在来做一下.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">someWords</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> word <span class="keyword">of</span> <span class="title function_">someWords</span>()) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一段代码已经够了. 但如果你想知道一切都是如何发生的, 运行的时候所有变量发生了什么, 那么会比较复杂, 会想以下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">SCENE - INTERIOR COMPUTER, DAY</span><br><span class="line"></span><br><span class="line">FOR LOOP stands alone onstage, wearing a hard hat and</span><br><span class="line">carrying a clipboard, all business.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">                         (calling)</span><br><span class="line">                        someWords()!</span><br><span class="line">                              </span><br><span class="line">The GENERATOR appears: a tall, brass, clockwork gentleman.</span><br><span class="line">It looks friendly enough, but it&#x27;s still as a statue.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">               (clapping her hands smartly)</span><br><span class="line">           All right! Let&#x27;s get some stuff done.</span><br><span class="line">                     (to the generator)</span><br><span class="line">                          .next()!</span><br><span class="line"></span><br><span class="line">The GENERATOR springs to life.</span><br><span class="line"></span><br><span class="line">                         GENERATOR</span><br><span class="line">               &#123;value: &quot;hello&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">It freezes in a goofy pose.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">                           alert!</span><br><span class="line"></span><br><span class="line">Enter ALERT at a sprint, wide-eyed and breathless. We sense</span><br><span class="line">he&#x27;s always like that.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">                   Tell the user &quot;hello&quot;.</span><br><span class="line"></span><br><span class="line">ALERT turns around and sprints offstage.</span><br><span class="line"></span><br><span class="line">                           ALERT</span><br><span class="line">                   (offstage, screaming)</span><br><span class="line">                      Stop everything!</span><br><span class="line">          The web page at hacks.mozilla.org says,</span><br><span class="line">                          &quot;hello&quot;!</span><br><span class="line"></span><br><span class="line">A few seconds&#x27; pause, then ALERT races back on, crossing all</span><br><span class="line">the way over to FOR LOOP and skidding to a halt.</span><br><span class="line"></span><br><span class="line">                           ALERT</span><br><span class="line">                     The user says OK.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">               (clapping her hands smartly)</span><br><span class="line">           All right! Let&#x27;s get some stuff done.</span><br><span class="line">              (turning back to the GENERATOR)</span><br><span class="line">                          .next()!</span><br><span class="line"></span><br><span class="line">The GENERATOR again springs to life.</span><br><span class="line"></span><br><span class="line">                         GENERATOR</span><br><span class="line">               &#123;value: &quot;world&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">It freezes in a different goofy pose.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">                           alert!</span><br><span class="line"></span><br><span class="line">                           ALERT</span><br><span class="line">                     (already running)</span><br><span class="line">                           On it!</span><br><span class="line">                   (offstage, screaming)</span><br><span class="line">                      Stop everything!</span><br><span class="line">          The web page at hacks.mozilla.org says,</span><br><span class="line">                          &quot;world&quot;!</span><br><span class="line"></span><br><span class="line">Again, a pause, then ALERT trudges back onstage, suddenly</span><br><span class="line">crestfallen.</span><br><span class="line"></span><br><span class="line">                           ALERT</span><br><span class="line">               The user says OK again, but...</span><br><span class="line">             but please prevent this page from</span><br><span class="line">               creating additional dialogues.</span><br><span class="line"></span><br><span class="line">He exits, pouting.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">               (clapping her hands smartly)</span><br><span class="line">           All right! Let&#x27;s get some stuff done.</span><br><span class="line">              (turning back to the GENERATOR)</span><br><span class="line">                          .next()!</span><br><span class="line"></span><br><span class="line">The GENERATOR springs to life a third time.</span><br><span class="line"></span><br><span class="line">                         GENERATOR</span><br><span class="line">                       (with dignity)</span><br><span class="line">               &#123;value: undefined, done: true&#125;</span><br><span class="line"></span><br><span class="line">Its head comes to rest on its chest and the lights go out of</span><br><span class="line">its eyes. It will never move again.</span><br><span class="line"></span><br><span class="line">                          FOR LOOP</span><br><span class="line">                  Time for my lunch break.</span><br><span class="line"></span><br><span class="line">She exits.</span><br><span class="line"></span><br><span class="line">After a while, the GARBAGE COLLECTOR enters, picks up the</span><br><span class="line">lifeless GENERATOR, and carries it offstage.</span><br></pre></td></tr></table></figure><p>好~ 以上的东西并不哈姆雷特, 但你知道了个大概了.</p><p>正如你看到的, 生成器对象最先出现后就暂停了. 当<code>.next()</code>方法调用后会被唤醒再运行一小段.</p><p>这个行为是同步并且单线程的. 注意到实际上只有一个线程在工作. 也就是不同生成器不会打断或者参与互相的工作. 他们互相独立工作, 互不影响.(就像莎士比亚一样)</p><p>在一些情况下生成器是为<code>for-of</code>循环工作的. 会由一些代码顺序地调用<code>.next()</code>方法, 即使你没有在代码中写. 我的代码中显性调用了, 但你的程序里不需要主动调用, 而可以使用<code>for-of</code>循环, 因为他本身设定就是和生成器一起工作的, 通过<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-iterator-interface">iterator接口</a>.</p><p>总结一下:</p><ul><li>   生成器对象是一个yield出值的机器人.<br>  +每个机器人的制造都包括一段简单的代码: 生成器代码的方法体.</li></ul><h2 id="怎么关闭一个生成器"><a href="#怎么关闭一个生成器" class="headerlink" title="怎么关闭一个生成器"></a>怎么关闭一个生成器</h2><p>生成器有一些比较繁琐的额外的特性, 这些我没有在第一部分中提到:</p><ul><li>   <code>generator.return()</code><br>  +<code>generator.next()</code>的可选参数<br>  +<code>generator.throw(error)</code><br>  +<code>yield*</code></li></ul><p>我跳过了他们是因为如果不知道这些特性为什么存在就很难去注意他们, 更难让他们在你脑子里留下印象. 而我们已经更多的在向我们的程序里去怎么使用生成器了, 我们来看下原因. </p><p>以下是一些你可能在某个场景写的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doThings</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">setup</span>();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... do some things ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doThings</span>();</span><br></pre></td></tr></table></figure><p>其中cleanup方法可能会去关闭一些连接或者文件, 来释放系统资源, 或者只是更新dom匀速来关闭他的’正在更新’的标志. 我们希望这些动作在代码的最后执行, 无论是否成功, 所以这些代码写在了<code>finally</code>块中.</p><p>如果用生成器写会是什么样的呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">produceValues</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">setup</span>();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... yield some values ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">produceValues</span>()) &#123;</span><br><span class="line">  <span class="title function_">work</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来没有问题, 但这有个小问题: <code>work(value)</code>的调用不在<code>try</code>块中. 如果这里抛出了异常, 那cleanup的步骤会发生什么呢?</p><p>或者假设<code>for-of</code>循环存在<code>break</code>或者<code>return</code>语句. 那么会对于cleanup步骤有什么影响呢?</p><p>es6支持着你, 所以随便如何(finally)都会执行.</p><p>当我们刚开始讨论遍历器与<code>for-of</code>循环的时候, 我们说到了遍历器接口有一个可选项<code>.return()</code>方法, 这个方法语言会在遍历器存在且表明遍历结束的时候自动调用. 生成器是支持这个方法的. 调用<code>myGenerator.return()</code>会使生成器运行<code>finally</code>块并且退出, 感觉就像是当前的<code>yield</code>语句被秘密地变成了<code>return</code>语句.</p><p>这个特性在使用中是如何表现的呢? 生成器会在任务中暂停需要一些步骤, 就像造一个大楼. 突然地一个人抛出了个错误! <code>for</code>循环捕捉到了错误并把它放在一边. 告诉生成器去执行<code>.return()</code>. 生成器不紧地拆除了所有脚手架并停止了工作. 当<code>for</code>循环的错误堆积, 那么普通的错误处理讲会继续.</p><h2 id="生成器的作用"><a href="#生成器的作用" class="headerlink" title="生成器的作用"></a>生成器的作用</h2><p>直到现在, 我们讲到的生成器与他的用户的事情还都是单方面的, 就像以下的场景:</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/generator-messages-small.png" alt="图意为单方面调用-相应的生成器"></p><p>用户发起请求, 生成器来回复需求. 但这不是生成器编程的唯一方式.</p><p>在第一部分, 我说过生成器可以被用作异步编程. 你现在使用回调或者promise做的事也许可以用生成器来代替的. 你可能会问那么他会是如何工作的呢. 他是如何yield(毕竟他是生成器唯一特殊的东西)满足需求的呢? 原来, 异步编程带啊不只是依靠yield. 需要做一些别的事. 他需要从文件或数据库中来的数据. 他的激活依靠服务器与请求. 然后回到事件的循环中来等待异步操作完成. 那生成器具体做了什么呢? 不适用回调, 生成器如何知道从文件的数据读到, 或是服务器给了响应呢?</p><p>开始前, 我们先想想看, 如果调用<code>.next()</code>的时候传入一些参数, 只通过这个改变, 我们会得到一个全新的对话:</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/07/generator-messages-2-small.png" alt="在next方法中带着参数, 生成器返回了不同的东西"></p><p>并且生成器的<code>.next()</code>方法确实使用了一些可选的参数, 通过<code>yield</code>返回了不同的结果. 因为<code>yield</code>不是像<code>return</code>一样的语句, 他可以接受参数, 只要生成器中写了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var results = yield getDataAndLatte(request.areaCode);</span><br></pre></td></tr></table></figure><p>这句代码做了很多事:</p><ul><li>调用了<code>getDataAndLatte()</code>. 我们看到了方法返回的字符串<code>&quot;get me the database records for area code…&quot;</code>正如上面截图看到的.</li><li>暂停了生成器, yield了一个字符串</li><li>在这个时间点, 随便可以暂停多久.</li><li>最后, 有人调用了<code>.next(&#123;data:…, coffee:…&#125;)</code>. 我们在本地变量中保存了<code>results</code>再继续运行下一行代码.</li></ul><p>想看上下文的话, 下面是对话的所有代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">handle</span>(<span class="params">request</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">yield</span> <span class="title function_">getDataAndLatte</span>(request.<span class="property">areaCode</span>);</span><br><span class="line">  results.<span class="property">coffee</span>.<span class="title function_">drink</span>();</span><br><span class="line">  <span class="keyword">var</span> target = <span class="title function_">mostUrgentRecord</span>(results.<span class="property">data</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">updateStatus</span>(target.<span class="property">id</span>, <span class="string">&quot;ready&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>yield</code>的意义仍然和我之前说过的一样: 暂停生成器并且给调用者返回一个值.  那么这些东西是如何变化的呢? 这个生成器期望他的调用者支持一些指定的行为. 看起来就像希望调用者是个行政助理的角色.</p><p>普通的方法就和这样的不同. 他们需要为了调用者的需求必须自己存在. 但生成器是一种你可以与他对话的代码, 这样就让生成器和他的调用者有发生更多关系的可能.</p><p>那么这个生成器运行的行政助手看起来是什么样的呢? 不需要很复杂, 可以如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runGeneratorOnce</span>(<span class="params">g, result</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> status = g.<span class="title function_">next</span>(result);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="property">done</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// phew!</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The generator has asked us to fetch something and</span></span><br><span class="line">  <span class="comment">// call it back when we&#x27;re done.</span></span><br><span class="line">  <span class="title function_">doAsynchronousWorkIncludingEspressoMachineOperations</span>(</span><br><span class="line">    status.<span class="property">value</span>,</span><br><span class="line">    <span class="function">(<span class="params">error, nextResult</span>) =&gt;</span> <span class="title function_">runGeneratorOnce</span>(g, nextResult));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们想要创建一个生成器并运行他一次, 像这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">runGeneratorOnce</span>(<span class="title function_">handle</span>(request), <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>上次我提到了<code>Q.async()</code>是一个lib实现的把生成器作为异步编程. <code>runGeneratorOnce</code>就是其中的一种. 实际中, 生成器并不会yield字符串, 可能会yield<code>promise</code>对象.</p><p>如果你已经理解了promise, 那么你也理解生成器了, 也许你已经想改写一下<code>runGeneratorOnce</code>来支持promise了. 做起来比较难, 但一旦你实现了, 你就可以写出复杂的使用平直的代码的promise, 而不是<code>.then()</code>或者回调的异步算法了.</p><h2 id="如何扩展一个生成器"><a href="#如何扩展一个生成器" class="headerlink" title="如何扩展一个生成器"></a>如何扩展一个生成器</h2><p>你有注意<code>runGeneratorOnce</code>是如何处理错误的吗? 错误被忽略了!</p><p>好, 这并不好. 我们应该是希望生成器可以正常报错的. 并且生成器也支持: 你可以使用<code>generator.throw(error)</code>而不是<code>generator.next(result)</code>. 这会导致<code>yield</code>语句的地方来抛出, 和<code>.return()</code>一样, 生成器也会被终止. 但如果yield的点实在<code>try</code>块里, 并且<code>catch</code>与<code>finally</code>块都存在, 那么生成器可能会恢复运行.</p><p>修改<code>runGeneratorOnce</code>来保证<code>.throw()</code>被正确调用也是一个比较难的事. 要记得生成器中的异常抛出都要被传播到调用者上. 所以<code>generator.throw(error)</code>只能抛出被生成器捕获的异常!</p><p>以下是生成器到达<code>yield</code>表达式而暂停的可能情况的集合:</p><ul><li>有人调用了<code>generator.next(valu)</code>, 这个情况中, 生成器会继续执行到剩下的部分.</li><li>有人调用了<code>generator.return()</code>, 也可能传入了参数. 在这个情况中, 生成器不会做任何继续执行的动作, 只会去执行<code>finally</code>块中的代码.</li><li>有人调用了<code>generator.throw(error)</code>.  生成器会与做<code>yield</code>一样的行为并调用抛出<code>error</code>的方法.</li><li>或者有人什么都没有做. 生成器也许会永远暂停. (是的, 也有可能生成器永远停在<code>try</code>块中而永远不会执行<code>finally</code>块, 这样的生成器也可以被垃圾回收机制回收.)</li></ul><p>这不比解释一个老式到达方法调用麻烦. 只是, <code>.return()</code>真的是一个新的可能性.</p><p>事实上, <code>yield</code>与方法调用有许多相同处. 你调用了一个方法后, 你其实也是暂停了, 不是吗? 一个方法调用可以控制, 他可以return, 也可以throw, 或者也可以永远循环下去.</p><h2 id="生成器一起工作"><a href="#生成器一起工作" class="headerlink" title="生成器一起工作"></a>生成器一起工作</h2><p>让我给你看另一个特性.假设我写了一个生成器把两个可遍历对象联系起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es6提供了一个简写的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通的<code>yield</code>表达式yield一个值, <code>yield*</code>表达式会消费整个遍历器并yield所有值.</p><p>这样的语法也解决了其他有趣的问题: 如何在生成器中调用另一个生成器. 在普通方法中, 我们可以把一个方法的一串代码分开到几个方法中, 并不改变他的行为. 显然我们也希望生成器可以这样做. <code>yield*</code>解决了这个问题.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">factoredOutChunkOfCode</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">refactoredFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">factoredOutChunkOfCode</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想一想一个机器人流畅的一个个完成任务. 你可以知道用生成器为基础的项目来保持代码整洁, 组织性有多重要.</p><h2 id="退场"><a href="#退场" class="headerlink" title="退场"></a>退场</h2><p>好了, 这就是生成器的全部内容! 下周我们将讨论es6的proxies.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 集合</title>
      <link href="/2016/09/10/es6-in-depth-collections/"/>
      <url>/2016/09/10/es6-in-depth-collections/</url>
      
        <content type="html"><![CDATA[<p>es6的声明, 官方title为ECMA-262, 第六个版本, ECMAScript2015语言声明, 已经被最后确定并作为ECMA标准. 恭喜TC39和所有贡献的朋友们! es6已经转正了!</p><p>更好的消息: 下个新版本将不会再需要6年, 标准委员会现在目标是大约每一年左右发布一个新版本. <a href="https://github.com/tc39/ecma262">es7提案</a>已经在发展中了.</p><p>最后很合适的引入今天要讨论的东西. 这个我很早就希望js拥有的特性, 并且我仍觉得这个特性在未来有提升空间.</p><h2 id="共同进化的难点"><a href="#共同进化的难点" class="headerlink" title="共同进化的难点"></a>共同进化的难点</h2><p>js与其他语言很不相像, 这个特点有时候对js的进化产生了奇妙的影响.</p><p>es6的module就是一个很好的例子. 别的语言有自己的模块系统. racket就由一个很好的, python也有. 当标准委员会决定为es6加上一个模块系统, 为什么不直接拷贝现有的系统呢?</p><p>js背景与那些语言不同的. 因为他还需要在浏览器中运行. I&#x2F;O会占用很多时间. 所以js需要一个可以支持异步加载代码的模块系统. 但也做不到从一些文件夹里顺序地搜索模块. 拷贝现有的系统行不通. es6模块需要一些新的东西的.</p><p>这是如何影响最后设计会是一个有意思的故事. 但我们现在先不展开模块的事.</p><p>本文会讲一下es6标准中的’带键集合’:<code>Set</code>,<code>Map</code>,<code>WeakSet</code>, 和<code>WeakMap</code>. 这个特性从很多角度来看就像是别的语言中的<a href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a>. 但标准委员会也做了一些有意思的平衡, 因为js与众不同.</p><h2 id="为什么需要集合"><a href="#为什么需要集合" class="headerlink" title="为什么需要集合?"></a>为什么需要集合?</h2><p>任何熟悉js的人都知道js已经有类似hash table的东西内置在语言里: 对象.</p><p>一个普通的<code>Object</code>毕竟是一个比较开放式键值对的集合. 你可以设置, 获取, 和删除属性, 遍历他们-hash table可以做的所有事. 所以为什么要去添加一个新特性呢?</p><p>好, 许多程序员用普通对象来保存键值对, 并且工作得很顺利, 并没有什么理由去使用<code>Map</code>或者<code>Set</code>. 好的, 那么我来说一下一些著名的使用对象的问题吧:</p><ul><li>   作为键值储存表的对象不能有方法, 因为避免冲撞的发生.</li><li>   所以程序员必须使用<code>Object.create(null)</code>(而不是普<code>&#123;&#125;</code>)或者特别注意来避免把内置的方法(比如<code>Object.prototype.toString</code>)也读成数据.</li><li>   键只能是字符串(或者es6的symbol). 对象不可以为键.</li><li>   没有高效率的方法来查询对象有多少属性.</li></ul><p>es6也多了一个新的担心: 普通的对象是不可遍历的, 所以他们不能与<code>for-of</code>循环, <code>...</code>操作符等良好配合.</p><p>重复一下, 现在有很多程序员没有真正碰到什么问题, 所以普通的对象还是在被选择使用. <code>Map</code>和<code>Set</code>被用在另外一些情况下.</p><p>因为他们是被设计用来避免用户数据和内置方法冲撞的, es6的集合<em>不会把自己的数据暴露为属性</em>. 这意味着类似<code>obj.key</code>或者<code>obj[key]</code>这样的表达式不能被用来获取hash table的数据了. 你必须写<code>map.get(key)</code>. 同样的, hash table的创建也不像属性, <em>不会</em>继承原型链.</p><p>好的方面是, 与普通的<code>Object</code>不同, <code>Map</code>和<code>Set</code>拥有方法, 也可以被添加更多的方法, 甚至在某个标准下, 或者你自己的类下, 不会有冲突.</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h2><p><code>Set</code>是一个值的集合. 是可变的, 所以你的程序可以增加和删除其中的值. 直到这里, 他还只是像一个数组. 但虽然有一些相同点, set和array的区别还是有很多的.</p><p>首先, 不同于array, set不会存在相同的值. 如果你给set添加了相同的值, 什么都不会发生.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> desserts = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;🍪🍦🍧🍩&quot;</span>);</span><br><span class="line">&gt; desserts.<span class="property">size</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&gt; desserts.<span class="title function_">add</span>(<span class="string">&quot;🍪&quot;</span>);</span><br><span class="line">    <span class="title class_">Set</span> [ <span class="string">&quot;🍪&quot;</span>, <span class="string">&quot;🍦&quot;</span>, <span class="string">&quot;🍧&quot;</span>, <span class="string">&quot;🍩&quot;</span> ]</span><br><span class="line">&gt; desserts.<span class="property">size</span></span><br><span class="line">    <span class="number">4</span></span><br></pre></td></tr></table></figure><p>以上例子用了字符串, 但<code>Set</code>可以包含任何类型的js值. 和字符串一样, 添加任何相同的对象, 数组多次都是无效的.</p><p>第二, <code>Set</code>会维护好内部的数据来使寻找成员更快.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// Check whether &quot;zythum&quot; is a word.</span></span><br><span class="line">&gt; arrayOfWords.<span class="title function_">indexOf</span>(<span class="string">&quot;zythum&quot;</span>) !== -<span class="number">1</span>  <span class="comment">// slow</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&gt; setOfWords.<span class="title function_">has</span>(<span class="string">&quot;zythum&quot;</span>)               <span class="comment">// fast</span></span><br><span class="line">    <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>你不能从索引获得<code>Set</code>的值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; arrayOfWords[<span class="number">15000</span>]</span><br><span class="line">    <span class="string">&quot;anapanapa&quot;</span></span><br><span class="line">&gt; setOfWords[<span class="number">15000</span>]   <span class="comment">// sets don&#x27;t support indexing</span></span><br><span class="line">    <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>以下是所有set的操作:</p><ul><li><p><code>new Set</code>来创建一个新的空set</p></li><li><p><code>new Set(iterable)</code>创建一个新的set并且遍历参数来填充数据</p></li><li><p><code>set.size</code>返回set的个数</p></li><li><p><code>set.has(value)</code>如果给set包含value就返回&#96;true&#96;&#96;</p></li><li><p><code>set.add(value)</code>为set添加一个value, 如果value已经存在什么都不做</p></li><li><p><code>set.delete(value)</code>从set删除一个value. 如果value本身不存在, 什么也不做. <code>.add()</code>和<code>.delete()</code>都会返回他本身, 所以你可以做连式操作.</p></li><li><p><code>set[Symbol.iterator]()</code>返回一个包含set数据的遍历器. 你一般不需要直接着么调用它, 但这样可以告诉你你是怎么遍历set的. 所以你可以直接写<code>for(v of set)</code>来遍历.</p></li><li><p><code>set.forEach(f)</code>用代码来解释最方便, 他是以下的简写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set)</span><br><span class="line"> <span class="title function_">f</span>(value, value, set);</span><br></pre></td></tr></table></figure><p> 这个方法与数组的<code>.forEach()</code>差不多.</p></li><li><p><code>set.clear()</code>移除set的所有数据.</p></li><li><p><code>set.keys()</code>,<code>set.values()</code>和<code>set.entries()</code>返回各自的遍历器. 这些是为了和<code>Map</code>良好配合, 我们下面会讲.</p></li></ul><p>以上这些特性中, 构造器<code>new Set(iterable)</code>是最强大的, 因为他操作了数据结构的层次. 你可以把一个array转为一个set, 只用一行代码就做了去重. 或者给他写一个生成器: 之后就可以按照你的意愿来遍历这个set. 构造器也是你可以拷贝现有<code>Set</code>的一个方法.<br>​<br>我上周说好我会讲一下es6的新集合, 我们已经开始了, 虽然<code>Set</code>已经很厉害了, 还是有一些希望在以后的标准里被添加的新特性:</p><ul><li>   一些功能性的辅助函数, 就像现在已经存在于array的<code>.map()</code>, <code>.filter()</code>, <code>.some()</code>和<code>.every()</code>.</li><li>   同样的<code>set1.union(set2)</code>和<code>set1.intersection(set2)</code></li><li>   一些可以一次就操作一批值的方法:<code>set.addAll(iterable)</code>, <code>set.removeAll(iterable)</code>, 和<code>set.hasAll(iterable)</code>.</li></ul><p>好的方面是, 以上这些都可以用es6提供的方法很快的自己实现.</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p><code>Map</code>是键值对的集合, 以下是<code>Map</code>可以做的事:</p><ul><li><code>new Map</code>返回一个新的空map.</li><li><code>new Map(pairs)</code>创建一个新的map并用现有的<code>[key, value]</code>对来填充数据. <em>pairs</em>可以是已经存在的<code>Map</code>对象, 或者是一个有2个元素的数组组成的数组, 或者是一个每次yield一个2个元素的数组的生成器, 等等</li><li><code>map.size</code>获得map的数据的个数.</li><li><code>map.has(key)</code>匹配存在的key(类似<code>key in obj</code>)</li><li><code>map.get(key)</code>获得到key对应的值, 如果没有对应的就返回undefined(类似<code>obj[key]</code>).</li><li><code>map.set(key, value)</code>添加关联的键值对, 并且会覆盖已经存在的(类似<code>obj[key] = value</code>).</li><li><code>map.delete(key)</code>删除一个数据(类似<code>delete obj[key]</code>).</li><li><code>map.clear()</code>移除map的所有属性.</li><li><code>map[Symbol.iterator]()</code>返回一个map属性的遍历器. 遍历器每次会吐出类似<code>[key, value]</code>的数组.</li><li><code>map.forEach(f)</code>等价于:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map)</span><br><span class="line"><span class="title function_">f</span>(value, key, map);</span><br></pre></td></tr></table></figure><pre><code>这个比较奇怪的参数是因为它类似于`Array.prototype.forEach()`.</code></pre></li><li><code>map.keys()</code>返回一个包含map中所有key的遍历器.</li><li><code>map.values()</code>返回一个包含map中所有值的遍历器.</li><li><code>map.entries()</code>返回一个包含map中所有key value的遍历器. 和调用<code>map[Symbol.iterator]()</code>的结果一样. 实际上本来就是同一个方法的不同调用方式.</li></ul><p>然后我要开始抱怨一下了, 以下是我觉得有用但是没有在es6标准里实现的功能:</p><ul><li>   一个默认值的机制, 类似Python的<a href="https://docs.python.org/3/library/collections.html#defaultdict-examples">collections.defaultdict</a>.</li><li>一个有用的方法, <code>Map.fromObject(obj)</code>, 这样可以轻松的用写对象的语法来构造map.</li></ul><p>同样的, 这些特性也很容易添加的.</p><p>好, 记得文章开头说的需要在浏览器中运行导致js语言设计的特殊性吗? 这是我们开始话题的地方. 现在我有三个例子, 下面是前两个.</p><h2 id="js与其他语言不同处1-没有hash-code的hash-table"><a href="#js与其他语言不同处1-没有hash-code的hash-table" class="headerlink" title="js与其他语言不同处1: 没有hash code的hash table?"></a>js与其他语言不同处1: 没有hash code的hash table?</h2><p>有一个有用的特性es6的集合一直没有支持.</p><p>假设我有一个<a href="https://url.spec.whatwg.org/">URL对象</a>的<code>Set</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = <span class="keyword">new</span> <span class="title class_">Set</span>;</span><br><span class="line">urls.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(location.<span class="property">href</span>));  <span class="comment">// two URL objects.</span></span><br><span class="line">urls.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(location.<span class="property">href</span>));  <span class="comment">// are they the same?</span></span><br><span class="line"><span class="title function_">alert</span>(urls.<span class="property">size</span>);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这2个URL对象真的需要被认为是一样的. 他们的一切都相同. 但是在javascript中这两个对象是不同的, 我们也没有办法重写语言判断是否相等的逻辑.</p><p>其他的语言是支持这样做的, 在Java, Python和Ruby里, 独立的类可以重写相等的规则. 在许多计划的实行里, 独立的hash table可以使用不同的相等策略. C++全都支持.</p><p>但是, 所有这些机制都需要用户去实现自定义的hash函数和系统默认的hash函数. 委员会选择不暴露js的hash code, 至少是现在还没-因为担心互相操作和安全性, 其他的语言没有这个顾虑.</p><h2 id="js与其他语言不同处2-天呐-可预测性"><a href="#js与其他语言不同处2-天呐-可预测性" class="headerlink" title="js与其他语言不同处2: 天呐! 可预测性!"></a>js与其他语言不同处2: 天呐! 可预测性!</h2><p>我可能觉得计算机的行为是可预见的一点不奇怪. 但是当我告诉别人<code>Map</code>和<code>Set</code>访问属性的顺序是他们被插入的顺序大家都由点惊讶呢.</p><p>我们已经习惯了hash table的顺序是随意的. 我们已经慢慢接受了这个设定. 但有一些办法可以避免这种随机性. </p><ul><li>   一开始一些程序员觉得随机的遍历顺序很奇怪.<a href="http://stackoverflow.com/questions/2453624/unsort-hashtable">1</a>,<a href="http://stackoverflow.com/questions/1872329/storing-python-dictionary-entries-in-the-order-they-are-pushed">2</a>,<a href="https://groups.google.com/group/comp.lang.python/browse_thread/thread/15f3b4a5cd6221b1/1b6621daf5d78d73">3</a>,<a href="http://bytes.com/topic/c-sharp/answers/439203-hashtable-items-order">4</a>,<a href="http://stackoverflow.com/questions/1419708/how-to-keep-the-order-of-elements-in-hashtable">5</a>,<a href="http://stackoverflow.com/questions/7105540/hashtable-values-reordered">6</a><br>  +ECMAScript并没有指定属性的枚举顺序, 而大多数实现都是强制为插入的顺序, 为了和web的做法达成一致. 所以有一些担忧就是TC39没有指定遍历的顺序, 这样每个web可能会自己指定顺序.<a href="https://mail.mozilla.org/pipermail/es-discuss/2012-February/020576.html">7</a><br>  +hash table遍历顺序可以暴露一些对象的hash code. 这让牵扯hash的函数实现有了比较大的安全问题. 比如, 一个对象的地址不能因为被暴露了hash code而可回收.(给非可信任的js代码暴露了对象的地址, 自己又并不需要使用, 这样增加了web上的安全漏洞)</li></ul><p>这些我已经在2012年的2月讨论过了, 我讨论过了<a href="https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables">遍历器的随机顺序的问题</a>. 然后我开始尝试用实验来证明要保持追踪插入的顺序使hash table的速度变得太慢. 我写了一个C++的小标准, <a href="https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables">结果让我震惊</a>.</p><p>这就是为什么我们的js最后选择了检测着插入顺序.</p><h2 id="一千个使用弱集合的理由"><a href="#一千个使用弱集合的理由" class="headerlink" title="一千个使用弱集合的理由"></a>一千个使用弱集合的理由</h2><p>symbol那篇文章, 我们讲了一个关于动画lib的js例子. 我们想要为每个dom元素来设置一个flag, 以下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">isMoving</span>) &#123;</span><br><span class="line">  <span class="title function_">smoothAnimations</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">element.<span class="property">isMoving</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>不幸的是在dom对象上加一个拓展属性好像是个坏主意, 我们在上篇文章有讲过.</p><p>那篇文章说了用symbol解决问题的方法. 那我们可不可以用<code>Set</code>来解决呢? 可能是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (movingSet.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">  <span class="title function_">smoothAnimations</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">movingSet.<span class="title function_">add</span>(element);</span><br></pre></td></tr></table></figure><p>这么做的话有一个唯一的缺点: <code>Map</code>和<code>Set</code>对象维护着他们内部的每一个键的关系. 这意味着如果dom元素被移除了document以后, 垃圾回收机制直到这个元素被移出<code>movingSet</code>前都不能回收这个内存. 当然lib一般都会有综合性的成功处理, 用户只能被强制自己做这个操作. 着么做也可能导致内存泄露.</p><p>es6有一个很惊人的对这个问题的修复. 把<code>movingSet</code>设置为<code>WeakSet</code>而不是<code>Set</code>. 内存泄露就解决了!</p><p>那这意味着解决这个问题可以用弱集合或者是symbol, 到底哪个更好呢? 完整的对于权衡的讨论可能会让这篇文章太长了. 如果你可以在整个web应用的生命周期里只用一个symbol, 那么用symbol好. 如果你希望用生命周期比较短的symbol, 那么这是一个危险的信号: 所以就考虑使用<code>WeakMap</code>来防止内存泄露.</p><h2 id="WeakMap和WeakSet"><a href="#WeakMap和WeakSet" class="headerlink" title="WeakMap和WeakSet"></a><code>WeakMap</code>和<code>WeakSet</code></h2><p><code>WeakMap</code>和<code>WeakSet</code>的表现行为就类似<code>Map</code>和<code>Set</code>, 但有以下几点限制:</p><ul><li>   <code>WeakMap</code>只支持<code>new</code>, <code>.has()</code>, <code>.get()</code>, <code>set()</code>, 和<code>.delete()</code>.</li><li><code>WeakSet</code>只支持<code>new</code>, <code>.has()</code>, <code>.add()</code>, 和<code>.delete()</code>.</li><li>在<code>WeakSet</code>中的值和<code>WeakMap</code>中的键必须是对象.</li></ul><p>注意任何类型的弱集合都是可遍历的. 除非你传入你指定的键, 其他情况你是得不到弱集合的属性的.</p><p>这些仔细设计的限制使垃圾回收机制可以收集到激活状态的集合中的已经不需要的对象. 效果就类似你可以通过弱索引或者弱键词典来找到东西, 但es6的弱集合有益于内存管理<em>并不需要脚本知道垃圾回收原理并用代码做操作</em>.</p><h2 id="js与其他语言的不同处3-隐藏垃圾回收机制的不确定性"><a href="#js与其他语言的不同处3-隐藏垃圾回收机制的不确定性" class="headerlink" title="js与其他语言的不同处3: 隐藏垃圾回收机制的不确定性"></a>js与其他语言的不同处3: 隐藏垃圾回收机制的不确定性</h2><p>通过以上的场景, 我们知道了弱集合是一种<a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak/jucs_14_21_3481_3497_barros.pdf">短声明中期table</a>的实现.</p><p>简而言之, <code>WeakSet</code>没有维护内部对象的强关系. 当一个<code>WeakSet</code>内的对象被采集, 他被很轻松地移出了<code>WeakSet</code>. <code>WeakMap</code>也是类似的. 都没有维护键值的强关系. 只要键存在, 那对应的值就存在.</p><p>为什么要添加这些限制? 为什么不直接在js中增加一种弱关系?</p><p>再说一次, 标准委员会非常不愿意把一些不可确定的行为暴露给脚本. 很差的跨浏览器兼容性是web开发的噩梦. 弱关系暴露了底层垃圾回收机制的实现-也正是’平台相关’的随意性行为. 当然应用不应该是依赖’平台相关’细节的, 但弱关系也让我们很难知道到底我们正在使用多少’平台相关’的垃圾回收机制. 我们很难去搞清原因.</p><p>对比来看, es6的弱集合是由一些限制特征的集合, 而且集合的特征很明显. 被采集以后的键值永远不会被发现, 所以应用不能着么使用他, 即使偶尔会发现.</p><p>这是一个由浏览器特性的问题导致的惊人的语法设计而使js成为了更好的语言的案例.</p><h2 id="如何在代码中使用集合"><a href="#如何在代码中使用集合" class="headerlink" title="如何在代码中使用集合?"></a>如何在代码中使用集合?</h2><p>许多现代浏览器都可以.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth symbols</title>
      <link href="/2016/09/10/es6-in-depth-symbols/"/>
      <url>/2016/09/10/es6-in-depth-symbols/</url>
      
        <content type="html"><![CDATA[<p>什么是es6 symbols?<br>symbols不是符号.<br>不是在你代码中的小图片.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 😻 = 😺 × 😍;  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><p>也不是别的什么.</p><h2 id="七个类型"><a href="#七个类型" class="headerlink" title="七个类型"></a>七个类型</h2><p>从javascript在1997年被标准化开始就又了6个类型. es6前, 每个js的值都可以被归类到下面几个种类里.</p><ul><li>   Undefined</li><li>   Null</li><li>   Boolean</li><li>   Number</li><li>   String</li><li>   Object</li></ul><p>每个类型都有一个值的集合. 前5个集合都是有限的. 比如说, 当然的事, Boolean只有2个值, <code>true</code>和<code>false</code>, 并且也不会再有新的了. Number和String的话会有更多的值. 在标准里Number类型有18,437,736,874,454,810,627 个值(包括<code>NaN</code>, “Not a Number”的简写). 和不同的String的值就没什么好比的了, 我想我没数错的话可能有(2^144,115,188,075,855,872 − 1) ÷ 65,535个.</p><p>但是Object的值就是开放的了. 每个Object都是唯一的, 像珍贵的雪花. 每当你打开一个页面, 一批新的Object就被创建了.</p><p>es6的symbol也是一个值, 但他不是String也不是Object, 他是一个新的东西, 第七个类型.</p><p>好拉, 接下来让我们说一下他的应用场景吧.</p><h2 id="保存一个小小的布尔值"><a href="#保存一个小小的布尔值" class="headerlink" title="保存一个小小的布尔值"></a>保存一个小小的布尔值</h2><p>有时候给js对象上藏一个实际是别的地方的额外的数据是相当容易的.</p><p>大哥比方, 假设你在用css transision来写一个让dom元素在页面上移动的js lib. 你注意到了对一个<code>div</code>同时多个操作是不能达到预期的. 会导致丑陋的不连续的跳动. 你觉得你可以修复这个问题, 但你首先需要一个方法指导当前的元素是否在移动.</p><p>我们怎么处理这个问题呢?</p><p>一个方法是调用css的api来请求浏览器得知元素是否在移动. 但这样看起来太费周章了. 你的lib最好是已经可以知道那个元素是否在移动, 应该用代码第一时间把他设为移动的状态!</p><p>你真正想做到的是保持追踪元素的移动状态. 你可以做一个数组来存放所有元素的状态, 每次你的lib调用元素的时候去检查一下这个数组.</p><p>啊哈, 如果数组很大的话线性的搜索又会非常慢.</p><p>你真正想做的是在元素上设定一个flag:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">isMoving</span>) &#123;</span><br><span class="line">  <span class="title function_">smoothAnimations</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">element.<span class="property">isMoving</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这样做也存在一些潜在的问题. 这些问题有关于不止同一份代码在操作这些dom.</p><ol><li>   别的代码使用<code>for-in</code>或者<code>Object.keys()</code>的时候会被你创建的属性影响.</li><li>   一些别的厉害的lib作者可能已经想过了解决方案, 而你的lib会对现有的lib有不好的作用.</li><li>   一些厉害的lib作者可能将来会向怎么处理, 而你的lib会对将来的lib有不好的作用.</li><li>   标准委员会决定增加一个<code>.isMoving()</code>方法到所有的元素里, 而你已经先占用了.</li></ol><p>当然你也可以用过把属性名设为很长很傻以致没人会想用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__</span>) &#123;</span><br><span class="line">  <span class="title function_">smoothAnimations</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">element.<span class="property">__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这个属性让人眼都看瞎了.</p><p>你也可以通过密码学来产生一个唯一的属性名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get 1024 Unicode characters of gibberish</span></span><br><span class="line"><span class="keyword">var</span> isMoving = <span class="title class_">SecureRandom</span>.<span class="title function_">generateName</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element[isMoving]) &#123;</span><br><span class="line">  <span class="title function_">smoothAnimations</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">element[isMoving] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><code>object[name]</code>这种语法让你可以把任何字符串作为一个属性名. 这样是可以正常工作的, 实际中几乎不可能碰撞, 你的代码看起来也是OK的.</p><p>但这样会导致很差的debug体验. 每次你用<code>console.log()</code>的时候都会看到一长串东西. 而且如果你需要更多的属性呢? 你怎么能正确的维护他们? 你每次重新加载的时候会变成不同的名字.</p><p>这真的那么难吗? 我们只是要保存一个小小的布尔值!</p><h2 id="答案是Symbol"><a href="#答案是Symbol" class="headerlink" title="答案是Symbol"></a>答案是Symbol</h2><p>Symbol是可以让程序员创建并使用一些属性键而不会冒着重名危险的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure><p>调用<code>Symbol()</code>可以创建一个新的symbol, 一个和其他值都不同的东西.</p><p>和字符串或者数字一样, 你可以用symbol来作为属性名. 因为他不等于任何字符串, 所以用symbol做键的属性也可以保证不会与其他属性冲撞.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[mySymbol] = <span class="string">&quot;ok!&quot;</span>;  <span class="comment">// guaranteed not to collide</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[mySymbol]);  <span class="comment">// ok!</span></span><br></pre></td></tr></table></figure><p>下面的代码是你可以如何用symbol解决之前讨论过的问题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a unique symbol</span></span><br><span class="line"><span class="keyword">var</span> isMoving = <span class="title class_">Symbol</span>(<span class="string">&quot;isMoving&quot;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element[isMoving]) &#123;</span><br><span class="line">  <span class="title function_">smoothAnimations</span>(element);</span><br><span class="line">&#125;</span><br><span class="line">element[isMoving] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>以上代码的一些注意点:</p><ul><li>   在<code>Symbol(&#39;isMoving&#39;)</code>中的字符串<code>&#39;isMoving&#39;</code>被称作<em>描述</em>. 在debug的时候很有用. 你<code>console.log()</code>symbol的时候会显示出来, 当你用<code>.toString()</code>来尝试转为字符串的时候, 他也许会在错误信息里, 就是这样.</li><li>   <code>element[isMoving]</code>被称作<em>symbol键的属性</em>. 一个使用symbol作为键而不是字符串作为键的值. 除了这个, 他和其他的属性别无二致.</li><li>   和数组元素一样, symbol作为键的属性不能用点的语法, 比如<code>obj.name</code>. 只要方括号才能使用symbol.</li><li>   如果你已经获得symbol, 那么拿到属性值就很容易, 上面已经展示了如何get和set<code>element[isMoving]</code>, 如果有需要的话我们同样也可以调用<code>if(isMoving in element)</code>甚至<code>delete element[isMoving]</code>.</li><li>   另一方面, 上面所有这些都需要<code>isMoving</code>在作用域内. 这让symbol可以用来实现弱封装: 一个模块可以创建一些sybol来给自己的object使用并且<strong>不用担心与其他代码创建的属性冲突</strong>.</li></ul><p>因为symbol键是被设计来避免冲撞的, javascript大多数普通的遍历对象的方法都会忽略symbol键. 比如唯一的获得对象字符串键的<code>for-in</code>循环. <code>Object.keys(obj)</code>和<code>Object.getOwnPropertyNames(obj)</code>也是如此. 但symbol实际上不是私有的: 通过新的api<code>Object.getOwnPropertySymbols(obj)</code>来列出一个对象的symbol. 另外一个api<code>Reflect.ownKeys(obj)</code>, 可以同时返回字符串键和symbol键. (Reflect将会在下篇文章里说.)</p><p>看起来lib和框架可能会更多使用symbol, 我们接下来也会看到es6让我们看到他有广泛的用途.</p><h2 id="symbol的三种放置"><a href="#symbol的三种放置" class="headerlink" title="symbol的三种放置"></a>symbol的三种放置</h2><p>有三种方法可以获取到symbol.</p><ul><li>   <strong>调用<code>Symbol()</code></strong>. 正如之前说的, 这样调用每次都会返回一个新的唯一的symbol.</li><li>   <strong>调用<code>Symbol.for(string)</code></strong>. 获得一个叫做<em>symbol寄存器</em>中的symbol集合. 与被<code>Symbol()</code>定义的唯一symbol不同, 在symbol寄存器中的symbol是共享的. 如果你调用<code>Symbol.for(&#39;cat&#39;)</code>三次,  你会得到同一个symbol. symbol寄存器可以用在多个web页面或者一个页面多个模块的情景下.</li><li>   <strong>使用类似<code>Symbol.iterator</code>的形式, 这是标准定义的</strong>. 一些symbol已经被标准创建了. 每个都有他们特殊的用途.</li></ul><p>如果你仍然没有确定symbol是不是那么有用, 下个章节很有趣, 会告诉你symbol已经被实践证明是有用的.</p><h2 id="es6标准中的symbol的使用"><a href="#es6标准中的symbol的使用" class="headerlink" title="es6标准中的symbol的使用."></a>es6标准中的symbol的使用.</h2><p>我们已经知道es6用symbol来避免与现有代码的冲突. 几周前, 我写过一个iterator的文章, 我们看到了循环:<code>fro (var item of myArray)</code> 以<code>myArray[Symbol.iterator]()</code>开头. 我提到过这个可以被写作<code>myArray.iterator()</code>, 但是写作symbol更利于兼容性.</p><p>现在我们已经吧symbol讲到这个程度了, 也很容易理解上面的代码的意思和原理了.</p><p>下面是几个es6使用的著名的symbol.</p><ul><li>   <strong>使<code>instanceof</code>可拓展</strong>. 在es6中, 表达式:<code>object instanceof constructor</code>被认为是构造方法的一个方法:<code>constructor[Symbol.hasInstance](object)</code>. 这意味了可拓展性.</li><li>   <strong>解决新特性和旧代码的冲突</strong>. 这又点难理解, 我们会发现<em>只是写了一些es6的<code>Array</code>方法</em>就把整个页面写崩了. 其他的web标准也存在类似的问题: 只是用了一个新方法就把浏览器整个页面搞挂了. 但是我们发现, 这种页面崩坏大多由一种被称作<em>不稳定范围的特性</em>导致的, 所以es6引入了一个特殊的symbol:<code>Symbol.unscopables</code>, 这样web标准可以防止我们使用了不稳定的特性而弄崩页面.</li><li>   <strong>支持字符串匹配的新种类</strong>. 在es6里, <code>str.match(myObject)</code>会尝试吧<code>myObject</code>转换为<code>RegExp</code>. 在es6, js首先会去检查<code>myObject</code>是否存在<code>myObject[Symbol.match](str)</code>. 现在各种lib就可以提供自定义的parse字符串的类来替换所有<code>RegExp</code>影响的地方.</li></ul><p>以上这些用法其实还很窄. 这还很难看到这个特性对我们每天编码的巨大影响. 来日方长. 这些被标准定义的symbol是js对php和python中的<code>__doubleUnderscores</code>(魔术方法)的改进版本. js标准会在将来给语言增加更多新的钩子并没有影响现有代码的危险.</p><h2 id="如何可以用es6的symbol"><a href="#如何可以用es6的symbol" class="headerlink" title="如何可以用es6的symbol?"></a>如何可以用es6的symbol?</h2><p>用一些polyfill的lib.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 箭头函数</title>
      <link href="/2016/09/10/es6-in-depth-arrow-functions/"/>
      <url>/2016/09/10/es6-in-depth-arrow-functions/</url>
      
        <content type="html"><![CDATA[<p>箭头从一开始就是javascript的一部分. 一开始javascript教程建议把脚本包起来作为注释. 这种表达会阻止浏览器把js代码错误地显示在html中. 你可能会写以下的代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="comment">&lt;!--</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">  document.bgColor = &quot;brown&quot;;  // red</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">// --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>老的浏览器会看到2个不支持的标签和一个注释, 只有新的浏览器可以识别这是js代码.</p><p>为了支持这个古老的坑, 你浏览器中的javascript引擎会把<code>&lt;!--</code>开始的语句作为一行注释. 这不是玩笑. 这真的一直是语法的一部分, 并每天在生效, 不止是最上面的<code>&lt;script&gt;</code>标签而是js的任何地方. 这个特性在node中也有效.</p><p>既然这样了, <a href="https://tc39.github.io/ecma262/#sec-html-like-comments">这样的注释标准第一时间被加入了es6</a>. 但这不是今天要讲的箭头.</p><p>这样顺序的箭头<code>--&gt;</code>也表示一行注释. 奇怪的是在HTML中在<code>--&gt;</code>之前的表示注释而在JS中<code>--&gt;</code>之后的表示注释.</p><p>接下来会更奇怪: 这个箭头只在他在行首的时候表示注释, 当他再代码中的时候, <code>--&gt;</code>是一个js操作符, ‘goes to’操作符!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (n --&gt; <span class="number">0</span>)  <span class="comment">// &quot;n goes to zero&quot;</span></span><br><span class="line">    <span class="title function_">alert</span>(n);</span><br><span class="line">  <span class="title function_">blastoff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/anon/pen/oXZaBY?editors=001">这个代码</a>真的可以运行. 循环从n运行到0. 这并不是es6的新特性, 而是一些我们熟悉的特性的混用再加上一些错用. 你能不能猜到是怎么做到的? 和往常一样, 我们能在<a href="http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator-in-c">stackoverflow</a>中找到答案. (答案是 <code>n-- &gt;0</code>, 尴尬.)</p><p>当然还有一个小等于操作符, <code>&lt;=</code>. 也许你还能在更多的地方发现箭头比如在图片的样式里, 但本文的介绍到此结束, 我们来看看这个还没有被使用的箭头.</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>&lt;!–</td><td>单行注释</td></tr><tr><td>–&gt;</td><td>‘goes to’ 操作符</td></tr><tr><td>&lt;&#x3D;</td><td>小等于</td></tr><tr><td>&#x3D;&gt;</td><td>???</td></tr></tbody></table><p>那么<code>=&gt;</code>是什么呢, 我们今天会讨论.<br>首先我们想讲一下函数.</p><h2 id="随处可见的函数表达式"><a href="#随处可见的函数表达式" class="headerlink" title="随处可见的函数表达式"></a>随处可见的函数表达式</h2><p>javascript的一个有意思的特性是你任何时间都需要函数, 你可以在运行的代码中间加上一个函数.</p><p>打个比方, 假设你试着告诉浏览器在点击某个按钮的时候需要做些什么, 你开始写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#confetti-btn&quot;</span>).<span class="title function_">click</span>(</span><br></pre></td></tr></table></figure><p>jQuery的<code>click()</code>方法只需要一个参数: 一个函数. 没问题, 你可以直接把函数写在这里:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#confetti-btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">playTrumpet</span>();</span><br><span class="line">  <span class="title function_">fireConfettiCannon</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对我们来说写这些代码已经非常自然了. 所以如果javascript取消这种写法会让我们不自然, 许多语言是没有这个特性的. 当然Lisp也有函数表达式, 叫做<em>lambda函数</em>, 始于1958年. 而C++, Python, C# 和Java都很多年不带有这个特性.</p><p>现在不再是那样了, 这4种语言现在都有lambda表达式了. 新兴的语言也普遍的有内置的lambda表达式. javascript现在也有了, 这要感谢早起的无畏的程序员写了很重的lib来引导这个特性的使用推广.</p><p>有点小尴尬的是, 所有我提及的语言, javascript对lambda表达式的语法是最冗长的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A very simple function in six languages.</span></span><br><span class="line"><span class="built_in">function</span> (a) &#123; <span class="keyword">return</span> a &gt; <span class="number">0</span>; &#125; <span class="comment">// JS</span></span><br><span class="line">[](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a &gt; <span class="number">0</span>; &#125;  <span class="comment">// C++</span></span><br><span class="line">(<span class="built_in">lambda</span> (a) (&gt; a <span class="number">0</span>))  ;; Lisp</span><br><span class="line">lambda a: a &gt; <span class="number">0</span>  # Python</span><br><span class="line">a =&gt; a &gt; <span class="number">0</span>  <span class="comment">// C#</span></span><br><span class="line">a -&gt; a &gt; <span class="number">0</span>  <span class="comment">// Java</span></span><br></pre></td></tr></table></figure><h2 id="新的箭头蓄势待发"><a href="#新的箭头蓄势待发" class="headerlink" title="新的箭头蓄势待发"></a>新的箭头蓄势待发</h2><p>es6引入了一个新的写函数的方式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> selected = allJobs.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">job</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> job.<span class="title function_">isSelected</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> selected = allJobs.<span class="title function_">filter</span>(<span class="function"><span class="params">job</span> =&gt;</span> job.<span class="title function_">isSelected</span>());</span><br></pre></td></tr></table></figure><p>当你想写只有一个参数的简单的函数时, 新的箭头函数语法是简单的<code>Identifier =&gt; Expression</code>. 你可以跳过打<code>function</code>和<code>return</code>, 和那些括号,分号等.</p><p>(对我来说这是一个极好的特性. 不需要打<code>function</code>对我来说太重要了. 因为我会不可避免地打<code>functoin</code>然后再点回去修改他.)</p><p>如果要写一个带有多参数(或者没参数, 或者rest参数或默认参数, 或解构参数)你需要在参数列表外用括号括起来.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> total = values.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> total = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我觉得这样看起来非常帅.</p><p>箭头函数也能非常完美的与一些功能函数配合, 比如<a href="http://underscorejs.org/">undercore.js</a>和<a href="https://facebook.github.io/immutable-js/">Immutable</a>. 事实上, 一个<a href="https://facebook.github.io/immutable-js/docs/#/">Immutable文档</a>已经用es6写了, 他们的很多地方都已经用了箭头函数.</p><p>那么如果是不那么函数向的场景呢?(可能指没返回, 而是执行一些内容) 箭头函数也可以包裹一个语句块而不只是表达式. 回忆下前面的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">$(<span class="string">&quot;#confetti-btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">playTrumpet</span>();</span><br><span class="line">  <span class="title function_">fireConfettiCannon</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是es6的版本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line">$(<span class="string">&quot;#confetti-btn&quot;</span>).<span class="title function_">click</span>(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">playTrumpet</span>();</span><br><span class="line">  <span class="title function_">fireConfettiCannon</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个比较小的改进. 如果用在Promise上效果会更大, 比如<code>&#125;).then(function (result) &#123;</code>这样的行就可以收起来了.</p><p>要注意的是使用body块的箭头函数不会自动返回值, 需要用<code>return</code>语句来实现.</p><p>有一个箭头对象返回对象的提醒, 对象永远要用括号括起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new empty object for each puppy to play with</span></span><br><span class="line"><span class="keyword">var</span> chewToys = puppies.<span class="title function_">map</span>(<span class="function"><span class="params">puppy</span> =&gt;</span> &#123;&#125;);   <span class="comment">// BUG!</span></span><br><span class="line"><span class="keyword">var</span> chewToys = puppies.<span class="title function_">map</span>(<span class="function"><span class="params">puppy</span> =&gt;</span> (&#123;&#125;)); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>很不凑巧, 一个空对象<code>&#123;&#125;</code>和空的语句块<code>&#123;&#125;</code>看起来正好一样. 在es6中在箭头后的<code>&#123;</code>会被当做一个语句块的开始, 而不是对象的开始. <code>puppy = &#123;&#125;</code>会被默认为一个什么都没做并返回<code>undefined</code>的箭头函数.</p><p>更复杂一点, 一个对象字面量<code>&#123;key:value&#125;</code>看起来正好是一个语句块, 至少js引擎是这么识别的, 幸运的是有歧义的字符只有<code>&#123;</code>这一个, 只要记得用括号括起来就可以了.</p><h2 id="this是指"><a href="#this是指" class="headerlink" title="this是指?"></a><code>this</code>是指?</h2><p>普通的<code>function</code>和箭头函数有一个小区别. **箭头函数没有自己的<code>this</code>值<code>. 箭头函数内的</code>this&#96;永远指向外层作用域.</p><p>在我们实际尝试和理解之前先来做一些前提准备.</p><p><code>this</code>在javascript用来干嘛?他的值从哪来?<a href="http://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work">这是个简短的回答</a>. 如果你觉得这很简单, 说明你经常在处理<code>this</code>.</p><p>这个问题经常遇见的原因是<code>function</code>函数会自动接收一个<code>this</code>值, 无论你想不想要, 你又没有写过类似的代码?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">addAll</span>: <span class="keyword">function</span> <span class="title function_">addAll</span>(<span class="params">pieces</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    _.<span class="title function_">each</span>(pieces, <span class="keyword">function</span> (<span class="params">piece</span>) &#123;</span><br><span class="line">      self.<span class="title function_">add</span>(piece);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里你想写一个类似<code>this.add(piece)</code>的内部方法. 不幸的是, 内部方法没有继承外部的<code>this</code>值, 在内部方法中<code>this</code>可能是<code>window</code>或者<code>undefined</code>. 临时变量<code>self</code>是用来传递外部的<code>this</code>值到内部方法的.(另外个方法是在内部方法使用<code>.bind(this)</code>, 两个方法都很不错.)</p><p>在es6中, 如果你遵循了一下规则<code>this</code>的问题会不存在:</p><ul><li>   在非箭头函数中使用<code>object.method()</code>语法来调用. 这样这些函数就可以接收到有意义的<code>this</code>.</li><li>   在其他地方都使用箭头函数.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">addAll</span>: <span class="keyword">function</span> <span class="title function_">addAll</span>(<span class="params">pieces</span>) &#123;</span><br><span class="line">    _.<span class="title function_">each</span>(pieces, <span class="function"><span class="params">piece</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(piece));</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在es6中, <code>addAll</code>方法从他的调用者接收到了<code>this</code>. 内部方法是一个箭头函数, 所以继承了外部作用域的<code>this</code>.</p><p>还有个小奖励, es6提供了一个在字面量对象中写方法的快捷语法, 上面的代码可以被简化成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 with method syntax</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">addAll</span>(<span class="params">pieces</span>) &#123;</span><br><span class="line">    _.<span class="title function_">each</span>(pieces, <span class="function"><span class="params">piece</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(piece));</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想可能在以后的方法和箭头里可以再也不用打<code>function</code>了, 太好了.</p><p>还有一个小区别, 箭头函数拿不到<code>arguments</code>对象. 当然在es6里你已经应该不需要他了.</p><h2 id="用这个箭头来刺穿计算机科学的黑暗心脏"><a href="#用这个箭头来刺穿计算机科学的黑暗心脏" class="headerlink" title="用这个箭头来刺穿计算机科学的黑暗心脏"></a>用这个箭头来刺穿计算机科学的黑暗心脏</h2><p>我们已经说了箭头函数的许多使用例子. 还有一些可能会用到的情况: es6可以作为一个学习工具来揭示计算的深层本质. 这是否实际决定于你自己.</p><p>在1936年, alonzo Church和Alan Turing独立开发了强大的数学计算模型. Turing把他这个模型称作<code>a-machines</code>, 但每个人都把这个叫做Turing machines. Church重新写了一些函数. 他的模型叫做<a href="https://en.wikipedia.org/wiki/Lambda_calculus"> λ-calculus</a>(λ是希腊字母lambda的小写). 这就是为什么Lisp用<code>LAMBDA</code>来命名函数, 也就是我们现在说的”lambdas”表达式.</p><p>但什么是λ-calculus呢? “计算模型”又是什么意思?</p><p>用简单几句没法解释清楚, 但我试一下: λ-calculus是第一个编程语言. 但并不是本来就想设计成编程语言-毕竟一个编程语言不能持续一二十年-但希望这种简单明了纯数学的算法可以在计算机内任何需要的时候都能用. Church希望这个模型可以某个程度上帮助计算.</p><p>然后他发现他的系统只需要一个东西:<em>函数</em>.</p><p>想一想这个想法是多么非凡. 不需要对象, 数字, 没有<code>if</code>语句, <code>while</code>循环, 分号, 赋值, 逻辑操作符, 或者事件循环, 只需要函数就可以重写计算机的任何方法.</p><p>下面是数学家可能会写的这种’编程’, 使用了Church的lambda表达式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix = λf.(λx.<span class="title function_">f</span>(λv.<span class="title function_">x</span>(x)(v)))(λx.<span class="title function_">f</span>(λv.<span class="title function_">x</span>(x)(v)))</span><br></pre></td></tr></table></figure><p>在javascript中看起来是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">fix</span> = f =&gt; (<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">x</span>(x)(v)))</span><br><span class="line">               (<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">x</span>(x)(v)));</span><br></pre></td></tr></table></figure><p>也就是说，JavaScript 包含了一个 λ 表达式的运行时实例，λ 表达式存在于 JavaScript 内部。</p><h2 id="哪里可以使用箭头函数"><a href="#哪里可以使用箭头函数" class="headerlink" title="哪里可以使用箭头函数?"></a>哪里可以使用箭头函数?</h2><p>babel, traceur或者typescript.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 解构赋值</title>
      <link href="/2016/09/10/es6-in-depth-destructuring/"/>
      <url>/2016/09/10/es6-in-depth-destructuring/</url>
      
        <content type="html"><![CDATA[<p>解构赋值允许你通过和数组对象相近的语法来使用数组或对象的属性. 他的语法非常简单. 而且还比传统的获取属性方法更清晰.</p><span id="more"></span><h2 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值?"></a>什么是解构赋值?</h2><p>不使用解构赋值, 你获取一个数组前三个属性的语法可能是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>用了解构赋值, 等价的代码变得更简单可读:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br></pre></td></tr></table></figure><h2 id="解构数组与可遍历数据"><a href="#解构数组与可遍历数据" class="headerlink" title="解构数组与可遍历数据"></a>解构数组与可遍历数据</h2><p>我们已经看了一个解构赋值的示例了, 他的语法基本形式是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ variable1, variable2, ..., variableN] = array;</span><br></pre></td></tr></table></figure><p>这样做会把数组中对应的变量赋值给variable1到variableN. 如果你想同时声明变量, 你可以在赋值前加上表示声明的<code>var</code>, <code>let</code>, <code>const</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [ variable1, variable2, ..., variableN ] = array;</span><br><span class="line"><span class="keyword">let</span> [ variable1, variable2, ..., variableN ] = array;</span><br><span class="line"><span class="keyword">const</span> [ variable1, variable2, ..., variableN ] = array;</span><br></pre></td></tr></table></figure><p>事实上上面代码的<code>variable</code>并不正确, 因为你可以无限层嵌套:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>而且你可以跳过数组的一些属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [,,third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(third);</span><br><span class="line"><span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p>你也可以用”rest”风格来拿到尾部的多个内容.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tail);</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>如果你尝试获取不存在的变量, 你会获得<code>undefined</code>, 就像你去获取一个不存在的索引一样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([][<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [missing] = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(missing);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意解构以后为数组赋值也可以在任何可遍历对象上执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fibs</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sixth);</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h2><p>对象的解构赋值让我们可以把值绑定到对象的不同属性上. 你指定的绑定属性需要和你解构的字段一样.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">&quot;Bender&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">&quot;Flexo&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameA);</span><br><span class="line"><span class="comment">// &quot;Bender&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameB);</span><br><span class="line"><span class="comment">// &quot;Flexo&quot;</span></span><br></pre></td></tr></table></figure><p>当我们需要赋值的变量属性名一样的时候下面这个快捷的语法很有用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;lorem&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;ipsum&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="comment">// &quot;lorem&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line"><span class="comment">// &quot;ipsum&quot;</span></span><br></pre></td></tr></table></figure><p>和数组的嵌套解构一样, 对象也可以这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">  <span class="attr">arrayProp</span>: [</span><br><span class="line">    <span class="string">&quot;Zapp&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">second</span>: <span class="string">&quot;Brannigan&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line"><span class="comment">// &quot;Zapp&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second);</span><br><span class="line"><span class="comment">// &quot;Brannigan&quot;</span></span><br></pre></td></tr></table></figure><p>同样的, 当你尝试获取一个不存在的属性后也会得到<code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; missing &#125; = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(missing);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>有一个需要注意的地方是, 你在没有声明变量前(没有<code>let</code>,<code>const</code>或<code>var</code>)进行了对象的解构赋值就会发生:(数组的话可以不声明)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; blowUp &#125; = &#123; <span class="attr">blowUp</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">// Syntax error</span></span><br></pre></td></tr></table></figure><p>发生这个语法错误的原因是js语法会告诉引擎把<code>&#123;</code>开头的语句都认为是一个语句块(打个比方, <code>&#123;console&#125;</code>会被认为是个合法的语句块). 解决的方法是在这个表达式两边加上括号.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#123; safe &#125; = &#123;&#125;);</span><br><span class="line"><span class="comment">// No errors</span></span><br></pre></td></tr></table></figure><h2 id="解构不是数组-对象-或可遍历对象的值"><a href="#解构不是数组-对象-或可遍历对象的值" class="headerlink" title="解构不是数组,对象,或可遍历对象的值"></a>解构不是数组,对象,或可遍历对象的值</h2><p>当你尝试去解构<code>null</code>或者<code>undefined</code>, 你会获得一个TypeError:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;blowUp&#125; = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// TypeError: null has no properties</span></span><br></pre></td></tr></table></figure><p>但你如果尝试解构类似布尔值, 数字, 字符串这些乱七八糟的数据类型时, 你会获得<code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;wtf&#125; = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wtf);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这看起来很莫名, 但仔细考虑原因其实很简单. 当我们使用了赋值语句, 待被解构的值需要被<a href="https://tc39.github.io/ecma262/#sec-requireobjectcoercible">转换为对象</a>来被解构. 大多类型都可以被转为对象, 但是<code>null</code>和<code>undefined</code>无法被转换. 举一反三, 当给数组解构赋值时, 目标值需要<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-getiterator">有遍历器</a>.</p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>你也可以在解构可能没有值的时候设置默认值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(missing);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&quot;Something went wrong&quot;</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line"><span class="comment">// &quot;Something went wrong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="解构赋值的实际应用"><a href="#解构赋值的实际应用" class="headerlink" title="解构赋值的实际应用"></a>解构赋值的实际应用</h2><h3 id="函数参数定义"><a href="#函数参数定义" class="headerlink" title="函数参数定义"></a>函数参数定义</h3><p>作为开发者, 我们现在可以提供更人性化的api: 接受一个包含多个属性的对象而不需要使用者来记住每个参数的顺序. 我们可以使用解构赋值来简化我们取到对应属性的过程:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置参数对象"><a href="#配置参数对象" class="headerlink" title="配置参数对象"></a>配置参数对象</h3><p>展开上一个例子, 我们同样可以给解构参数的属性默认值. 当我们需要给有很多属性的参数对象配置一些合理的默认值时这个特性就很有用.举个例子, jQuery的<code>ajax</code>函数接受一个对象配置作为第二个参数, 所以可以被写成这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  beforeSend = noop,</span></span><br><span class="line"><span class="params">  cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  complete = noop,</span></span><br><span class="line"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  <span class="variable language_">global</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  // ... more config</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写避免了给每个属性的默认值重复写<code>var foo = config.foo || theDefaultFoo;</code></p><h3 id="与es6的遍历协议配合"><a href="#与es6的遍历协议配合" class="headerlink" title="与es6的遍历协议配合"></a>与es6的遍历协议配合</h3><p>es6定义了遍历器的协议, 在我们之前的章节讲过了. 当我们遍历<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>时, 会得到一系列的<code>[key, value]</code>对. 我们解构他时可以同时获得键和值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="variable language_">window</span>, <span class="string">&quot;the global&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="variable language_">document</span>, <span class="string">&quot;the document&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;[object Window] is the global&quot;</span></span><br><span class="line"><span class="comment">// &quot;[object HTMLDocument] is the document&quot;</span></span><br></pre></td></tr></table></figure><p>只遍历键:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者只遍历值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>语言特性里没有被假如返回多个值, 是因为没有必要, 因为你可以解构函数返回值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnMultipleValues</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [foo, bar] = <span class="title function_">returnMultipleValues</span>();</span><br></pre></td></tr></table></figure><p>当然你也可以你也可以把对象作为返回值来解构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnMultipleValues</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = <span class="title function_">returnMultipleValues</span>();</span><br></pre></td></tr></table></figure><p>以上两种都比创建一个临时变量优雅:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnMultipleValues</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="title function_">returnMultipleValues</span>();</span><br><span class="line"><span class="keyword">var</span> foo = temp.<span class="property">foo</span>;</span><br><span class="line"><span class="keyword">var</span> bar = temp.<span class="property">bar</span>;</span><br></pre></td></tr></table></figure><p>或者使用延续传值的形式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnMultipleValues</span>(<span class="params">k</span>) &#123;</span><br><span class="line">  <span class="title function_">k</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">returnMultipleValues</span>(<span class="function">(<span class="params">foo, bar</span>) =&gt;</span> ...);</span><br></pre></td></tr></table></figure><h3 id="从commonJS模块中import-name"><a href="#从commonJS模块中import-name" class="headerlink" title="从commonJS模块中import name"></a>从commonJS模块中import name</h3><p>还没有使用es6的模块? 还在用commonJS的模块? 没问题! 当我们引入某个commonJS的模块X, 模块X提供了比你需要得更多的功能是很正常的. 使用了解构, 你可以引入你需要的模块而避免污染你的命名空间:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SourceMapConsumer</span>, <span class="title class_">SourceNode</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure><p>(如果你在用es6的模块, 你应该知道<code>import</code>声明有类似的语法)</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们已经知道了解构在各种小场景中都很有用. 在火狐中我们已经有一些这方面的经验了. Lar Hansen在十年前就在Opera里引入了解构, Brendan Eich在后来给火狐添加了这个特性. 解构赋值已经被使用到了我们每天对js的使用中, 让我们的代码更简短.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth rest参数与默认参数</title>
      <link href="/2016/09/10/es6-in-depth-rest-parameters-and-defaults/"/>
      <url>/2016/09/10/es6-in-depth-rest-parameters-and-defaults/</url>
      
        <content type="html"><![CDATA[<p>今天,我们来讲一下es6让js语法更有表达性的两个特性: rest参数和默认参数.</p><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>这是一个普遍的需求, 当需要创建一个可以接受任何数量参数的函数, 叫做无限参数函数(variadic function). 比如<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat">String.prototype.concat</a>可以接受任何数量的参数. 通过rest参数, es6提供了一个新的方法来写无限参数函数.</p><p>来写一个例子, 我们写了一个<code>containsAll</code>函数来检查是否一个字符串包含一些字符串. 比如<code>containsAll(&#39;banana&#39;, &#39;b&#39;, &#39;nan&#39;)会返回</code>true<code>, </code>containsAll(‘banana’,’c’,’nan’)<code>会返回</code>false&#96;.</p><p>如果是传统的方法实现是以下的样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">containsAll</span>(<span class="params">haystack</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> needle = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (haystack.<span class="title function_">indexOf</span>(needle) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments对象</a>, 一个包含了被传入函数的参数的类数组的对象. 这个代码当然已经实现了我们的需求, 但他的可读性不是最理想. 函数参数只能列出有限的参数. 我们不能直接看出函数可以接受无限参数. 另外我们必须小心地从<code>1</code>开始遍历<code>arguments</code>而不是<code>0</code>, 因为<code>auguments[0]</code>代表固定的参数. 如果我们想在参数前再加一个参数, 我们就要重写循环了. rest参数解决了以上所有问题. 以下是rest参数的<code>containsAll</code>实现代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">containsAll</span>(<span class="params">haystack, ...needles</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> needle <span class="keyword">of</span> needles) &#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack.<span class="title function_">indexOf</span>(needle) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包含了特殊语法<code>...needles</code>的函数做了和上一个函数一样的事. 我们来看看调用了<code>containsAll(&#39;banana&#39;, &#39;b&#39;, &#39;nan&#39;)</code>后发生了什么. 固定的函数<code>banana</code>和通常一样是被传入的第一个参数. 前面带有省略号的<code>needles</code>代表他是一个<em>rest参数</em>. 所有被传入的其他的参数都被放进一个数组并赋值到<code>needles</code>变量中. 在我们的调用例子中, <code>needles</code>就是<code>[&#39;b&#39;, &#39;nan&#39;]</code>. 然后函数和平时一样继续执行. (注意我们用了es6的<code>for-of</code>循环)</p><p>函数只有最后一个参数可以被标记为rest参数. 在调用中, rest参数前的参数获得与通常是一样的. 并且任何其他’多余’的参数会被塞入rest参数. 如果不再有其他额外的参数, rest参数的值称为一个简单的空数组; rest参数永远不会为<code>undefined</code>.</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>通常, 一个函数的参数不要求传入所有的参数, 一些参数有默认值不需要每次都传值是合理的. javascript向来都有一种不灵活的默认参数的形式; 参数没有被传入的时候默认为<code>undefined</code>. es6引入了一个新的方法来指定参数的默认值.</p><p>以下是例子. (反引号是模板字符串的特性, 在上篇文章有提及)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animalSentence</span>(<span class="params">animals2=<span class="string">&quot;tigers&quot;</span>, animals3=<span class="string">&quot;bears&quot;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Lions and <span class="subst">$&#123;animals2&#125;</span> and <span class="subst">$&#123;animals3&#125;</span>! Oh my!`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个参数中, <code>=</code>的值代表如果调用时没传入值的默认参数. 所以<code>animalSentence()</code>会返回<code> &quot;Lions and tigers and bears! Oh my!&quot;</code>, <code>animalSentence(&quot;elephants&quot;)</code>会返回<code>&quot;Lions and elephants and bears! Oh my!&quot;</code>,<code>animalSentence(&quot;elephants&quot;, &quot;whales&quot;)</code>会返回<code>&quot;Lions and elephants and whales! Oh my!&quot;</code>.</p><p>默认参数还有一些细节:</p><ul><li><p>和Python不同, <strong>默认参数在函数被调用时</strong>被从左到右的赋值. 这意味着默认参数表达式可以使用之前的参数. 比如我们可以让之前的函数更溜如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animalSentenceFancy</span>(<span class="params">animals2=<span class="string">&quot;tigers&quot;</span>,</span></span><br><span class="line"><span class="params">    animals3=(animals2 == <span class="string">&quot;bears&quot;</span>) ? <span class="string">&quot;sealions&quot;</span> : <span class="string">&quot;bears&quot;</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Lions and <span class="subst">$&#123;animals2&#125;</span> and <span class="subst">$&#123;animals3&#125;</span>! Oh my!`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>animalSentenceFancy(&quot;bears&quot;)</code>的调用会返回<code>&quot;Lions and bears and sealions. Oh my!&quot;</code>.</p></li><li><p>传入<code>undefined</code>会被认为没有传入任何参数. 所以<code>animalSentence(undefined, &quot;unicorns&quot;)</code>的返回结果是<code>&quot;Lions and tigers and unicorns! Oh my!&quot;</code>.</p></li><li><p>没有被保留默认值的参数默认为undefined, 所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">a=<span class="number">42</span>, b</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>是被允许的, 并等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">a=<span class="number">42</span>, b=<span class="literal">undefined</span></span>) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="废弃arguments"><a href="#废弃arguments" class="headerlink" title="废弃arguments"></a>废弃<code>arguments</code></h2><p>我们现在知道了rest参数和默认参数可以代替<code>arguments</code>的使用了. 所以废弃<code>arguments</code>可以使我们的代码更好更可读. <code>arguments</code>的魔性也造成了<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments">优雅化js的头疼</a>.</p><p>我们希望rest参数和默认参数可以完全代替<code>arguments</code>. 作为第一步, 使用rest参数和默认参数的函数就不允许使用<code>arguments</code>. 鉴于<code>arguments</code>不太会被很快移除, 如果这样的话, 我们还是尽量用rest参数和默认参数去代替他吧.</p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>除了火狐15+对此特性有支持, 其他浏览器都不太行, 所以建议用babel.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然技术上说rest参数和默认参数没有改变任何js行为, 但他让js函数声明更有表现力, 更可读. 快乐的调用吧!</p><hr><p>下周我们会讲另外一个es6的特性, 他简单优雅, 实际, 每天都会用到. 他用了类似你已经在写的数组对象类似的语法, 我们会用新的语法来拆分数组和对象. 什么意思呢? 为什么要把对象拆开呢? 期待下周的解构赋值吧.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 模版字符串</title>
      <link href="/2016/09/10/es6-in-depth-template-strings/"/>
      <url>/2016/09/10/es6-in-depth-template-strings/</url>
      
        <content type="html"><![CDATA[<p>上周我说了准备改变下节奏. 在遍历器和生成器之后我们要来说一些简单的东西. 一些不会烧脑的东西. 你们可以看下我最后有没有实现承诺.</p><p>现在开始, 我们将以一些简单的东西开始.</p><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>es6引入了一个新的字符串字面语法叫做<em>模版字符串</em>. 他看起来和普通字符串差不多, 除了用了反引号<code>`</code>而不是通常的引号<code>&#39;</code>或者<code>&quot;</code>. 简单的例子的话就是以下的单纯字符串:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="title function_">fillText</span>(<span class="string">`Ceci n&#x27;est pas une chaîne.`</span>, x, y);</span><br></pre></td></tr></table></figure><p>但他被叫做”模版字符串”而不是”只是加了反引号的无聊的老式字符串”是有原因的. 模版字符串带来了简单的javascript<a href="https://en.wikipedia.org/wiki/String_interpolation">字符串插值</a>. 就是看起来很舒服, 又很方便地把js的变量插入到字符串中.</p><p>有一万个方法可以使用他, 但最温暖人心的使用点是在显示错误信息:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">authorize</span>(<span class="params">user, action</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.<span class="title function_">hasPrivilege</span>(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">            <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中, <code>$&#123;user.name&#125;</code> 和<code>$&#123;action&#125;</code>被叫做模版占位符. javascript会把<code>user.name</code>和<code>action</code>插入到输出字符串中. 这样就会输出这样的信息: <code>User joredorff is not authorized to do hockey.</code>(这是真的, 我确实没有hockey证书)</p><p>到了这里, 看起来只是相较<code>+</code>操作符稍微好一点的语法, 而以下的细节可能是你所期待的:</p><ul><li>模版占位符可以是任何javascript表达式. 函数调用, 算数表达式等等都是可以的. (如果你真的想, 甚至可以在模版字符串里嵌入另一个模版字符串, 这样叫做<em>模版嵌套</em>)</li><li>如果插值内容不是字符串, 他会被用通常的规则转为字符串. 比如<code>action</code>是一个对象的话, 就会调用他的<code>toString()</code>方法.</li><li>如果你想在模版字符串中写反引号, 那么就要把他转义为<code>\`</code>, 得到的效果如同<code>"`"</code>.</li><li>同样的, 如果你想要在模版字符串中包含这2个字母<code>$&#123;</code>, 你也可以用反斜杠把他们转义成<code>write \$&#123; or $\&#123;</code>.</li></ul><p>和普通字符串不同, 模版字符串可以包含多行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#warning&quot;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h1&gt;Watch out!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;Unauthorized hockeying can result in penalties</span></span><br><span class="line"><span class="string">  of up to <span class="subst">$&#123;maxPenalty&#125;</span> minutes.&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>所有在模版字符串里的空格, 包括新起一行和缩进, 都会被原样输出.</p><p>好, 因为我上周的承诺, 我要对大家的大脑健康负责. 所以这里给个提醒: 接下来的东西可能会让你略烦. 你可以现在停止阅读并且喝杯咖啡, 享受一下轻松没有烧起来的脑子. 当然谈, 继续回来看也没什么不好意思的. <a href="https://en.wikipedia.org/wiki/Lopes_Gon%C3%A7alves">Lopes Gonçalves</a>有没有在证明了用船穿越赤道不会被怪物攻击也不会掉到地球边缘之后有没有探索整个南半球呢? 没有, 他回来了, 回家吃了顿好饭, 你也喜欢吃饭, 对吧?</p><h2 id="反引号的未来"><a href="#反引号的未来" class="headerlink" title="反引号的未来"></a>反引号的未来</h2><p>我们来说一下几个模版字符串没有做到的事情</p><ul><li>没有把特殊字符自动转义, 为了避免<a href="http://www.techrepublic.com/blog/it-security/what-is-cross-site-scripting/">跨站脚本攻击(XSS)</a>, 你仍需要对待普通的连续字符串一样小心处理不能信任的数据.</li><li>没有明确与<a href="http://yuilibrary.com/yui/docs/intl/">i18n类库</a>(把你代码显示的语言国际化)的交互. 模版字符串不会处理语言相关的数字和日期的格式化.</li><li>不能替代类似<a href="https://mustache.github.io/">Mustache</a>和<a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>的模版类库.<br>打个比方, 在某种需求下, 模版字符串没有内置的for循环模版来把数组显示在html上.</li></ul><p>es6还提供了一个比较搞的模版字符串, 给js开发者和类库设计者提供了处理上述限制的可能性. 这个特性叫做<em>标签模版(tagged templates).</em></p><p>标签模版的语法很简单. 只是在模版字符串的开头多了一个额外的<em>tag(标签)</em>. 对于上面第一个不足点, 标签可以为<code>SaferHTML</code>, 我们将用这个标签来处理上述提到的第一个限制:自动转义特殊字符.</p><p>注意<code>SaferHTML</code>并不是es6标准库提供的东西, 而是我们之后要来自己实现的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = </span><br><span class="line">    <span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;bonk.sende&#125;</span> has sent you a bonk.&lt;/p&gt;`</span>;</span><br></pre></td></tr></table></figure><p>这里的标签是一个简单的标识符<code>SaferHTML</code>, 标签也可以是一个属性, 类似<code>SaferHTML.escape</code>, 或者一个方法调用, 类似<code>SaferHTML.escape(&#123;unicodeControlCharacter: false&#125;)</code>. (准确地说, 任何es6<a href="https://tc39.github.io/ecma262/#sec-left-hand-side-expressions">成员表达式或者调用表达式</a>都可以作为标签.)</p><p>没有被标签的模版字符串是简单字符串拼接的简写方式. 标签模版字符串是用剩余其他的字符串的简写, 其实全是<em>方法调用</em>.</p><p>所以以上的代码是等价于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = </span><br><span class="line">    <span class="title class_">SaferHTML</span>(templateData, bonk.<span class="property">sender</span>);</span><br></pre></td></tr></table></figure><p><code>templateData</code>是一个我们用js写的包含模版各个部分的固定的数组. 数组需要有两部分组成, 因为标签模版是被占位符分割的两个字符串的部分. 所以<code>templateData</code>可能会是<code>Object.freeze([&quot;&lt;p&gt;&quot;, &quot; has sent you a bonk. &lt;/p&gt;&quot;])</code>.</p><p>(实际上<code>templateData</code>还有一个存在的属性. 我们在本文中不会用, 但我为了完整性所以说一下: <code>templateData.raw</code>是一个包含数组所有部分的数组, 但看起来像源代码的感觉, 因为有像<code>\\n</code>类似的字符, 而不是转化以后的缩进等. 标准的标签<a href="https://tc39.github.io/ecma262/#sec-left-hand-side-expressions">String.raw</a>用了这个.)</p><p>这样可以让<code>SaferHTML</code>有一万个可能去自由的操作和编译字符串和占位符.</p><p>继续看下去前, 你可能想猜出<code>SaferHTML</code>需要做些什么, 然后试着自己去实现他. 毕竟只是一个函数. 你可以在浏览器控制台中测试一下你的代码.</p><p>答案可能是以下这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SaferHTML</span>(<span class="params">templateData</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="title class_">String</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做以后, 标签模版的<code>SaferHTML`&lt;p&gt;$&#123;bonk.sender&#125; has sent you a bonk.&lt;/p&gt;`</code>会被展开成<code>"&lt;p&gt;ES6& lt;3er has sent you a bonk.&lt;/p&gt;"</code> 这样用户及时遇到恶意的攻击也是安全的, 例如: <code> Hacker Steve &lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;</code> 的发起攻击.</p><p>(顺带一提, 如果函数的参数对象太多让你很烦, 下周我会给大家介绍一个我想你会喜欢的新特性)</p><p>一个简单的例子不足以完全说清标签模版的灵活性. 让我们回顾一下刚才所列出的模版字符串的限制, 这样我们才知道我们还可以进一步做些什么:</p><ul><li>模版字符串不会自动转义特殊字符. 但我们已经看到用了标签的模版可以来处理这个问题.</li></ul><p>事实上你可以做到更多.</p><p>从安全角度来说, 我的<code>SaferHTML</code>其实相当弱. html不同的地方需要有不同的转义策略; <code>SaferHTML</code>没有把他们都转义. 但只需要再折腾一下, 你就可以写出比<code>SaferHTML</code>智能很多的函数, 可以分辨每个在<code>templateData</code>中的字节, 知道哪些是html代码; 那些实在元素属性中的, 他们需要被转义<code>&#39;</code>和<code>&quot;</code>; 那些是在url的参数里的, 这些需要被url编码; 等等. 他们每个都需要被正确地替换.</p><p>这样听起来是不是有点牵强, 因为html转换太慢了. 幸运的是, 标签模板的字符串部分被二次编译时不会再有变化. <code>SaferHTML</code>会把转换的结果缓存起来来提升以后编译的速度. (缓存可以是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>是es6另一个特性, 以后也会讲到).</p><ul><li>模板字符串没有内置的i18n特性. 但可以用标签来实现. 有一篇<a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/">Jack hsu的文章</a>写了我们第一步大概该如何做, 以下样例抛砖引玉:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, you have <span class="subst">$&#123;amount&#125;</span>:c(CAD) in your bank account.`</span></span><br><span class="line"><span class="comment">// =&gt; Hallo Bob, Sie haben 1.234,56 $CA auf Ihrem Bankkonto.</span></span><br></pre></td></tr></table></figure><p>注意到这个例子, <code>name</code>和<code>amout</code>是javascript, 但有一个不熟悉的代码, <code>:c(CAD)</code>, Jack把他放在了字符串部分. javascript是javascript引擎处理的部分; 字符串部分就由Jack的<code>i18n</code>标签来处理. 我们可以从<code>i18n</code>的文档中读到<code>:c(CAD)</code>意思是<code>amount</code>是一个货币计量, 加拿大刀.</p><p>以上是关于标签模板的事情.</p><ul><li>模板字符串不能代替Mustache和Nunjucks, 一部分是因为他没有内置的循环和条件语句. 现在我们开始看看你可以如何修复这个问题. 如果js没有提供这个特性, 那么我可以写个标签来提供这个特性.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Purely hypothetical template language based on</span></span><br><span class="line"><span class="comment">// ES6 tagged templates.</span></span><br><span class="line"><span class="keyword">var</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>灵活性还不止于此. 注意标签函数的参数不会被自动转换成字符串. 他们可以是任何东西. 包括返回值也一样, 可以是任何东西. 标签模板甚至也不一定是字符串! 你可以用标签字符串来创建: 正则, dom树, 图片, promise, js数据结构, openGL 的shader…<br><strong>标签模板让类库开发者来创造更多强大的面向领域的语言.</strong> 这些语言可能看起来不像js, 但他们可以无缝插入js并与其余语言智能互动. 我一时想不出别的有这样特性的语言了. 我不知道这个特性会给我们带来什么, 这种可能性让人兴奋.</p><h2 id="我们什么时候可以使用他"><a href="#我们什么时候可以使用他" class="headerlink" title="我们什么时候可以使用他?"></a>我们什么时候可以使用他?</h2><p>用高端浏览器和nodejs, 或者是typescript.</p><h2 id="等等-那markdown呢"><a href="#等等-那markdown呢" class="headerlink" title="等等..那markdown呢?"></a>等等..那markdown呢?</h2><p>嗯哼?</p><p>噢.. 好问题.</p><p>(这个缓解并没有在讲js, 如果你不用markdown, 你可以跳过这里)</p><p>用模板字符串的话, markdown和javascript都用了<code>`</code>来表示一些特殊的东西. 其实在markdown里, 反引号是用来分隔文本中的<code>code</code>(代码)的.</p><p>这带来了些小问题! 如果你写了以下的markdown文档:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To display a message, write `alert(`hello world!`)`.</span><br></pre></td></tr></table></figure><p>他可能会被显示成:</p><p>   To display a message, write <code>alert(h</code>ello world!).</p><p>注意markdown是不存在反引号的. markdown会把所有反引号认为是代码并把他们用html标签替换.</p><p>为了避免这点, 我告诉你一个新手不太知道的事: 你可以用多个反引号来作为代码分隔符, 像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To display a message, write ``alert(`hello world!`)``.</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/jorendorff/d3df45120ef8e4a342e5">这里</a>有详情, 这些使用markdown写的你可以看一下.</p><h2 id="下一章"><a href="#下一章" class="headerlink" title="下一章"></a>下一章</h2><p>下一章我们将说一下许多程序员在别的语言中喜欢了几十年的两个特性: 一个是为了尽量节省参数的人, 一个是为了需要写很多参数的人. –我会讲一下函数的参数问题.</p><p>我们将看到在在火狐中实现这个特性的人的眼里这个特性是怎么样的. 下周我们的嘉宾Benjamin Peterson带来的es6的rest默认参数和rest参数.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 生成器</title>
      <link href="/2016/09/10/es6-in-depth-generators/"/>
      <url>/2016/09/10/es6-in-depth-generators/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我很激动. 今天我们将要讨论es6最魔性的特性.</p><p>我说的魔性是什么意思? 对新手来说这个特性与已知的js差别比较大. 刚开始看的时候可能觉得很神秘. 总之他颠覆了语言的行为! 如果不是魔性那还是什么呢.</p><p>不仅如此: 这个特性还简化了代码, 神奇地纠正了”callback hell”(多层回调).</p><p>我是不是说得太抽象了? 那就开始研究然后你自己感受吧.</p><h2 id="生成器介绍"><a href="#生成器介绍" class="headerlink" title="生成器介绍"></a>生成器介绍</h2><p>什么是生成器?</p><p>让我们从看一个生成器开始.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">quips</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&quot;hello &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&quot;i hope you are enjoying the blog post&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(name.<span class="title function_">startWith</span>(<span class="string">&#x27;X&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&quot;it&#x27;s cool your name start with X, &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&quot;see you later&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<a href="http://people.mozilla.org/~jorendorff/demos/meow.html">会说话的猫</a>的一部分代码, 这可能是现在网上最重要的应用. (<a href="http://people.mozilla.org/~jorendorff/demos/meow.html">点击链接来玩玩吧</a>你觉得疑惑的时候可以回来这里看解释).</p><p>他看起来是一种函数吧? 他的名字是<em>生成器函数(generator-function)</em>, 和函数有很多共同点. 但你会发现有以下两点不同:</p><ul><li>普通函数以<code>function</code>开头, 生成器函数以<code>function*</code>开头.</li><li>在生成器函数内部<code>yield</code>是一个类似于<code>return</code>的关键字.不同点是普通函数(生成器函数也是如此)只能return一次, 而生成器函数可以yield任意次数. <code>yield</code>表达式可以被<em>延缓执行, 并在稍后被继续.</em></li></ul><p>就是这些, 以上是普通函数和生成器函数的大的区别之处. 普通函数不能暂停执行, 而生成器函数可以哦.</p><h2 id="生成器能干啥"><a href="#生成器能干啥" class="headerlink" title="生成器能干啥"></a>生成器能干啥</h2><p>当你调用生成器函数<code>quips()</code>会发生什么呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> iter = <span class="title function_">quips</span>(<span class="string">&quot;jorendorff&quot;</span>);</span><br><span class="line">  [object <span class="title class_">Generator</span>]</span><br><span class="line"></span><br><span class="line">&gt; iter.<span class="title function_">next</span>();</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="string">&quot;hello jorendorff!&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; iter.<span class="title function_">next</span>();</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="string">&quot;i hope you are enjoying the blog posts&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; iter.<span class="title function_">next</span>();</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="string">&quot;see you later!&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; iter.<span class="title function_">next</span>();</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可能对普通函数的行为很熟悉. 当你调用他们, 他们马上执行, 运行到return或者报错为止. 这是js程序员的本能.</p><p>看起来相同的对于生成器的调用:<code>quips(&#39;jorendorff&#39;)</code>. 但你调用了生成器以后什么也不会执行. 而是返回了一个生成器对象(<em>generator object</em>)(就是上面代码中的<code>iter</code>). 你可以认为生成器对象是’被暂停的函数调用’. 正是暂停在生成器的头部, 执行他的第一行代码的前面.</p><p>每次你调用生成器的<code>.next()</code>方法, 函数会执行到下一个<code>yield</code>表达式.</p><p>这就是为什么每次我们调用了<code>iter.next()</code>都会得到一个不同的字符串. 这是<code>quips()</code>函数体中<code>yield</code>表达式产生的.</p><p>当执行到了最后的<code>iter.next()</code>, 我们走到了生成器方法的最后, 所以<code>.done</code>属性变为了<code>true</code>. 走到了方法的最后就好比返回了<code>undefined</code>, 这就是为什么<code>.value</code>的结果是undefined.</p><p>现在可以回到那个猫咪的应用来修改代码, 试试增加一个<code>yield</code>在循环中会发生什么?</p><p>技术层面来说, 每次生成器执行了<code>yield</code>, 他的栈的内容-本地变量, 参数, 临时变量, 当前执行的位置-都被移除了当前栈. 但生成器留了一份栈内容的复制来使调用<code>.next()</code>有响应并继续执行.</p><p>有必要指出<strong>生成器不是多线程</strong>. 多线程的语言中, 多个代码片可以同时运行, 经常会导致抢跑执行, 不确定性, 和不错的表现. 生成器完全不是那样的. 生成器随着调用地单线程执行. 执行顺序是有序的, 确定的, 不会同时运行. 和多线程系统不同, 生成器只会一直以<code>yield</code>标记的点挂在运行体上.</p><p>好了, 我们知道了什么是生成器了. 我们知道了生成器是如何运行的, 如何暂停运行的. 那么现在有个大问题, 他这个奇怪的能力有什么用呢?</p><h2 id="生成器是遍历器"><a href="#生成器是遍历器" class="headerlink" title="生成器是遍历器"></a>生成器是遍历器</h2><p>上周我们知道了es6的遍历器不只是单纯的内置类, 而是一个语法的拓展. 我们可以通过实现<code>[Symbol.iterator]</code>和<code>.next()</code>来创建自己的遍历器.</p><p>但实现接口虽是小工作但每次都要去做. 我们来看看实际代码里是怎么实现遍历器接口的. 我们先来做个简单的<code>range</code>遍历器, 他的作用是像老式的C的<code>for(;;)</code>循环一样一个个数数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样会&#x27;ding&#x27;三下</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;ding at floor#&quot;</span> + value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>有个解决方法, 可以使用es6的类 (如果class语法还不清晰, 不要担心-我们会在以后的文章讲到)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a new iterator that counts up from &#x27;start&#x27; to &#x27;stop&#x27;.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种遍历器的实现很像<code>Java</code>或是<code>Swift</code>. 这样还是可以的, 但这样很不仔细, 这样的代码会不会有什么bug? 很难说. 他看起来就像原来的<code>for(;;)</code>循环. 而我们正在尝试的是废除这样的循环.</p><p>到这儿你可能对遍历器有点灰心了. 他用起来可能很厉害, 但很难去实现. </p><p>你应该不会去开发一种自创的, 很绕的, 新的控制流程来让遍历器更容易构建, 但我们有了生成器, 要不要试试?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">range</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; stop; i++ )</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这4行很简单的代码替代了23行对<code>range()</code>的实现. 包括整个<code>RangeIterator</code>类. 做到这点是因为生成器就是遍历器. 所有生成器都有<code>.next()</code>方法和[Symbol.iterator]. 你只需要写循环行为的逻辑就可以了.</p><p>不用生成器地去实现一个遍历器就像用被动语态写一篇很长的邮件. 如果没有告诉你这只是一个可选项的时候你可能最后会觉得这个代码太麻烦了. <code>RangeIterator</code>又长又怪因为这段代码没有用循环地去函数. 生成器是一个解决方案.</p><p>我们还可以怎么利用生成器是遍历器这个特性?</p><ul><li><strong>让任何对象可遍历.</strong> 只需写一个遍历<code>this</code>的生成器, yield每个键值. 然后把这个生成器作为对象的<code>[Symbol.iterator]</code>属性.</li><li><strong>简化组合成数组的函数.</strong> 假设你有一个方法希望每次调用返回一个数组结果集, 类似下面的:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Divide the one-dimensional array &#x27;icons&#x27;</span></span><br><span class="line"><span class="comment">// into arrays of length &#x27;rowLength&#x27;.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">splitIntoRows</span>(<span class="params">icons, rowLength</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> rows = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; icons.<span class="property">length</span>; i += rowLength) &#123;</span><br><span class="line">    rows.<span class="title function_">push</span>(icons.<span class="title function_">slice</span>(i, i + rowLength));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成器让这种代码更短了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">splitIntoRows</span>(<span class="params">icons, rowLength</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; icons.<span class="property">length</span>; i += rowLength) &#123;</span><br><span class="line">    <span class="keyword">yield</span> icons.<span class="title function_">slice</span>(i, i + rowLength);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的不同行为是生成器没有一次性计算出结果并返回, 而是返回了一个遍历器, 然后按需执行并返回.</p><ul><li><p><strong>非通常的结果集.</strong> 你不能构造一个无限的数组. 但你可以返回一个产生无限数据的生成器. 这样调用者不管需要多少返回值都可以拿到.</p></li><li><p><strong>重构复杂的循环.</strong> 你有一个很丑很大的函数吗? 你想不想把他分成两个稍简略的部分? 生成器就像一把重构你代码的新刀. 当你遇见复杂的循环, 你可以把产生数据的部分代码剥离成一个生成器, 然后把循环变为<code>for (var data of myNewGenerator(args))</code>.</p></li><li><p><strong>利用遍历器的工具.</strong> es6没有为filter, map提供拓展lib, 而生成器可以遍历任何数据结构. 生成器可以用很少的几行代码来构建成你需要的工具.</p></li></ul><p>打个比方, 假设你你需要像<code>Array.prototype.filter</code>一样处理DOM节点列表, 而不只像数组一样, 以下是一部分代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">filter</span>(<span class="params">test, iterable</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">test</span>(item))</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成器是不是很有用? 当然了. 他可以用简单得惊人的方法来实现自定义遍历器, 而遍历器正式es6新的遍历数据的方式!</p><p>但以上还不是生成器全部可以做的事. 你能用他做的最重要的事还我还没开始说呢.</p><h2 id="生成器与异步代码"><a href="#生成器与异步代码" class="headerlink" title="生成器与异步代码"></a>生成器与异步代码</h2><p>以下是一些我写过的js代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也许你也在你的代码里见过如此的东西. <a href="http://www.html5rocks.com/en/tutorials/async/deferred/">异步编程</a>通常需要回调, 意味着每次你需要做一件事情的时候就要多写一个匿名函数. 所以如果你在很少的代码里做了三件事, 你会看到三个缩进块, 而不是简单的三行代码.</p><p>以下也是我写过的一些js代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;).<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">done</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line">&#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="title function_">done</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>异步编程api有的是错误处理而不是异常处理. 不同的api有不同的规定. 大多数错误都会被默认得静默处理, 另外一部分规定普通的成功回调也会被默认静默处理.</p><p>生成器提供了我们不需要这么做的希望.</p><p><a href="https://github.com/kriskowal/q/tree/v1/examples/async-generators">Q.async()</a>是一个实验性质的尝试, 用promise和生成器来使异步代码看起来像同步代码. 比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeNoise</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">shake</span>();</span><br><span class="line">  <span class="title function_">rattle</span>();</span><br><span class="line">  <span class="title function_">roll</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Asynchronous code to make some noise.</span></span><br><span class="line"><span class="comment">// Returns a Promise object that becomes resolved</span></span><br><span class="line"><span class="comment">// when we&#x27;re done making noise.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeNoise_async</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> Q.<span class="title function_">async</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">shake_async</span>();</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">rattle_async</span>();</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">roll_async</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的区别在于异步版本必须在每个调用异步方法的地方加上<code>yield</code>关键字.</p><p>如果在<code>Q.async</code>版本加上像<code>if</code>语句或<code>try/catch</code>代码块实际只是加上了普通的异步方法. 和别的异步代码比, 这样不会像在学一门新语言一样.</p><p>如果你对这些比较深入了, 可以去看一下James Long的<a href="/2016/09/16/a-study-on-solving-callbacks-with-javascript-generators">对这个专题的深入研究</a>.</p><p>所以生成器为异步编程模型对人脑更友好指了一条明道. 这些工作仍在进行中. 在其余的研究中有有帮助的更好的语法. <a href="https://github.com/tc39/ecmascript-asyncawait">异步编程的一个提案</a>建立在promise和generator上, 也吸收了C#的灵感, 已经在<a href="https://github.com/tc39/ecma262">es7草案</a>上了.</p><h2 id="我们什么时候需要用这些疯狂的东西"><a href="#我们什么时候需要用这些疯狂的东西" class="headerlink" title="我们什么时候需要用这些疯狂的东西?"></a>我们什么时候需要用这些疯狂的东西?</h2><p>在服务端, 我们可以在node上用es6了.</p><p>在浏览器, 可以用现代的浏览器或者用Babel来写es6.</p><p>有一些组织说: 生成器第一次被引入js, 和python的生成器很像.</p><h2 id="yields"><a href="#yields" class="headerlink" title="yields;"></a>yields;</h2><p>关于生成器还有一些要说的. 我们还没有讲到<code>.throw()</code>和<code>.return()</code>方法, <code>.next()</code>方法的可选参数, 或者是<code>yiled*</code>语法. 但我觉得这篇文章已经够长了. 就像生成器一样, 我们也要暂停一下, 然后在以后的时间继续.</p><p>但在下周, 我们会稍微改变下节奏. 我们已经一下子说了两个比较深的主题了. 下次可以说一些不会改变你生活的es6特性. 一些又简单又明显有用的. 能让你会心一笑的. es6也有一些这样的特性的.</p><p>接下来: 一些会对你每天都要写的代码有影响的东西. 请期待下周的es6-in-depth之模板字符串.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 遍历器 和 for-of 循环</title>
      <link href="/2016/09/10/es6-in-depth-iterators-and-the-for-of-loop/"/>
      <url>/2016/09/10/es6-in-depth-iterators-and-the-for-of-loop/</url>
      
        <content type="html"><![CDATA[<p>你是如何循环一个数组的元素的呢？ 用javascript的话, 20年前你可能是这么做的: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自从有了es5, 你可以用内置的<code>forEach</code>方法: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样代码量少了一点, 但也有了一个小问题:  循环的时候不能用<code>break</code>语句或用<code>return</code>语句来退出当前方法.</p><p>如果可以使用for循环语法来循环数组元素那就好了.</p><p><code>for-in</code>循环张啥样？（如下）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;   <span class="comment">//事实上并不能这么干</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个坏主意因为: </p><ul><li><p>在这种代码里<code>index</code>接受到的参数是字符串类型的<code>&quot;0&quot;</code>,<code>&quot;1&quot;</code>,<code>&quot;2&quot;</code>等等, 并不是数字. 如果你不想发生字符串计算的话（<code>&quot;2&quot; + 1 == &quot;21&quot;</code>）, 这种代码最不方便了.</p></li><li><p>这样的代码执行得到的不只是数组的元素, 还能得到其他被人加上的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Expando">expando</a>属性. 比方:  你的数组有个可被枚举(enumerable)的属性<code>myArray.name</code>, 那么这个循环会知道到一次额外的<code>index == &quot;name&quot;</code>. 只要在数组原型链上的属性可以被访问.</p></li><li><p>其中最让人咋舌的是, 在某些情况下, 这个循环数组元素的顺序是随机的.</p></li></ul><p>总的来说, <code>for-in</code>是为了遍历原生的<code>Object</code>对象的字符串类型的键设计的. 对于<code>Array</code>来说并不怎么能使用.</p><h2 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h2><p>记得我上周打赌es6会打破你之前写的js的样子. 好了, 一万个网站都是用<code>for-in</code>的, 甚至作用在数组上. 而且从来没有任何想“修复”<code>for-in</code>在数组上行为的课题. es6唯一来改进这个行为的方法是如下的新的循环语法: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯嗯, 看了写法以后, 感觉好像没什么特别的. <code>for-of</code>循环到底有什么特别的地方呢, 我们马上来看: </p><ul><li>这是有史以来循环数组元素最简要、直接的语法.</li><li>他避免了所有<code>for-in</code>的坑</li><li>不像<code>forEach()</code>, 他可以随时<code>break</code>,<code>continue</code>,或者<code>return</code>.</li></ul><p><code>for-in</code>循环用来循环对象的属性.<br><code>for-of</code>循环用来循环类似在数组里的值的数据.</p><p>但这还不是全部.</p><h2 id="也有别的数据类型支持for-of"><a href="#也有别的数据类型支持for-of" class="headerlink" title="也有别的数据类型支持for-of"></a>也有别的数据类型支持for-of</h2><p><code>for-of</code>循环不止可以用在数组, 也可能在类数组的对象上生效, 比如<code>NodeList</code>.</p><p>也可能作用在字符串上, 把字符串当成Unicode字母的序列.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> chr <span class="keyword">of</span> <span class="string">&quot;😺😲&quot;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(chr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也能在<code>Map</code>和<code>Set</code>对象上生效.</p><p>噢抱歉. 你从来没听过<code>Map</code>和<code>Set</code>对象？ 他们是es6新加的. 以后会有整章来说他们的特点. 如果你在其他语言里用过map和set, 那对你来说不是大变化.</p><p>比如, <code>Set</code>对象是用来去重的: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用一个words的数组生成一个set</span></span><br><span class="line"><span class="keyword">var</span> uniqueWords = <span class="keyword">new</span> <span class="title class_">Set</span>(words);</span><br></pre></td></tr></table></figure><p>一但你得到了一个<code>Set</code>, 你就可以来简单得循环他: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> word <span class="keyword">of</span> uniqueWords) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code>有一点点不同:  里面的数据由键值对组成, 所以你想<code>destructuring</code>来把键值拆开: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">For</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> phoneBookMap) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;的电话是: &quot;</span> + value) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>destructuring</code>也是es6的一个新特性, 我也会写一个专题来介绍他.</p><p>到了现在, 你已经感受到了:  js已经有了一些不同的数据类型, 还可能更多. <code>for-of</code>就是用来遍历他们的.</p><p><code>for-of</code>不可以用在原生的<code>Object</code>上了, 但你还是想遍历对象属性的话可以这么用: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把一个对象可枚举的属性打出来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(someObject)) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;:&quot;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><blockquote><p>一般的人模仿, 厉害的人借鉴. —Pablo Picasso</p></blockquote><p>es6发展加入的新特性并非无中生有. 大多数都是别的语言中尝试过和被证明是有用的特性.</p><p>比如<code>for-of</code>循环, 和C++, Java, C#, 和Python的语法很像. 和他们一样, 他作用于自己语言和标准的不同数据结构上. 但他仍是一个语言的拓展点. </p><p>和别的语言的<code>for</code>&#x2F;<code>foreach</code>一样, <strong><code>for-of</code>完全以函数调用的形式工作</strong>. <code>Array</code>, <code>Map</code>, <code>Set</code>和一些其他对象都有一个共同点就是有遍历器方法。</p><p>还有一种对象可以有遍历器方法, 这个对象就是: <em>你需要的任何对象</em>.</p><p>就像你把<code>myObject.toString()</code>方法添加给对象来使js知道如何将这个对象转为字符串, 你可以添加<code>myObject[Symbol.iterator]()</code>方法给对象来使js知道怎么来循环他.</p><p>举个例子, 假设你再用jQuery, 当然你已经知道有<code>.each()</code>这个方法了, 但你想让jQuery也可以使用<code>for-of</code>的话, 以下是如何做到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为jQuery对象是类数组的, 所以就赋给他数组的遍历器</span></span><br><span class="line">jQuery.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = </span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br></pre></td></tr></table></figure><p>好吧, 我知道你在想啥. 那个<code>[Symbol.iterator]</code>语法看起来好奇怪. 这里发生了什么?<br> 他的行为等价于方法名字. 标准委员会本想就简单得把方法名字叫做<code>.iterator()</code>, 但当你的代码有一个<code>.iterator()</code>方法的时候就让人觉得很搞了. 所以在标准中使用了<em>symbol</em>而不是字符串, 来作为这个方法的名字.</p><p>Symbol也是一个es6的一个新特性, 然后(正如你所猜测的)我会在以后的文章里说到.你现在只需要知道, 我们可以定义一个symbol, 就像<code>Symbol.iterator</code>, 他保证了不与现有的代码冲突. 代价是他的语法很奇怪. 但相对于他的通用性和以后的良好兼容的成果来说这是个很小的代价了.</p><p>拥有<code>[Symbol.iterator]()</code>方法的对象我们称为可遍历的(interable). 下周的文章我们会了解可遍历对象的概念贯穿了js语言的使用, 不仅在<code>for-of</code>, 还有<code>Map</code>和<code>Set</code>的构造方法, destructuring 赋值, 和新的操作符 spread.</p><h2 id="可遍历对象"><a href="#可遍历对象" class="headerlink" title="可遍历对象"></a>可遍历对象</h2><p>恩, 你可能永远不会自己从头开始用可遍历对象. 我们会在下周讨论, 但为了完整性, 我们来看一下可遍历对象张啥样. (如果你跳过了整个章节, 你很可能会错过零碎的技术细节.)</p><p>一个<code>for-of</code>循环从调用对象的<code>[Symbol.iterator]</code>方法开始. 调用以后会得到一个新的可遍历对象. 一个可遍历对象可以是任何拥有<code>.next()</code>方法的对象; <code>for-of</code>循环会重复得调用这个方法, 每次循环调用一次. 举个例子吧, 下面是我能想到的最简单的可遍历对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zeroForeverIterator = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>; </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次这里的<code>.next()</code>方法被调用都会返回一个相同的结果, 告诉<code>for-of</code>循环我们还没有遍历完; 并且返回的value是0.<br>这意味着<code>for (value of zeroForeverIterator) &#123;&#125;</code>将是一个无限循环. 当然一个普通的遍历器不会像这次尝试一样.</p><p>这种有着<code>.done</code>和<code>.value</code>属性的遍历器设计, 看起来和其他语言的遍历器工作方式不同. Java里遍历器有<code>.hasNext()</code>和<code>.next()</code>方法. Python里只有<code>.next()</code>方法并会在没有值来进行遍历的时候抛出<code>StopIteration</code>. 但三种设计其实包含的基本信息是一样的.</p><p>可遍历对象也可以选择性得包含<code>.return()</code>和<code>.throw(exc)</code>方法. <code>for-of</code>循环会在循环因为<code>break</code>或<code>return</code>语句过早退出的时候调用<code>.return().</code>如果遍历器需要清理或释放正在使用的资源那就可以包含<code>.return()</code>方法, 大多数遍历器不需要. <code>.throw(exc)</code>方法比较特殊: <code>for-of</code>永远不会调用他. 我们会在下篇文章更多了解他.</p><p> 我们已经知道了所有的细节, 现在我们可以写一个简单的<code>for-of</code>循环并重载他隐性调用的方法了.</p><p>首先写一下<code>for-of</code>循环:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable constant_">VAR</span> <span class="keyword">of</span> <span class="variable constant_">ITERABLE</span>) &#123;</span><br><span class="line">    <span class="variable constant_">STATEMENTS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下这段代码是差不多等价的, 用了隐性方法和一些临时变量.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $interator = <span class="variable constant_">ITERABLE</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">while</span> (!$result.<span class="property">done</span>) &#123;</span><br><span class="line">    <span class="variable constant_">VAR</span> = $result.<span class="property">value</span>;</span><br><span class="line">    $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码没有表现<code>.return()</code>是如何处理的.<br>我可以加上, 但我觉得会使我们搞不清发生了什么, 更不用说原理了.<br><code>for-of</code>循环很容易用, 但底层有很多内容.</p><h2 id="我们什么时候可以开始用他"><a href="#我们什么时候可以开始用他" class="headerlink" title="我们什么时候可以开始用他?"></a>我们什么时候可以开始用他?</h2><p><code>for-of</code>循环被现在所有火狐支持. chrome的话要去<code>chrome://flags</code>开启’Experimental JavaScript’选项. 也被微软的浏览器spartan支持(并不是IE). 当然如果你你需要支持IE或者Safari, 你可以使用类似<code>Babel</code>或谷歌的<code>Traceur</code>这样的编译器来把你的es6代码转为es5.</p><p>如果是服务端, 就不需要编译器了. 高版本的nodejs就可以.</p><h2 id="done-true"><a href="#done-true" class="headerlink" title="{done: true}"></a>{done: true}</h2><p>哦耶!</p><p>这篇文章结束啦, 但我们在<code>for-of</code>的学习还没有结束.</p><p>还有更多es6的新品种对象可以和<code>for-of</code>一起工作. 因为是下周的主题所以我没提. 我觉得这是es里最魔性的新特性. 如果你已经在Python和C#里遇到过你可能会觉得吃惊. 但这是写遍历器最简单的方法, 并且对重构友善, 改变你写异步代码的方式, 无论在浏览器还是服务端. 敬请期待下周的es6-in-depth之生成器.</p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 in depth 介绍</title>
      <link href="/2016/09/10/es6-in-depth-an-introduction/"/>
      <url>/2016/09/10/es6-in-depth-an-introduction/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到es6 in depth系列！ 这个系列我们将探索es6-将要到来的js新版本. es6包含了许多让js更强力更有表达性的新特性, 我们讲在系列中一一深入. 但在我们开始前, 也许可以花一些时间来说说es6是什么和你可以期待es6能干什么.</p><h2 id="ESMAScript的研究带来了什么？"><a href="#ESMAScript的研究带来了什么？" class="headerlink" title="ESMAScript的研究带来了什么？"></a>ESMAScript的研究带来了什么？</h2><p>javascript编程语言是基于ECMA标准的（就像html是基于W3C）, 叫做EMACScript. ECMAScript在这里定义了: </p><ul><li>语法 - parse规则, 关键字, 语句, 声明, 操作等.</li><li>类型 - 布尔, 数字, 字符串, 对象等.</li><li>prototype和继承</li><li>内置对象和函数的标准api - <code>JSON</code>,<code>Math</code>,<code>Array</code>方法, 对象内置方法等</li></ul><p>而没有定义任何<code>HTML</code>,<code>CSS</code>或者<code>Web API</code>, 比如<code>DOM</code>. 他们被分开维护. ECMAScript 覆盖的标准是:  不仅存在于浏览器切能用于非浏览器环境的js比如<code>node.js</code> 这种方面的js.</p><h2 id="新标准"><a href="#新标准" class="headerlink" title="新标准"></a>新标准</h2><p>上周, ECMAScript版本6的最终草案被提交到了<code>Ecma General Assembly</code>来review了. 这意味着什么？</p><p>这意味着这个夏天, <em>我们会有一个新的Javascript的语言标准了.</em></p><p>这是一个大新闻. 不是每天都会发布一个新的js版本的. 上一个版本, es5, 是在2009年发布的. 之后es标准委员会就一直在进行es6的工作了.</p><p>es6的主要更新在语法上. 同时你之前的js代码也能运行. es6的设计最大程度得与现有代码契合. 其实已经有很多浏览器支持各种各样的es特性, 并且在继续实现更多特性. 这代表你的js代码已经可以在有用es6特性的浏览器上运行啦！ 如果你至今没有遇到es6和之前版本的兼容问题, 那可能以后也不会有哦.</p><h2 id="数到6"><a href="#数到6" class="headerlink" title="数到6"></a>数到6</h2><p>之前的的ECMAScript标准版本号是 1 2 3 5.</p><p>版本4怎么了呢？ 版本4曾经被规划过 – 而且已经完成了很多版本4的工作 – 然后最终因为改动太大被废弃了. （比如他曾经设计了复杂的接口类型的内置静态类型属性）</p><p>es4是有争议的. 当标准委员会最终停止es4的工作, 委员会成员赞成发布一个相对稳健的es5版本并开发稳定的新特性. 这个明确的, 商讨过的协议被称为 “harmony”. 这也是为什么es5的说明会有这样的话: </p><blockquote><p> ECMAScript 是一个充满活力的语言, 并且语言的进化还未完成.今后的版本会有显著的技术提升.</p></blockquote><p>这句话可以被看成一种保证.</p><h2 id="承诺实现"><a href="#承诺实现" class="headerlink" title="承诺实现"></a>承诺实现</h2><p>2009年更新的es5语言有了<code>Object.create()</code>,<code>Object.defineProperty()</code>,<code>getters</code>和<code>setter</code>,<code>strict mode</code>, 和<code>JSON</code>对象. 我们已经使用了所有这些特性, 我很喜欢es5对语言做的事. 但还很难说这让我写js代码的方式有很大的变化. 对我来说最大的发明是新的数组方法: <code>.map()</code>, <code>.filter()</code>等.</p><p>然后呢, es6很不同. 他是多年“harmony”工作的结果. 他是一个新语法特性的宝藏, 是js有史以来最大的更新. 新特性包含了受欢迎的方便性, 比如箭头函数和简单的字符串插值, 和烧脑的新概念, 比如代理和生成器. </p><p>es6会改变你编写js的方式.</p><p>这个系列会通过深入es6提供给程序员的新特性来给你看es6的面貌.</p><p>我们会从经典的‘缺失的特性’（我们早就希望在js特性里出现的特性）来开始说. 所以下周的主题是es6的<code>iterator</code>和新的<code>for-of</code>循环. </p><hr><p>es in depth 系列 <a href="/2016/09/10/es6-in-depth-content/">目录</a> <a href="https://hacks.mozilla.org/category/es6-in-depth/">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
            <tag> 深入es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强力3D的PPT 介绍</title>
      <link href="/2016/09/04/web-ppt-js-lib-impress-js/"/>
      <url>/2016/09/04/web-ppt-js-lib-impress-js/</url>
      
        <content type="html"><![CDATA[<p>要做ppt, 从小都没做过, 怎么办, 本劳资好紧张, 看到个有意思的ppt lib, 赶紧试一发.</p><span id="more"></span><h2 id="隆重介绍这个ppt的lib（其实是远古年代的了）"><a href="#隆重介绍这个ppt的lib（其实是远古年代的了）" class="headerlink" title="隆重介绍这个ppt的lib（其实是远古年代的了）"></a>隆重介绍这个ppt的lib（其实是远古年代的了）</h2><p><a href="https://github.com/impress/impress.js">IMPRESS.JS</a><br>api和用法都非常简单, 只是对3D的调试和设计可能需要一点心思.<br>（本文完）</p><h2 id="impress-js-api-简单介绍"><a href="#impress-js-api-简单介绍" class="headerlink" title="impress.js api 简单介绍"></a>impress.js api 简单介绍</h2><ul><li>这个lib的启动方式是寻找id与class来启动应用. </li><li>启动之后提供的api只有一个: 翻页, 各种翻, 向前先后、根据id根据顺序, 效果是改变hash.</li><li>提供了3个状态class分别为<code>past</code>,<code>present</code>,<code>future</code>, 作用的话聪明的你一看就知道了.</li></ul><p>完, api就是这么少, 这么简单, 所以这个lib很强, 难的是设计.</p><p>我用angular把以上已经很简单的api封装了一下, 所以根本就不需要去启动应用了.<br>只需要把ppt写在<code>ppt</code>,<code>slide</code>这2个标签里, 再代码里配置下每个<code>slide</code>的位置就ok.<br><a href="https://github.com/fjonas/ng1-impress-ppt">repo地址</a></p><h2 id="3D系统介绍"><a href="#3D系统介绍" class="headerlink" title="3D系统介绍"></a>3D系统介绍</h2><p>这里是重点. ppt的位置属性一共有8个:<br><code>x</code>,<code>y</code>,<code>z</code>,<code>scale</code>,<code>rotate</code>,<code>rotate-x</code>,<code>rotate-y</code>,<code>rotate-z</code>. 作用都是字面意思.</p><p>我的经验: </p><ul><li>以几张关系密切需要明确定位的slide为基准, 基准ppt的<code>x</code>,<code>y</code>以外所有属性不要变. 因为任何<code>rotate</code>,<code>scale</code>属性会导致你的(其实是我的)大脑跟不上节奏.</li><li>在主场景和分镜切换多使用<code>scale</code>, 这样感觉很帅.</li><li>past和future设置0.3左右的透明度, present类可以作为入场动画的类.</li><li>整个ppt其实是一个3D场景, 这个思路很重要, 我们切换slide只是在场景中切换镜头.</li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>这个ppt已经很厉害了, 展望的内容为:  </p><ol><li>封装、抽象位置信息, 提供容易被想象的api来map那些属性.</li><li>每个slide页提供方便、 多功能的编写方式.</li><li>通过文件build页面.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改hexo主题(Jade版本)</title>
      <link href="/2016/08/29/modify-hexo-theme-of-jade/"/>
      <url>/2016/08/29/modify-hexo-theme-of-jade/</url>
      
        <content type="html"><![CDATA[<p>hexo主题虽多, 但是都没让自己完全舒服的, 真的没什么意思, 就着现在用的主题来修改吧.</p><span id="more"></span><p>用的主题是jade写的, 稍微了解了下, 就是一个模板什么的, 气氛搞起来.</p><h2 id="插入一个js"><a href="#插入一个js" class="headerlink" title="插入一个js"></a>插入一个js</h2><p>看了下模板, 大多模板都是继承(<code>extends</code>)了一个叫<code>base.pug</code>的模板, 那么好了,找到了这个模板, 根据以下引入方式: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">script</span>(type=<span class="string">&#x27;text/javascript&#x27;</span>, src=<span class="string">&#x27;//cdn.bootcss.com/jquery/3.0.0/jquery.min.js&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">link</span>(rel=<span class="string">&#x27;stylesheet&#x27;</span>, type=<span class="string">&#x27;text/css&#x27;</span>, href=<span class="title function_">url_for</span>(theme.<span class="property">css</span>) + <span class="string">&#x27;/style.css&#x27;</span> + <span class="string">&#x27;?v=&#x27;</span> + theme.<span class="property">version</span>)</span><br></pre></td></tr></table></figure><p>上面这个是引入自定义样式吧, 那如果我有样式直接写里面好了, 不再引入了, 注意到他引入的时候<code>url_for</code>这个函数, 我并不知道是干嘛的.<br>所以抱着试一试的想法写了<code>url_for(theme.js)</code>,如下: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">script</span>(type=<span class="string">&#x27;text/javascript&#x27;</span>, src=<span class="title function_">url_for</span>(theme.<span class="property">js</span>) + <span class="string">&#x27;/main.js&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后在对应js文件下打了一下控制台, 成功了, 还真对得起我这张脸.</p><h2 id="jade的模板继承"><a href="#jade的模板继承" class="headerlink" title="jade的模板继承"></a>jade的模板继承</h2><p>官方是这么说的, 其实就是个模板的复用.<br>（因为英文不好看半天才明白原来这么简单的东西）</p><p>举个伪代码的例子: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名: parent.pug</span></span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">        title i am title</span><br><span class="line">        block script</span><br><span class="line">    block body</span><br><span class="line">    block foot</span><br></pre></td></tr></table></figure><p>上面的模板出现了3个block, 如果有模板extends了这个模板, 只要改写block就可以重载这个block的部分而继承父的其他结构.<br>比如: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extends</span> <span class="string">&#x27;./parent.pug&#x27;</span></span><br><span class="line">block script</span><br><span class="line">    <span class="title function_">script</span>(src=<span class="string">&#x27;jquery.js&#x27;</span>)</span><br><span class="line">block foot</span><br><span class="line">    div.<span class="property">footer</span></span><br><span class="line">        copyright <span class="number">1991</span>~<span class="number">2016</span></span><br></pre></td></tr></table></figure><p>效果就是这个页面继承了父的内容, 并引入了jquery, 把页脚加了版权信息.</p><p>**对于我们的应用:  我在<code>base.pug</code>中加入了block script, 这样就可以在不同的模板中自定义引入哪些js了.</p><h2 id="引入小模块"><a href="#引入小模块" class="headerlink" title="引入小模块"></a>引入小模块</h2><p>语法是<code>include</code>, 引入文件可以不加拓展名, 需要是jade文件.<br>比如tag, footer 等小模块就可以如此引入.</p><h2 id="我修改的内容"><a href="#我修改的内容" class="headerlink" title="我修改的内容"></a>我修改的内容</h2><ul><li>修改背景</li><li>把博客的链接指向改为新tab页面</li><li>用插件增强md代码快</li><li>增加post模板的页尾</li><li>把火箭回到顶部改为kotori回到顶部</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用angular1.4, es2015, webpack, angular-material来搭建一个app</title>
      <link href="/2016/08/09/creating-an-application-with-angularjs-1-4-ecmascript-6-material-design-and-webpack/"/>
      <url>/2016/08/09/creating-an-application-with-angularjs-1-4-ecmascript-6-material-design-and-webpack/</url>
      
        <content type="html"><![CDATA[<p>介绍了如何用webpack构建ng1+es6应用, 原文: <a href="http://julienrenaux.fr/2015/05/05/creating-an-application-with-angularjs-1-4-ecmascript-6-material-design-and-webpack/">Creating an application with AngularJS 1.4, ECMAScript 6, Material Design and Webpack</a></p><span id="more"></span><h2 id="来学一下如何用ng1-4-es6-material-design和webpack来做一个应用吧！"><a href="#来学一下如何用ng1-4-es6-material-design和webpack来做一个应用吧！" class="headerlink" title="来学一下如何用ng1.4, es6, material design和webpack来做一个应用吧！"></a>来学一下如何用ng1.4, es6, material design和webpack来做一个应用吧！</h2><p>angular1.4发布了.（现在1.x的最后版本是<strong>1.5.8</strong>, 1.5.9好像僵死在了beta).</p><p>现在要介绍一个新的路由: 一个由Pascal Percht开发的类似于angular-translate的转换系统, 加强了webpack, 没有‘劫持’的Browserify支持(CommonJS)(Browserify就是在web应用里可以像node一样require lib的一个lib). 你可以像这样直接import angular: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;angular/angular.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>而不是这样: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;expose?angular!exports?window.angular!angular/angular.js&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p><a href="https://github.com/shprink/angular1.4-ES6-material-webpack-boilerplate">这是demo地址</a></p><hr><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="依赖-package-json"><a href="#依赖-package-json" class="headerlink" title="依赖(package.json)"></a>依赖(package.json)</h3><p>这个教程里我们会使用<code>AngularJS</code>,<code>Angular Material</code>,<code>UI router</code>（一个还没能可以上生产的路由）（其实现在早可以上了, 这文章在一年前, 作者眼光真是厉害）和<code>icon library</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;angular&quot;</span>: <span class="string">&quot;~1.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;angular-animate&quot;</span>: <span class="string">&quot;~1.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;angular-aria&quot;</span>: <span class="string">&quot;~1.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;angular-material&quot;</span>: <span class="string">&quot;^0.10.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;angular-ui-router&quot;</span>: <span class="string">&quot;^0.2.14&quot;</span>,</span><br><span class="line">    <span class="string">&quot;font-awesome&quot;</span>: <span class="string">&quot;^4.3.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>如果你想知道webpack是干嘛的, 我建议你看我的上篇博客.</p><p>我们要让webpack的加载器去编译es6并处理css和html文件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;babel-loader&quot;</span>: <span class="string">&quot;^5.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.12.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;file-loader&quot;</span>: <span class="string">&quot;^0.8.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;html-loader&quot;</span>: <span class="string">&quot;^0.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^1.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.12.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code>也是不能再简单了: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./lib/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;./www&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle-[hash:6].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">loaders</span>: [&#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;file?name=templates/[name]-[hash:6].html&#x27;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;style!css&quot;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;ng-annotate?add=true!babel&quot;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">test</span>: [<span class="regexp">/fontawesome-webfont\.svg/</span>, <span class="regexp">/fontawesome-webfont\.eot/</span>],</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;file?name=fonts/[name].[ext]&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./lib/index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="入口文件-lib-x2F-index-js"><a href="#入口文件-lib-x2F-index-js" class="headerlink" title="入口文件(lib&#x2F;index.js)"></a>入口文件(lib&#x2F;index.js)</h2><p>下面这个入口文件集合了我们应用的所有基本依赖的库: Angular, Material Design, 路由和icon.<br>我们用<code>import</code>这个es6的引入CommonJS模块的语法, 注入了<code>angularMaterial</code>和<code>angularUIRouter</code>作为模块依赖并输出默认模块.<br>（你可以在单个文件输出多个模块, 如果没指定import那么获取到的就是默认模块.）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import angular</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;angular/angular.js&#x27;</span>;</span><br><span class="line"><span class="comment">// Material design css</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;angular-material/angular-material.css&#x27;</span>;</span><br><span class="line"><span class="comment">// Icons</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;font-awesome/css/font-awesome.css&#x27;</span>;</span><br><span class="line"><span class="comment">// Materail Design lib</span></span><br><span class="line"><span class="keyword">import</span> angularMaterial <span class="keyword">from</span> <span class="string">&#x27;angular-material&#x27;</span>;</span><br><span class="line"><span class="comment">// Router</span></span><br><span class="line"><span class="keyword">import</span> angularUIRouter <span class="keyword">from</span> <span class="string">&#x27;angular-ui-router&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create our demo module</span></span><br><span class="line"><span class="keyword">let</span> demoModule = angular.<span class="title function_">module</span>(<span class="string">&#x27;demo&#x27;</span>, [</span><br><span class="line">    angularMaterial,</span><br><span class="line">    angularUIRouter</span><br><span class="line">])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> demoModule;</span><br></pre></td></tr></table></figure><hr><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>index.html要做2件事. 一个是启动应用（就是<code>ng-app=&quot;demo&quot;</code>）, 另外是引入js文件.（<code>src=&quot;&#123;\%=o.htmlWebpackPlugin.assets[chunk]\%&#125;&quot;</code>）.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-strict-di</span> <span class="attr">ng-app</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">        &#123;% for (var chunk in o.htmlWebpackPlugin.assets) &#123; %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;%=o.htmlWebpackPlugin.assets[chunk]%&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        &#123;% &#125; %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你现在应该已经让你的<code>demo</code>模块运行了. 为确信他已经运行让我们在入口文件添加一个打log的代码吧: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demoModule.<span class="title function_">run</span>(<span class="function">(<span class="params">$log</span>) =&gt;</span> &#123;</span><br><span class="line">    $log.<span class="title function_">info</span>(<span class="string">&#x27;demo running&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后看一下控制台！</p><hr><h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><h3 id="创建你自己的模块"><a href="#创建你自己的模块" class="headerlink" title="创建你自己的模块"></a>创建你自己的模块</h3><p>你的应用已经运行了, 我们来用es6创建一个home模块吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new module</span></span><br><span class="line"><span class="keyword">let</span> homeModule = angular.<span class="title function_">module</span>(<span class="string">&#x27;demo.home&#x27;</span>, []);</span><br><span class="line"><span class="comment">// Named export is needed to inject modules directly as Angular dependencies</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> homeModule = homeModule.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>和别的模块一样地注入: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&#x27;./home/home.module.js&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create our demo module</span></span><br><span class="line"><span class="keyword">let</span> demoModule = angular.<span class="title function_">module</span>(<span class="string">&#x27;demo&#x27;</span>, [</span><br><span class="line">    angularMaterial,</span><br><span class="line">    angularUIRouter,</span><br><span class="line">    home</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>我们建立一个controller<code>./home/controller</code>来让我们新的模块引入: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">$scope</span>) &#123;</span><br><span class="line">    <span class="string">&#x27;ngInject&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ngInject</code>是<code>ng-annotate</code>的注释, 让angular可以进入严格模式, 预知详情可以复制以下链接<strong><a href="http://julienrenaux.fr/2015/01/18/angularjs-1-x-open-source-projects-to-follow-in-2015/#Ng-Annotate">http://julienrenaux.fr/2015/01/18/angularjs-1-x-open-source-projects-to-follow-in-2015/#Ng-Annotate</a></strong></p><p>我们可以这样引入方法: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeModule = angular.<span class="title function_">module</span>(<span class="string">&#x27;demo.home&#x27;</span>, []);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeController</span> <span class="keyword">from</span> <span class="string">&#x27;./home.controller&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">homeModule.<span class="title function_">controller</span>(<span class="string">&#x27;HomeController&#x27;</span>, <span class="title class_">HomeController</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> homeModule = homeModule.<span class="property">name</span></span><br></pre></td></tr></table></figure><hr><h3 id="DEMO地址"><a href="#DEMO地址" class="headerlink" title="DEMO地址"></a>DEMO地址</h3><p><a href="https://github.com/shprink/angular1.4-ES6-material-webpack-boilerplate">demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> webpack </tag>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三分钟精通webpack</title>
      <link href="/2016/08/09/introduction-to-webpack-with-practical-examples/"/>
      <url>/2016/08/09/introduction-to-webpack-with-practical-examples/</url>
      
        <content type="html"><![CDATA[<p>带有实例的webpack介绍, 原文: <a href="http://julienrenaux.fr/2015/03/30/introduction-to-webpack-with-practical-examples/">Introduction to Webpack with practical examples</a></p><span id="more"></span><p><strong>webpack是一个模块化打包工具, 可以根据依赖处理模块来生成静态资源. 我们准备借鉴真实场景的应用作为例子来学习.</strong></p><hr><p>webpack正快速占领自动化构建市场. 我用了几个月, 在大部分需求上已经可以代替<code>Grunt</code>和<code>gulp</code>了.</p><h2 id="Webpack-加载器"><a href="#Webpack-加载器" class="headerlink" title="Webpack 加载器"></a>Webpack 加载器</h2><p>加载器是可以在编译中注入的代码片段, 加载器会在编译结束时被调用.</p><blockquote><p>webpack只能处理原生js, 而加载器用来把其他资源转化为js. 这样做的话每个资源都形成了一个模块.</p></blockquote><p><a href="https://github.com/shprink/webpack-examples">我是一个例子的链接</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>你的电脑上需要装好<a href="https://nodejs.org/">node</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure><p>现在新建个文件<code>webpack.config.js</code>然后输入这些: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>),</span><br><span class="line">    path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">debug</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">loaders</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面配置的意思大概是: 把入口文件设为<code>index.js</code>, 文件编译后会输出到<code>dist</code>这个目录里. （作者笔误拼错单词了:p）</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>你已经写好入口文件的话就可以用以下命令编译了.(我理解就是在主入口文件里require,import)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Debug mode</span></span><br><span class="line">webpack</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Production mode (minified version)</span></span><br><span class="line">webpack -p</span><br></pre></td></tr></table></figure><h2 id="ES2015编译"><a href="#ES2015编译" class="headerlink" title="ES2015编译"></a>ES2015编译</h2><p>ES2015引进了一些我们马上就可以使用的新特性（箭头函数, 类, 生成器, 模块等）.为了使用ES2015我推荐使用<a href="https://babeljs.io/">Babel</a></p><p>装一下babel: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader --save-dev</span><br></pre></td></tr></table></figure><p>在webpack配置里增加加载器: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.es6.js$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>你现在可以用ES2015写代码了, 需要根据配置里的正则引入, 当前的配置引入方式是&#96;require(‘.&#x2F;src&#x2F;index.es6.js’);</p><h3 id="编译结果"><a href="#编译结果" class="headerlink" title="编译结果"></a>编译结果</h3><p>作者用ES2015的生成器写了一个斐波那契数列的输出, 然后用webpack加babel编译成了es5. 顺便说一下, 好处很明显, 代码量变少了, 类型明确了, 在编译的层面上进行了jshint.</p><h4 id="编译前"><a href="#编译前" class="headerlink" title="编译前"></a>编译前</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generators</span></span><br><span class="line"><span class="keyword">var</span> fibonacci = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123;</span><br><span class="line">        <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur += temp;</span><br><span class="line">            <span class="keyword">yield</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = fibonacci;</span><br></pre></td></tr></table></figure><h4 id="编译后"><a href="#编译后" class="headerlink" title="编译后"></a>编译后</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fibonacci = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">    a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = regeneratorRuntime.<span class="title function_">mark</span>(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a, c, d;</span><br><span class="line">        <span class="keyword">return</span> regeneratorRuntime.<span class="title function_">wrap</span>(<span class="keyword">function</span> <span class="title function_">e</span>(<span class="params">b</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) <span class="keyword">switch</span> (b.<span class="property">prev</span> = b.<span class="property">next</span>) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                a = <span class="number">0</span>, c = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                d = a;</span><br><span class="line">                a = c;</span><br><span class="line">                c += d;</span><br><span class="line">                b.<span class="property">next</span> = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                b.<span class="property">next</span> = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> b.<span class="title function_">stop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, b, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = fibonacci;</span><br></pre></td></tr></table></figure><hr><p>这里有一段coffescript的编译介绍, 我不想看了, 本文头有原文链接.<br>作者用的lib叫<code>cofffee-loader</code>, 所有用法和es6是一样的.</p><hr><h2 id="引入css文件"><a href="#引入css文件" class="headerlink" title="引入css文件"></a>引入css文件</h2><p>装一下: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader --save-dev</span><br></pre></td></tr></table></figure><p>在webpack配置里增加一个加载器规则:<br><code>css-loader</code>会建立一个<code>style</code>标签在程序运行的时候注入页面. 还会在生产环境的时候自动压缩文件.生产环境是<code>-p</code>.e.g.<code>webpack -p</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>老规矩, 你要引入css的话就要符合正则: <code>require(&#39;./src/index.css&#39;)</code></p><hr><h2 id="给css自动加前缀"><a href="#给css自动加前缀" class="headerlink" title="给css自动加前缀"></a>给css自动加前缀</h2><p>装装装: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install autoprefixer-loader --save-dev</span><br></pre></td></tr></table></figure><p>我们很烦在各个浏览器上一些样式的写法是不同的.IE要加<code>-ms-</code>的前缀, 火狐是<code>-moz-</code>, chrome、opera、safari是<code>-webkit-</code>. 这个lib让您安心使用标准css, 不需要考虑浏览器语法兼容了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;css-loader!autoprefixer-loader&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>引入方式还是一样（我倒建议这里的规则要写特殊点, 毕竟前缀只是少数）</p><h3 id="编译结果-1"><a href="#编译结果-1" class="headerlink" title="编译结果"></a>编译结果</h3><h4 id="编译前-1"><a href="#编译前-1" class="headerlink" title="编译前"></a>编译前</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译后-1"><a href="#编译后-1" class="headerlink" title="编译后"></a>编译后</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;      <span class="comment">/* OLD - iOS 6-, Safari 3.1-6 */</span></span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;      <span class="comment">/* TWEENER - IE 10 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;     <span class="comment">/* NEW - Chrome */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;             <span class="comment">/* NEW, Spec - Opera 12.1, Firefox 20+ */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="编译SASS"><a href="#编译SASS" class="headerlink" title="编译SASS"></a>编译SASS</h2><p>sass让你可以写css的时候可以用变量, 嵌套, 混合, 继承等. 用sass会很方便.</p><p>安装: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader sass-loader --save-dev</span><br></pre></td></tr></table></figure><p>webpack配置如下:<br>（吐槽: 终于有不一样的了）<br>现在我们要同时使用2个加载器了！第一个加载器<code>sass-loader</code>（从右向左看）会把ssass编译成css然后交给css处理, 就是之前说的创建<code>style</code>标签之类的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;css-loader!sass-loader&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>加载方式: <code>require(&#39;./src/index.scss&#39;);</code></p><h3 id="编译结果-2"><a href="#编译结果-2" class="headerlink" title="编译结果"></a>编译结果</h3><h4 id="编译前-2"><a href="#编译前-2" class="headerlink" title="编译前"></a>编译前</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$font-stack:    Helvetica, sans-serif;</span><br><span class="line">$primary-color: #333;</span><br><span class="line"> </span><br><span class="line">body &#123;</span><br><span class="line">  font: 100% $font-stack;</span><br><span class="line">  color: $primary-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译后-2"><a href="#编译后-2" class="headerlink" title="编译后"></a>编译后</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里有段less的,使用的lib是<code>less-loader</code>, 用法和sass一样的.</p><hr><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>我们可以移动任何文件, lib名字叫<code>file-loader</code>.</p><p>安装: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure><p>来看看如何配置吧: </p><p>例子里我们尝试把一个图片从他的目录里移动到指定的目录并命名成这种规范: <code>img-[hash].[ext]</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;file-loader?name=img/img-[hash:6].[ext]&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>你可以这样引入任何图片: <code>require(&#39;./src/image_big.jpg&#39;);</code></p><h3 id="编译结果-3"><a href="#编译结果-3" class="headerlink" title="编译结果"></a>编译结果</h3><p><code>./src/img.jpg</code>被复制并重命名为<code>dist/img/img-a4bd04.jpg</code></p><hr><h2 id="编码文件-encode-files"><a href="#编码文件-encode-files" class="headerlink" title="编码文件(encode files)"></a>编码文件(encode files)</h2><p>有时候你不想通过http来拿资源. 比如: 当你可以直接拿到encode过的资源的时候, 选择去http拿一个很小的图片还有什么意义呢？这个lib正是做了这个事情. 你需要做的只是决定什么编码的文件给多少限制（如果超过限制你会得到路径）.</p><p>安装: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure><p>配置如下: </p><p>如果图片小于5k我们就拿他base64encoded, 不然就路径.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;url-loader?limit=5000&amp;name=img/img-[hash:6].[ext]&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="编译结果-4"><a href="#编译结果-4" class="headerlink" title="编译结果"></a>编译结果</h3><h4 id="编译前-3"><a href="#编译前-3" class="headerlink" title="编译前"></a>编译前</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgBig = <span class="string">&#x27;&lt;img src=&quot;&#x27;</span> + <span class="built_in">require</span>(<span class="string">&quot;./src/image_big.jpg&quot;</span>) + <span class="string">&#x27;&quot; /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> imgSmall = <span class="string">&#x27;&lt;img src=&quot;&#x27;</span> + <span class="built_in">require</span>(<span class="string">&quot;./src/image_small.png&quot;</span>) + <span class="string">&#x27;&quot; /&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="编译后-3"><a href="#编译后-3" class="headerlink" title="编译后"></a>编译后</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgBig = <span class="string">&#x27;&lt;img src=&quot;img/img-a4bd04.jpg&quot; /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> imgSmall = <span class="string">&#x27;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA&quot; /&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="引入HTML文件（require-HTML-files"><a href="#引入HTML文件（require-HTML-files" class="headerlink" title="引入HTML文件（require HTML files)"></a>引入HTML文件（require HTML files)</h2><p><code>html-loader</code>可以把任何文件转成模块, 也可以引入任何图片.<br>安装: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-loader --save-dev</span><br></pre></td></tr></table></figure><p>配置: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;html-loader&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>你可以这样引入任何html文件: <code>require(&#39;./src/index.html&#39;);</code>所有图片会被转成流（就是前面的encode files）.</p><h3 id="编译结果-5"><a href="#编译结果-5" class="headerlink" title="编译结果"></a>编译结果</h3><h4 id="编译前-4"><a href="#编译前-4" class="headerlink" title="编译前"></a>编译前</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image_small.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编译后-4"><a href="#编译后-4" class="headerlink" title="编译后"></a>编译后</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;&lt;html&gt;\n    </span></span><br><span class="line"><span class="string">   &lt;head&gt;</span></span><br><span class="line"><span class="string">      \n        </span></span><br><span class="line"><span class="string">      &lt;title&gt;&lt;/title&gt;</span></span><br><span class="line"><span class="string">      \n        </span></span><br><span class="line"><span class="string">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">      \n        </span></span><br><span class="line"><span class="string">      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span></span><br><span class="line"><span class="string">      \n    </span></span><br><span class="line"><span class="string">   &lt;/head&gt;</span></span><br><span class="line"><span class="string">   \n    </span></span><br><span class="line"><span class="string">   &lt;body&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA&quot;&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">   \n</span></span><br><span class="line"><span class="string">&lt;/html&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="暴露任何模块（Expose-any-module"><a href="#暴露任何模块（Expose-any-module" class="headerlink" title="暴露任何模块（Expose any module)"></a>暴露任何模块（Expose any module)</h2><p><code>expose-loader</code>可以让你把任何模块绑定到全局作用域上.<br>安装: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install expose-loader --save-dev</span><br></pre></td></tr></table></figure><p>配置:<br>例子中我们要把<code>lodash</code>在全局作用域中暴露为<code>_</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loaders</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&quot;lodash&quot;</span>),</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;expose?_&#x27;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>现在当我们引入lodash<code>require(&#39;lodash&#39;);</code>会把他暴露给全局. 这个模块在你使用一些流行模块时是必须的.</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 入门 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular表单</title>
      <link href="/2016/08/08/angular-form/"/>
      <url>/2016/08/08/angular-form/</url>
      
        <content type="html"><![CDATA[<p>从零开始跟着文档学习angular表单</p><span id="more"></span><h2 id="表单简介"><a href="#表单简介" class="headerlink" title="表单简介"></a>表单简介</h2><p><strong>打开了angular1.5.9的form文档开始一行行了解下angular表单的东西吧</strong></p><p><em>暂时跳过的部分用这个字体表示, 以便查漏补缺</em></p><p><a href="https://docs.angularjs.org/api/ng/directive/form">写作时查看的文档地址</a></p><hr><h2 id="form行为"><a href="#form行为" class="headerlink" title="form行为"></a>form行为</h2><ul><li><em>form这个directive是提供api的, 提供了方法和属性.</em></li><li><em>如果form有<code>name</code>这个属性, form的api会挂在当前scope的这个字段下(后面会有例子).</em></li><li><em>form有个别名是<code>ng-form</code>, 作用是浏览器不允许嵌套form的, 用别名可以嵌套了, 嵌套场景可能是有父子关系的input组？</em></li></ul><hr><p>form会被加上一些class, 尝试:<br>代码中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译后变为了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;ng-pristine ng-valid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是angular的form永远会存在一些(2+个)状态class, 这很方便, 并且<code>ngAmimate</code>可以自动对这些class进行动画, 这些class为: </p><blockquote><p>ng-valid is set if the form is valid.<br>ng-invalid is set if the form is invalid.<br>ng-pending is set if the form is pending.<br>ng-pristine is set if the form is pristine.<br>ng-dirty is set if the form is dirty.<br>ng-submitted is set if the form was submitted.</p></blockquote><hr><p>因为angular的适用场景是SPA, 所以form的提交默认被阻止, 除非form上存在<code>action</code>属性.<br>所以form的提交行为就交给<code>ng-click</code>处理吧, 或者使用<code>form</code>上的<code>ng-submit</code>来指定提交动作以后执行的方法.(提交动作就是触发普通form提交的行为: 点击botton和点击type为submit的input）<br><strong>重要: 为防止重复提交,<code>ng-click</code>与<code>ng-submit</code>只能使用一种.(不是一个, 是一种)</strong><br><code>ng-click</code>执行会在<code>ng-model</code>更新前触发, 所以尽量使用<code>ng-submit</code></p><hr><p>form状态改变导致的class改变都可以和<code>ngAnimate</code>配合的, css大概是这样的(在form上加了个my-form的class来区分不同地方的动画):</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//be sure <span class="selector-tag">to</span> include ngAnimate as <span class="selector-tag">a</span> module <span class="selector-tag">to</span> hook into more</span><br><span class="line">//advanced animations</span><br><span class="line"><span class="selector-class">.my-form</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>:<span class="number">0.5s</span> linear all;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my-form</span><span class="selector-class">.ng-invalid</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h2><p>（万万没想到文档竟然这么短.）<br>文档已经教我们如何拿到form的状态了, 写个简单的form来看一下form的状态如何吧:)</p><p>html代码: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">&#x27;submit()&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;form&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">ng-model</span>=<span class="string">&#x27;a&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ng-minlength</span>=<span class="string">5</span> <span class="attr">ng-model</span>=<span class="string">&#x27;b&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">5</span> <span class="attr">ng-model</span>=<span class="string">&#x27;c&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">ng-min</span>=<span class="string">&#x27;123&#x27;</span> <span class="attr">ng-model</span>=<span class="string">&#x27;d&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;form&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我把所有input都弄成错的状态了, 以下是form的class情况和页面上打出的结果.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">&quot;submit()&quot;</span> <span class="attr">name</span>=<span class="string">&quot;form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ng-dirty ng-valid-parse ng-invalid ng-invalid-minlength ng-valid-number ng-invalid-min ng-invalid-required ng-valid-date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;$error&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;minlength&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;$viewValue&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$validators&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;$asyncValidators&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;$parsers&quot;</span>: [],</span><br><span class="line">                <span class="string">&quot;$formatters&quot;</span>: [</span><br><span class="line">                    <span class="literal">null</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;$viewChangeListeners&quot;</span>: [],</span><br><span class="line">                <span class="string">&quot;$untouched&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$touched&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$pristine&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$dirty&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$valid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$invalid&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$error&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;minlength&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;$name&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$options&quot;</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;min&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;$viewValue&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$validators&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;$asyncValidators&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;$parsers&quot;</span>: [</span><br><span class="line">                    <span class="literal">null</span>,</span><br><span class="line">                    <span class="literal">null</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;$formatters&quot;</span>: [</span><br><span class="line">                    <span class="literal">null</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;$viewChangeListeners&quot;</span>: [],</span><br><span class="line">                <span class="string">&quot;$untouched&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$touched&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$pristine&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$dirty&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$valid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$invalid&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$error&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;min&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;$name&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$options&quot;</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;required&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;$viewValue&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$validators&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;$asyncValidators&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;$parsers&quot;</span>: [],</span><br><span class="line">                <span class="string">&quot;$formatters&quot;</span>: [</span><br><span class="line">                    <span class="literal">null</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;$viewChangeListeners&quot;</span>: [],</span><br><span class="line">                <span class="string">&quot;$untouched&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$touched&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$pristine&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$dirty&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$valid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&quot;$invalid&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;$error&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;required&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;$name&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$options&quot;</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;$name&quot;</span>: <span class="string">&quot;form&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$dirty&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;$pristine&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;$valid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;$invalid&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;$submitted&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我猜想一般使用的话只要全局给个ng-invalid的样式就可以实时置红invalid的form,各个地方写验证很麻烦吧.<br>不允许提交也很简单: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button ng-disabled=<span class="string">&#x27;form.$invalid&#x27;</span>&gt;submit&lt;/button&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li>input的validator一定要配合<code>ng-model</code>食用, 否则无效.</li><li><code>ng-required</code>效果等于<code>required</code>, 以此推测pattern也是如此.</li><li>其实每个input需要去看各自的文档.</li><li>事实证明, 不去disable<code>button</code>的话angular也阻止函数执行的. disable只是样式问题.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Promise</title>
      <link href="/2016/07/23/promise-related/"/>
      <url>/2016/07/23/promise-related/</url>
      
        <content type="html"><![CDATA[<p>promise的理解于实践场景</p><span id="more"></span><h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>这条是最后加上的, 本文语法来源都是正统的, 理解却是自己的经验产生的, 包括应用, 优缺点, 作用, <strong>可能与部分朋友意见不同或者与主流观点不同.</strong> </p><h2 id="关于异步"><a href="#关于异步" class="headerlink" title="关于异步"></a>关于异步</h2><p>人是这样的:  有时候想找人说话, 有时候想静静.<br>女神想找我聊天的时候我想静静, 等我响应女神的时候他已经准备洗澡了. 同步和异步只是等不等的区别.</p><p>我与别人有时候关于同步异步有不同的看法, 在我看来同步异步只是等与不等的区别, 本质是一样的, 只是处理方式不同.</p><h2 id="关于callback"><a href="#关于callback" class="headerlink" title="关于callback"></a>关于callback</h2><p>之所以谈一下异步是因为我认为callback与promise也是一样, promise只是一个处理方式的封装, 和callback之间是可以互相替代的.</p><h2 id="promise的优缺点"><a href="#promise的优缺点" class="headerlink" title="promise的优缺点"></a>promise的优缺点</h2><h3 id="promise的优点"><a href="#promise的优点" class="headerlink" title="promise的优点"></a>promise的优点</h3><h4 id="避免callback-hell"><a href="#避免callback-hell" class="headerlink" title="避免callback hell"></a>避免callback hell</h4><p>这是聪明的你第一个会想到的.<br>以下callback伪代码: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSchoolInfo</span>(<span class="string">&#x27;spicyChickenScool&#x27;</span>, <span class="function">(<span class="params">schoolInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getGradeInfo</span>(<span class="number">2</span>, <span class="function">(<span class="params">gradeInfo</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">getClassInfo</span>(<span class="number">3</span>, (classInfo) &#123;</span><br><span class="line">            <span class="title function_">getStudent</span>(<span class="number">4</span>, <span class="function">(<span class="params">student</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//悄悄调查小姐姐的个人信息</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果以上获取信息的方式全是promise的话: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSchoolInfo</span>(<span class="string">&#x27;spicyChickenScool&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">schoolInfo</span> =&gt;</span> <span class="title function_">getGradeInfo</span>(<span class="number">2</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">gradeInfo</span> =&gt;</span> <span class="title function_">getClassInfo</span>(<span class="number">3</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">classInfo</span> =&gt;</span> <span class="title function_">getStudent</span>(<span class="number">4</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">student</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//查出了小姐姐的梦想是成为校园偶像</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>光从美观上就已分出了胜负.</p><h4 id="避免callback的copy-paste代码"><a href="#避免callback的copy-paste代码" class="headerlink" title="避免callback的copy paste代码"></a>避免callback的copy paste代码</h4><p><strong>本条添加于2016&#x2F;07&#x2F;24</strong></p><p>promise把对成功失败的处理统一放在了回调中, 而callback可能反复调用一些方法的时候会需要重复一些代码.</p><p>举个简单的例子, 对用户的所有操作（给用户设置权限、更新用户数据、把用户加入某个缓存列表）, 强调一下有许多操作, 接受了用户参数以后要去获取用户的信息, 代码类似以下: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateUser = <span class="keyword">function</span>(<span class="params">uid, filed, value, callback</span>) &#123;</span><br><span class="line">    <span class="title function_">getUser</span>(uid, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            callback &amp;&amp; <span class="title function_">callback</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">update</span>(uid, filed, value, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方便组织代码"><a href="#方便组织代码" class="headerlink" title="方便组织代码"></a>方便组织代码</h4><p>promise的形式就是为了组织代码而设计的, 下文将会仔细讲解各种实例.</p><h3 id="promise的缺点"><a href="#promise的缺点" class="headerlink" title="promise的缺点"></a>promise的缺点</h3><h4 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h4><p>promise是个憋了很久的东西了, 市面上也有不同版本和规范的promise实现, 而es2015明确表示了建议使用原生promise.<br>新的node项目可以安心使用, 对于浏览器端新东西还得做不少处理.</p><h4 id="模式问题"><a href="#模式问题" class="headerlink" title="模式问题"></a>模式问题</h4><p>怎么描述呢, 一但使用promise, 会发现非常不自由, 会期待各处返回值全是promise, 很明显大多数经典的、必须的api全是callback的, 必须包装他们, 这就成了负担, 当然新的api都已经包装成了promise.</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>promise内部异常是需要在error callback中写的, 如果不写内部异常会不抛出导致程序莫名卡死, 查bug无从下手, 导致到处打log查问题的狼狈局面.<br>具体也会在下文中详细说明.</p><h2 id="promise的实际应用情景"><a href="#promise的实际应用情景" class="headerlink" title="promise的实际应用情景"></a>promise的实际应用情景</h2><h3 id="请求服务中有某个必须参数"><a href="#请求服务中有某个必须参数" class="headerlink" title="请求服务中有某个必须参数"></a>请求服务中有某个必须参数</h3><p>模拟场景:  某个服务封装了一些统计游戏数据的请求, 大部分请求（非所有）需要带上游戏信息, 游戏信息本身就是http请求来的.<br>在特殊情况下（比如页面初始化, 获取游戏信息慢了）, 服务存储的游戏信息为空, 可能产生 <code>getNewUser/game/undefined</code>类似的尴尬情况, 为处理类似情况,聪明的你可能会想到这些办法: </p><ul><li>设置timeout</li><li>查询错误重复查询</li><li>设置是否取到游戏信息的标识, 把后续的请求建立队列重新处理</li></ul><p>如此可能还有一些问题, 还是会产生有undefined的请求, 错误处理的不方便, 或许你聪明绝顶有更好的办法, 这里只是介绍下promise的使用场景, 并不是宗教战争.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取游戏信息的服务</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">changeGame</span> = game =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">        <span class="attr">game</span>:game</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取‘pokemon’这个游戏的信息, 其他需要游戏信息的服务取这里的数据就可以</span></span><br><span class="line"><span class="keyword">var</span> curGame = <span class="title function_">changeGame</span>(<span class="string">&#x27;pokemon&#x27;</span>);</span><br><span class="line"><span class="comment">//获取某个日期新增用户的服务</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">getNewUser</span> = date =&gt; curGame</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">game</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">date</span>:date,</span><br><span class="line">            <span class="attr">game</span>:game.<span class="property">game</span>,</span><br><span class="line">            <span class="attr">newUser</span>:<span class="number">233</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;));</span><br><span class="line"><span class="comment">//如此调用</span></span><br><span class="line"><span class="title function_">getNewUser</span>(<span class="string">&#x27;20160724&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 我们获得了新增数据&#123;date: &#x27;20160724&#x27;, game: &#x27;pokemon&#x27;, newUser: 233 &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>讲一下原理, changeGame的时候就会马上发起请求, 并且一但resolve,curGame就一直是resolve状态, 调用就能直接获得结果.<br>如果发生错误可以在changeGame处理, 也能把错误传递到外部的promise, 本例子就写得很残缺了.</p><h3 id="多组有依赖关系的请求"><a href="#多组有依赖关系的请求" class="headerlink" title="多组有依赖关系的请求"></a>多组有依赖关系的请求</h3><p>模拟场景:  获取一个班级列表里第一名学生的信息. （一组请求, 每组请求都有顺序了要求.）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单模拟获取班级最强的学生和获取学生信息</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">getTopStudent</span> = clazz =&gt; <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;top student in class&#x27;</span> + clazz);</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">getStudentInfo</span> = student =&gt; <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:student,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//假设班级列表</span></span><br><span class="line"><span class="keyword">var</span> classList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//请求列表</span></span><br><span class="line"><span class="keyword">var</span> requests = [];</span><br><span class="line"><span class="comment">//开始请求</span></span><br><span class="line">classList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">clazz</span>) =&gt;</span> &#123;</span><br><span class="line">    requests.<span class="title function_">push</span>(</span><br><span class="line">        <span class="title function_">getTopStudent</span>(clazz)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">studentName</span> =&gt;</span> <span class="title function_">getStudentInfo</span>(studentName))</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取结果</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(requests)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//获得的结果为[ &#123; name: &#x27;top student in class1&#x27;, age: 18 &#125;,&#123; name: &#x27;top student in class2&#x27;, age: 18 &#125;,&#123; name: &#x27;top student in class3&#x27;, age: 18 &#125; ]</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><ul><li>如果某一个请求依赖某个上上层的结果完全可以在回掉里进行下次请求, 并不是必须写成链式.</li><li>同时向多个服务器发起请求, 使用响应最快的数据<code>Promise.race()</code>, 一系列请求全部完成再处理数据<code>Promise.all()</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码组织 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
